diff -cr --new-file -b --tabsize 4 -x CVS -x .svn -x tools pgsql-REL8_3_STABLE/src/backend/access/common/printtup.c pgsql/src/backend/access/common/printtup.c
*** pgsql-REL8_3_STABLE/src/backend/access/common/printtup.c	Tue Jan  1 20:45:45 2008
--- pgsql/src/backend/access/common/printtup.c	Thu Jan 10 19:37:51 2008
***************
*** 16,21 ****
--- 16,22 ----
  #include "postgres.h"
  
  #include "access/printtup.h"
+ #include "catalog/pg_type.h"
  #include "libpq/libpq.h"
  #include "libpq/pqformat.h"
  #include "tcop/pquery.h"
***************
*** 633,635 ****
--- 634,676 ----
  
  	pq_endmessage(&buf);
  }
+ 
+ /*
+  * datum_to_text
+  *
+  * converts Datum into text
+  * call pfree on returned pointer
+  */
+ char *
+ datum_to_text(Datum datum, bool isnull, Oid restype)
+ {
+ 	char	   *res = NULL;
+ 	Oid			typoutput;
+ 	bool		typisvarlena;
+ 	Datum		out_datum;
+ 
+ 	if (isnull)
+ 		return NULL;
+ 
+ 	if (restype == UNKNOWNOID)
+ 		restype = TEXTOID;
+ 
+ 	getTypeOutputInfo(restype, &typoutput, &typisvarlena);
+ 
+ 	/*
+ 	 * If we have a toasted datum, forcibly detoast it here to avoid
+ 	 * memory leakage inside the type's output routine.
+ 	 */
+ 	if (typisvarlena)
+ 		out_datum = PointerGetDatum(PG_DETOAST_DATUM(datum));
+ 	else
+ 		out_datum = datum;
+ 
+ 	res = OidOutputFunctionCall(typoutput, out_datum);
+ 
+ 	/* Clean up detoasted copy, if any */
+ 	if (out_datum != datum)
+ 		pfree(DatumGetPointer(out_datum));
+ 
+ 	return res;
+ }
diff -cr --new-file -b --tabsize 4 -x CVS -x .svn -x tools pgsql-REL8_3_STABLE/src/backend/commands/explain.c pgsql/src/backend/commands/explain.c
*** pgsql-REL8_3_STABLE/src/backend/commands/explain.c	Tue Jan  1 20:45:49 2008
--- pgsql/src/backend/commands/explain.c	Tue Mar  4 14:24:13 2008
***************
*** 31,36 ****
--- 31,37 ----
  #include "utils/guc.h"
  #include "utils/lsyscache.h"
  #include "utils/tuplesort.h"
+ #include "utils/skyline.h"
  
  
  /* Hook for plugins to get control in ExplainOneQuery() */
***************
*** 68,73 ****
--- 69,78 ----
  static void show_sort_keys(Plan *sortplan, int nkeys, AttrNumber *keycols,
  			   const char *qlabel,
  			   StringInfo str, int indent, ExplainState *es);
+ static void show_skyline_details(Skyline *skyline, char *nodename,
+ 			   StringInfo str, int indent, ExplainState *es);
+ static void show_skyline_info(SkylineState *skylinestate, char *nodename,
+ 			   StringInfo str, int indent, ExplainState *es);
  static void show_sort_info(SortState *sortstate,
  			   StringInfo str, int indent, ExplainState *es);
  static const char *explain_get_index_name(Oid indexId);
***************
*** 564,569 ****
--- 569,580 ----
  		case T_Sort:
  			pname = "Sort";
  			break;
+ 		case T_Skyline:
+ 			pname = "Skyline";
+ 			break;
+ 		case T_ElimFilter:
+ 			pname = "Elimination Filter";
+ 			break;
  		case T_Group:
  			pname = "Group";
  			break;
***************
*** 848,853 ****
--- 859,886 ----
  							"Filter", plan,
  							str, indent, es);
  			break;
+ 		case T_Skyline:
+ 			show_sort_keys(plan,
+ 						   ((Skyline *) plan)->numCols,
+ 						   ((Skyline *) plan)->skylineColIdx,
+ 						   "Skyline Attr",
+ 						   str, indent, es);
+ 			show_skyline_details((Skyline *) plan, "Skyline",
+ 								 str, indent, es);
+ 			show_skyline_info((SkylineState *) planstate, "Skyline",
+ 							  str, indent, es);
+ 			break;
+ 		case T_ElimFilter:
+ 			show_sort_keys(plan,
+ 						   ((Skyline *) plan)->numCols,
+ 						   ((Skyline *) plan)->skylineColIdx,
+ 						   "Elim Filter Attr",
+ 						   str, indent, es);
+ 			show_skyline_details((Skyline *) plan, "Elim Filter",
+ 								 str, indent, es);
+ 			show_skyline_info((SkylineState *) planstate, "Elim Filter",
+ 							  str, indent, es);
+ 			break;
  		case T_Sort:
  			show_sort_keys(plan,
  						   ((Sort *) plan)->numCols,
***************
*** 1163,1168 ****
--- 1196,1268 ----
  }
  
  /*
+  * Show the method details for a Skyline node.
+  */
+ static void
+ show_skyline_details(Skyline *skyline, char *nodename,
+ 					 StringInfo str, int indent, ExplainState *es)
+ {
+ 	int			i;
+ 
+ 	for (i = 0; i < indent; i++)
+ 		appendStringInfo(str, "  ");
+ 
+ 	appendStringInfo(str, "  %s Method: %s%s %d dim\n",
+ 		nodename,
+ 		skyline_method_name(skyline->skyline_method), 
+ 		skyline->skyline_distinct ? " distinct" : "",
+ 		skyline->numCols);
+ }
+ 
+ /*
+  * If it's EXPLAIN ANALYZE, show skyline explain info for the skyline node
+  */
+ static void
+ show_skyline_info(SkylineState *skylinestate, char *nodename,
+ 				  StringInfo str, int indent, ExplainState *es)
+ {
+ 	Assert(IsA(skylinestate, SkylineState) || IsA(skylinestate, ElimFilterState));
+ 	if (es->printAnalyze && skylinestate->status == SS_DONE)
+ 	{
+ 		int			i;
+ 		
+ 		if (skylinestate->skyline_method == SM_BLOCKNESTEDLOOP
+ 			|| skylinestate->skyline_method == SM_SFS
+ 			|| skylinestate->skyline_method == SM_ELIMFILTER)
+ 		{
+ 			for (i = 0; i < indent; i++)
+ 				appendStringInfo(str, "  ");
+ 			
+ 			appendStringInfo(str, "  %s Stats: passes=%lld", 
+ 							 nodename, 
+ 							 skylinestate->pass);
+ 			appendStringInfo(str, " rows=%s", skylinestate->pass_info->data);
+ 			appendStringInfo(str, "\n");
+ 
+ 			for (i = 0; i < indent; i++)
+ 				appendStringInfo(str, "  ");
+ 
+ 			appendStringInfo(str, "  %s Window:", nodename);
+ 			if (skylinestate->windowsize != -1)
+ 				appendStringInfo(str, " size=%dk", skylinestate->windowsize);
+ 			if (skylinestate->windowslots != -1)
+ 				appendStringInfo(str, " slots=%d", skylinestate->windowslots);
+ 			appendStringInfo(str, " policy=%s", 
+ 							 skyline_window_policy_name(skylinestate->window_policy));
+ 			appendStringInfo(str, "\n");
+ 		}
+ 
+ 		for (i = 0; i < indent; i++)
+ 			appendStringInfo(str, "  ");
+ 
+ 		appendStringInfo(str, "  %s Cmps: tuples=%lld fields=%lld\n",
+ 						 nodename,
+ 						 skylinestate->cmps_tuples,
+ 						 skylinestate->cmps_fields);
+ 	}
+ }
+ 
+ /*
   * If it's EXPLAIN ANALYZE, show tuplesort explain info for a sort node
   */
  static void
diff -cr --new-file -b --tabsize 4 -x CVS -x .svn -x tools pgsql-REL8_3_STABLE/src/backend/executor/Makefile pgsql/src/backend/executor/Makefile
*** pgsql-REL8_3_STABLE/src/backend/executor/Makefile	Mon Jun 11 03:16:22 2007
--- pgsql/src/backend/executor/Makefile	Fri Oct  5 22:50:46 2007
***************
*** 20,27 ****
         nodeHashjoin.o nodeIndexscan.o nodeMaterial.o nodeMergejoin.o \
         nodeNestloop.o nodeFunctionscan.o nodeResult.o nodeSeqscan.o \
         nodeSetOp.o nodeSort.o nodeUnique.o \
!        nodeValuesscan.o nodeLimit.o nodeGroup.o \
!        nodeSubplan.o nodeSubqueryscan.o nodeTidscan.o tstoreReceiver.o spi.o
  
  all: SUBSYS.o
  
--- 20,28 ----
         nodeHashjoin.o nodeIndexscan.o nodeMaterial.o nodeMergejoin.o \
         nodeNestloop.o nodeFunctionscan.o nodeResult.o nodeSeqscan.o \
         nodeSetOp.o nodeSort.o nodeUnique.o \
!        nodeValuesscan.o nodeLimit.o nodeGroup.o nodeSkyline.o \
!        nodeSubplan.o nodeSubqueryscan.o nodeTidscan.o tstoreReceiver.o spi.o \
!        nodeElimFilter.o
  
  all: SUBSYS.o
  
diff -cr --new-file -b --tabsize 4 -x CVS -x .svn -x tools pgsql-REL8_3_STABLE/src/backend/executor/execAmi.c pgsql/src/backend/executor/execAmi.c
*** pgsql-REL8_3_STABLE/src/backend/executor/execAmi.c	Tue Aug  5 23:28:36 2008
--- pgsql/src/backend/executor/execAmi.c	Tue Nov 11 22:46:08 2008
***************
*** 20,25 ****
--- 20,26 ----
  #include "executor/nodeBitmapHeapscan.h"
  #include "executor/nodeBitmapIndexscan.h"
  #include "executor/nodeBitmapOr.h"
+ #include "executor/nodeElimFilter.h"
  #include "executor/nodeFunctionscan.h"
  #include "executor/nodeGroup.h"
  #include "executor/nodeGroup.h"
***************
*** 33,38 ****
--- 34,40 ----
  #include "executor/nodeResult.h"
  #include "executor/nodeSeqscan.h"
  #include "executor/nodeSetOp.h"
+ #include "executor/nodeSkyline.h"
  #include "executor/nodeSort.h"
  #include "executor/nodeSubplan.h"
  #include "executor/nodeSubqueryscan.h"
***************
*** 185,190 ****
--- 187,200 ----
  			ExecReScanGroup((GroupState *) node, exprCtxt);
  			break;
  
+ 		case T_SkylineState:
+ 			ExecReScanSkyline((SkylineState *) node, exprCtxt);
+ 			break;
+ 
+ 		case T_ElimFilterState:
+ 			ExecReScanElimFilter((ElimFilterState *) node, exprCtxt);
+ 			break;
+ 
  		case T_AggState:
  			ExecReScanAgg((AggState *) node, exprCtxt);
  			break;
***************
*** 469,474 ****
--- 479,485 ----
  		case T_MaterialState:
  		case T_UniqueState:
  		case T_LimitState:
+ 		case T_ElimFilterState:
  			return ExecMayReturnRawTuples(node->lefttree);
          
  		case T_AppendState:
***************
*** 485,490 ****
--- 496,507 ----
  			}
  
  			/* All projecting node types come here */
+ 		/*
+ 		 * FIXME: skyline does not project yet
+ 		 */
+ 		case T_SkylineState:
+ 			return ExecMayReturnRawTuples(node->lefttree);
+ 
  		default:
  			break;
  	}
diff -cr --new-file -b --tabsize 4 -x CVS -x .svn -x tools pgsql-REL8_3_STABLE/src/backend/executor/execProcnode.c pgsql/src/backend/executor/execProcnode.c
*** pgsql-REL8_3_STABLE/src/backend/executor/execProcnode.c	Tue Jan  1 20:45:49 2008
--- pgsql/src/backend/executor/execProcnode.c	Thu Jan 10 19:37:14 2008
***************
*** 85,90 ****
--- 85,91 ----
  #include "executor/nodeBitmapHeapscan.h"
  #include "executor/nodeBitmapIndexscan.h"
  #include "executor/nodeBitmapOr.h"
+ #include "executor/nodeElimFilter.h"
  #include "executor/nodeFunctionscan.h"
  #include "executor/nodeGroup.h"
  #include "executor/nodeHash.h"
***************
*** 97,102 ****
--- 98,104 ----
  #include "executor/nodeResult.h"
  #include "executor/nodeSeqscan.h"
  #include "executor/nodeSetOp.h"
+ #include "executor/nodeSkyline.h"
  #include "executor/nodeSort.h"
  #include "executor/nodeSubplan.h"
  #include "executor/nodeSubqueryscan.h"
***************
*** 236,241 ****
--- 238,253 ----
  												 estate, eflags);
  			break;
  
+ 		case T_Skyline:
+ 			result = (PlanState *) ExecInitSkyline((Skyline *) node,
+ 												   estate, eflags);
+ 			break;
+ 
+ 		case T_ElimFilter:
+ 			result = (PlanState *) ExecInitElimFilter((ElimFilter *) node,
+ 													  estate, eflags);
+ 			break;
+ 
  		case T_Agg:
  			result = (PlanState *) ExecInitAgg((Agg *) node,
  											   estate, eflags);
***************
*** 386,391 ****
--- 398,411 ----
  			result = ExecSort((SortState *) node);
  			break;
  
+ 		case T_SkylineState:
+ 			result = ExecSkyline((SkylineState *) node);
+ 			break;
+ 
+ 		case T_ElimFilterState:
+ 			result = ExecElimFilter((ElimFilterState *) node);
+ 			break;
+ 
  		case T_GroupState:
  			result = ExecGroup((GroupState *) node);
  			break;
***************
*** 558,563 ****
--- 578,589 ----
  		case T_Group:
  			return ExecCountSlotsGroup((Group *) node);
  
+ 		case T_Skyline:
+ 			return ExecCountSlotsSkyline((Skyline *) node);
+ 
+ 		case T_ElimFilter:
+ 			return ExecCountSlotsElimFilter((ElimFilter *) node);
+ 
  		case T_Agg:
  			return ExecCountSlotsAgg((Agg *) node);
  
***************
*** 689,694 ****
--- 715,728 ----
  			ExecEndSort((SortState *) node);
  			break;
  
+ 		case T_SkylineState:
+ 			ExecEndSkyline((SkylineState *) node);
+ 			break;
+ 
+ 		case T_ElimFilterState:
+ 			ExecEndElimFilter((ElimFilterState *) node);
+ 			break;
+ 
  		case T_GroupState:
  			ExecEndGroup((GroupState *) node);
  			break;
diff -cr --new-file -b --tabsize 4 -x CVS -x .svn -x tools pgsql-REL8_3_STABLE/src/backend/executor/nodeElimFilter.c pgsql/src/backend/executor/nodeElimFilter.c
*** pgsql-REL8_3_STABLE/src/backend/executor/nodeElimFilter.c	Thu Jan  1 01:00:00 1970
--- pgsql/src/backend/executor/nodeElimFilter.c	Tue Nov 11 21:16:59 2008
***************
*** 0 ****
--- 1,287 ----
+ /*-------------------------------------------------------------------------
+  *
+  * nodeElimFilter.c
+  *	  Routines to handle skyline LESS elimination Filter
+  *
+  * Portions Copyright (c) 2008, PostgreSQL Global Development Group
+  * Portions Copyright (c) 2007-2008, Hannes Eder
+  *
+  *
+  * DESCRIPTION
+  *	  FIXME
+  *
+  * IDENTIFICATION
+  *	  $PostgreSQL: $
+  *
+  *-------------------------------------------------------------------------
+  */
+ 
+ #include "postgres.h"
+ 
+ #include "executor/executor.h"
+ #include "executor/nodeElimFilter.h"
+ #include "utils/tuplewindow.h"
+ #include "utils/skyline.h"
+ 
+ /*
+  * ExecElimFilterInitTupleWindow
+  *
+  *	FIXME
+  */
+ static void
+ ExecElimFilterInitTupleWindow(SkylineState *state, Skyline *node)
+ {
+ 	int			window_size = BLCKSZ / 1024;	/* allocate a page */
+ 	int			window_slots = -1;
+ 	TupleWindowPolicy	window_policy = TUP_WIN_POLICY_APPEND;
+ 
+ 	Assert(state != NULL);
+ 
+ 	if (state->window != NULL)
+ 	{
+ 		tuplewindow_end(state->window);
+ 		state->window = NULL;
+ 	}
+ 
+ 	/*
+ 	 * Can be overrided by an option, otherwise use entire
+ 	 * work_mem.
+ 	 */
+ 	skyline_option_get_int(node->skyline_of_options, "efwindow", &window_size) ||
+ 		skyline_option_get_int(node->skyline_of_options, "efwindowsize", &window_size);
+ 
+ 	skyline_option_get_int(node->skyline_of_options, "efslots", &window_slots) ||
+ 		skyline_option_get_int(node->skyline_of_options, "efwindowslots", &window_slots);
+ 
+ 	if (window_slots == 0)
+ 	{
+ 		/*
+ 		 * If window_slots == -1, then we constrain the tuple window in
+ 		 * terms of memory.
+ 		 */
+ 		elog(ERROR, "tuple window must have at least one slot");
+ 	}
+ 
+ 	state->window = tuplewindow_begin(window_size, window_slots, state->window_policy);
+ 
+ 	state->windowsize = window_size;
+ 	state->windowslots = window_slots;
+ }
+ 
+ /*
+  * ExecInitElimFilter
+  *
+  *	FIXME
+  */
+ ElimFilterState *
+ ExecInitElimFilter(ElimFilter *node, EState *estate, int eflags)
+ {
+ 	ElimFilterState	   *state;
+ 
+ 	state = makeNode(ElimFilterState);
+ 	state->ss.ps.plan = (Plan *) node;
+ 	state->ss.ps.state = estate;
+ 
+ 	state->status = SS_INIT;
+ 	state->skyline_method = node->skyline_method;
+ 	state->pass = 1;
+ 
+ 	state->cmps_tuples = 0;
+ 	state->cmps_fields = 0;
+ 	state->pass_info = makeStringInfo();
+ 	state->flags = SL_FLAGS_NONE;
+ 	state->window_policy = TUP_WIN_POLICY_APPEND;
+ 
+ 	skyline_option_get_window_policy(node->skyline_of_options, "efwindowpolicy", &state->window_policy);
+ 
+ 	/*
+ 	 * If we do not have stats for at least one column, fall back from
+ 	 * window policy "ranked" back to "append".
+ 	 */
+ 	if (state->window_policy == TUP_WIN_POLICY_ENTROPY && !(node->flags & SKYLINE_FLAGS_HAVE_STATS))
+ 	{
+ 		state->window_policy = TUP_WIN_POLICY_APPEND;
+ 		elog(INFO, "no stats for skyline expressions available, falling back to window policy \"append\"");
+ 	}
+ 
+ 	if (state->window_policy == TUP_WIN_POLICY_ENTROPY)
+ 		state->flags |= SL_FLAGS_RANKED | SL_FLAGS_ENTROPY;
+ 	else if (state->window_policy == TUP_WIN_POLICY_RANDOM)
+ 		state->flags |= SL_FLAGS_RANKED | SL_FLAGS_RANDOM;
+ 
+ 	ExecElimFilterInitTupleWindow(state, node);
+ 
+ #define ELIMFILTER_NSLOTS 2
+ 
+ 	/*
+ 	 * tuple table initialization
+ 	 */
+ 	ExecInitScanTupleSlot(estate, &state->ss);
+ 	ExecInitResultTupleSlot(estate, &state->ss.ps);
+ 
+ 	/*
+ 	 * initialize child expressions
+ 	 */
+ 	state->ss.ps.targetlist = (List *)
+ 		ExecInitExpr((Expr *) node->plan.targetlist,
+ 					 (PlanState *) state);
+ 	state->ss.ps.qual = (List *)
+ 		ExecInitExpr((Expr *) node->plan.qual,
+ 					 (PlanState *) state);
+ 
+ 	/*
+ 	 * initialize child nodes
+ 	 */
+ 	outerPlanState(state) = ExecInitNode(outerPlan(node), estate, eflags);
+ 
+ 	/*
+ 	 * Initialize tuple type.  
+ 	 */
+ 	ExecAssignResultTypeFromTL(&state->ss.ps);
+ 	ExecAssignScanTypeFromOuterPlan(&state->ss);
+ 	ExecAssignProjectionInfo(&state->ss.ps, NULL);
+ 	
+ 	ExecSkylineCacheCompareFunctionInfo(state, node);
+ 	ExecSkylineCacheCoerceFunctionInfo(state, node);
+ 
+ 	return state;
+ }
+ 
+ /*
+  * ExecCountSlotsElimFilter
+  *
+  *	FIXME
+  */
+ int
+ ExecCountSlotsElimFilter(ElimFilter *node)
+ {
+ 	return ExecCountSlotsNode(outerPlan(node)) + ELIMFILTER_NSLOTS;
+ }
+ 
+ /*
+  * ExecEndElimFilter
+  *
+  *	FIXME
+  */
+ void
+ ExecEndElimFilter(ElimFilterState *state)
+ {
+ 	/*
+ 	 * clean out the tuple table
+ 	 */
+ 	ExecClearTuple(state->ss.ss_ScanTupleSlot);
+ 	ExecClearTuple(state->ss.ps.ps_ResultTupleSlot);
+ 
+ 	/*
+ 	 * shut down the subplan
+ 	 */
+ 	ExecEndNode(outerPlanState(state));
+ }
+ 
+ /*
+  * ExecReScanElimFilter
+  *
+  *	FIXME
+  */
+ void
+ ExecReScanElimFilter(ElimFilterState *state, ExprContext *exprCtxt)
+ {
+ 	/* FIXME: code coverage = 0 !!! */
+ 
+ 	state->status = SS_INIT;
+ 
+ 	/* must clear first tuple */
+ 	ExecClearTuple(state->ss.ss_ScanTupleSlot);
+ 
+ 	if (((PlanState *) state)->lefttree &&
+ 		((PlanState *) state)->lefttree->chgParam == NULL)
+ 		ExecReScan(((PlanState *) state)->lefttree, exprCtxt);
+ 
+ 	/* reinit tuple window */
+ 	ExecElimFilterInitTupleWindow(state, (Skyline *) state->ss.ps.plan);
+ 
+ 	/* FIXME: there is maybe more that need to be done here */
+ }
+ 
+ /*
+  * ExecElimFilter
+  *
+  *	FIXME
+  */
+ TupleTableSlot *
+ ExecElimFilter(ElimFilterState *state)
+ {
+ 	TupleWindowState   *window = state->window;
+ 	TupleTableSlot	   *inner_slot = state->ss.ps.ps_ResultTupleSlot;
+ 	TupleTableSlot	   *slot;
+ 	ElimFilter		   *plan = (ElimFilter *) state->ss.ps.plan;
+ 
+ 	for (;;)
+ 	{
+ 		switch (state->status)
+ 		{
+ 			case SS_INIT:
+ 				state->status = SS_PROCESS;
+ 				break;
+ 
+ 			case SS_PROCESS:
+ 				slot = ExecProcNode(outerPlanState(state));
+ 
+ 				if (TupIsNull(slot))
+ 				{
+ 					state->status = SS_DONE;
+ 					return NULL;
+ 				}
+ 
+ 				tuplewindow_rewind(window);
+ 				if (state->flags & SL_FLAGS_RANKED)
+ 				{
+ 					if (state->flags & SL_FLAGS_ENTROPY)
+ 						tuplewindow_setinsertrank(window, ExecSkylineRank(state, slot));
+ 					else if (state->flags & SL_FLAGS_RANDOM)
+ 						tuplewindow_setinsertrank(window, ExecSkylineRandom());
+ 					else
+ 						Assert(0);
+ 				}
+ 				for (;;)
+ 				{
+ 					int cmp;
+ 
+ 					if (tuplewindow_ateof(window))
+ 					{
+ 						tuplewindow_puttupleslot(window, slot, 0, true);
+ 
+ 						return slot;
+ 					}
+ 
+ 					tuplewindow_gettupleslot(window, inner_slot, false);
+ 
+ 					cmp = ExecSkylineIsDominating(state, inner_slot, slot);
+ 
+ 					/*
+ 					 * The tuple in slot is dominated by a inner_slot in
+ 					 * the window, so fetch the next.
+ 					 */
+ 					if (cmp == SKYLINE_CMP_FIRST_DOMINATES || (cmp == SKYLINE_CMP_ALL_EQ && plan->skyline_distinct))
+ 						break;
+ 					else if (cmp == SYKLINE_CMP_SECOND_DOMINATES)
+ 					{
+ 						tuplewindow_removecurrent(window);
+ 					}
+ 					else
+ 					{
+ 						tuplewindow_movenext(window);
+ 					}
+ 				}
+ 				break;
+ 
+ 			case SS_DONE:
+ 				return NULL;
+ 
+ 			default:
+ 				/* Invalid State */
+ 				AssertState(0);
+  				return NULL;
+ 		}
+ 	}
+ }
diff -cr --new-file -b --tabsize 4 -x CVS -x .svn -x tools pgsql-REL8_3_STABLE/src/backend/executor/nodeSkyline.c pgsql/src/backend/executor/nodeSkyline.c
*** pgsql-REL8_3_STABLE/src/backend/executor/nodeSkyline.c	Thu Jan  1 01:00:00 1970
--- pgsql/src/backend/executor/nodeSkyline.c	Tue Nov 11 23:57:37 2008
***************
*** 0 ****
--- 1,1363 ----
+ /*-------------------------------------------------------------------------
+  *
+  * nodeSkyline.c
+  *	  Routines to handle skyline nodes (used for queries with SKYLINE OF clause).
+  *
+  * Portions Copyright (c) 2008, PostgreSQL Global Development Group
+  * Portions Copyright (c) 2007-2008, Hannes Eder
+  *
+  *
+  * DESCRIPTION
+  *	  FIXME
+  *
+  * IDENTIFICATION
+  *	  $PostgreSQL: $
+  *
+  *-------------------------------------------------------------------------
+  */
+ 
+ #include "postgres.h"
+ 
+ #include "access/nbtree.h"
+ #include "executor/execdebug.h"
+ #include "executor/executor.h"
+ #include "executor/nodeSkyline.h"
+ #include "miscadmin.h"
+ #include "utils/datum.h"
+ #include "utils/tuplesort.h"
+ #include "utils/tuplestore.h"
+ #include "utils/tuplewindow.h"
+ #include "utils/lsyscache.h"
+ #include "utils/skyline.h"
+ 
+ /*
+  * Inline-able copy of FunctionCall2() to save some cycles in sorting.
+  */
+ /* TODO: this is from tublesort.c, export it there */
+ static inline Datum
+ myFunctionCall2(FmgrInfo *flinfo, Datum arg1, Datum arg2)
+ {
+ 	FunctionCallInfoData fcinfo;
+ 	Datum		result;
+ 
+ 	InitFunctionCallInfoData(fcinfo, flinfo, 2, NULL, NULL);
+ 
+ 	fcinfo.arg[0] = arg1;
+ 	fcinfo.arg[1] = arg2;
+ 	fcinfo.argnull[0] = false;
+ 	fcinfo.argnull[1] = false;
+ 
+ 	result = FunctionCallInvoke(&fcinfo);
+ 
+ 	/* Check for null result, since caller is clearly not expecting one */
+ 	if (fcinfo.isnull)
+ 		elog(ERROR, "function %u returned NULL", fcinfo.flinfo->fn_oid);
+ 
+ 	return result;
+ }
+ 
+ /*
+  * Apply a compare (sort) function (by now converted to fmgr lookup form)
+  * and return a 3-way comparison result.  This takes care of handling
+  * reverse-sort and NULLs-ordering properly.  We assume that DESC and
+  * NULLS_FIRST options are encoded in sk_flags the same way btree does it.
+  */
+ /* TODO: this is from tublesort.c, export it there */
+ static inline int32
+ inlineApplyCompareFunction(FmgrInfo *compFunction, int sk_flags,
+ 						   Datum datum1, bool isNull1,
+ 						   Datum datum2, bool isNull2)
+ {
+ 	int32		compare;
+ 
+ 	if (isNull1)
+ 	{
+ 		if (isNull2)
+ 			compare = 0;		/* NULL "=" NULL */
+ 		else if (sk_flags & SK_BT_NULLS_FIRST)
+ 			compare = -1;		/* NULL "<" NOT_NULL */
+ 		else
+ 			compare = 1;		/* NULL ">" NOT_NULL */
+ 	}
+ 	else if (isNull2)
+ 	{
+ 		if (sk_flags & SK_BT_NULLS_FIRST)
+ 			compare = 1;		/* NOT_NULL ">" NULL */
+ 		else
+ 			compare = -1;		/* NOT_NULL "<" NULL */
+ 	}
+ 	else
+ 	{
+ 		compare = DatumGetInt32(myFunctionCall2(compFunction,
+ 												datum1, datum2));
+ 
+ 		if (sk_flags & SK_BT_DESC)
+ 			compare = -compare;
+ 	}
+ 
+ 	return compare;
+ }
+ 
+ /*
+  * ExecSkylineIsDominating
+  *
+  *	FIXME
+  */
+ int
+ ExecSkylineIsDominating(SkylineState *state, TupleTableSlot *inner_slot, TupleTableSlot *slot)
+ {
+ 	Skyline    *node = (Skyline *) state->ss.ps.plan;
+ 	int			i;
+ 	bool		cmp_all_eq = true;
+ 	bool		cmp_lt = false;
+ 	bool		cmp_gt = false;
+ 
+ 	/* collect statistics */
+ 	state->cmps_tuples++;
+ 
+ 	for (i = 0; i < node->numCols; ++i)
+ 	{
+ 		Datum		datum1;
+ 		Datum		datum2;
+ 		bool		isnull1;
+ 		bool		isnull2;
+ 		int			attnum = node->skylineColIdx[i];
+ 		int			cmp;
+ 
+ 		/* collect statistics */
+ 		state->cmps_fields++;
+ 
+ 		datum1 = slot_getattr(inner_slot, attnum, &isnull1);
+ 		datum2 = slot_getattr(slot, attnum, &isnull2);
+ 
+ 		cmp = inlineApplyCompareFunction(&(state->compareOpFn[i]), state->compareFlags[i], datum1, isnull1, datum2, isnull2);
+ 
+ 		cmp_all_eq &= (cmp == 0);
+ 
+ 		switch (node->skylineOfDir[i])
+ 		{
+ 			case SKYLINEOF_DEFAULT:
+ 			case SKYLINEOF_MIN:
+ 			case SKYLINEOF_MAX:
+ 			case SKYLINEOF_USING:
+ 				if (cmp < 0)
+ 				{
+ 					cmp_lt = true;
+ 					if (cmp_gt)
+ 						return SKYLINE_CMP_INCOMPARABLE;
+ 				}
+ 				else if (cmp > 0)
+ 				{
+ 					cmp_gt = true;
+ 					if (cmp_lt)
+ 						return SKYLINE_CMP_INCOMPARABLE;
+ 				}
+ 
+ 				break;
+ 			case SKYLINEOF_DIFF:
+ 				/*
+ 				 * FIXME: For SFS if we sort first on all the DIFF attrs
+ 				 * then we could flush the tuple window in this case.
+ 				 * Return SKYLINE_CMP_DIFF_GRP_DIFF to indicate this
+ 				 *
+ 				 * FIXME: we could use SKYLINE_CMP_DIFF_GRP_DIFF for all
+ 				 * other methods in the same places as SKYLINE_CMP_DIFF_GRP_DIFF
+ 				 */
+ 				if (cmp != 0)
+ 					return SKYLINE_CMP_INCOMPARABLE;
+ 				break;
+ 			default:
+ 				elog(ERROR, "unrecognized skylineof_dir: %d", node->skylineOfDir[i]);
+ 				break;
+ 		}
+ 	}
+ 
+ 	if (cmp_all_eq)
+ 		return SKYLINE_CMP_ALL_EQ;
+ 
+ 	if (cmp_lt)
+ 		return SKYLINE_CMP_FIRST_DOMINATES;
+ 
+ 	if (cmp_gt)
+ 		return SYKLINE_CMP_SECOND_DOMINATES;
+ 
+ 	return SKYLINE_CMP_INCOMPARABLE;
+ }
+ 
+ /*
+  * ExecSkylineRank
+  *
+  *  FIXME
+  */
+ 
+ double
+ ExecSkylineRank(SkylineState *state, TupleTableSlot *slot)
+ {
+ 	Skyline    *node = (Skyline *) state->ss.ps.plan;
+ 	double		res = 0.0;
+ 	int			i;
+ 
+ 	for (i = 0; i < node->numCols; ++i)
+ 	{
+ 		Datum		datum;
+ 		double		value;
+ 		bool		isnull;
+ 		int			attnum;
+ 		int			sk_flags;
+ 
+ 		/* DIFF does not count for ranking */
+ 		if (node->skylineOfDir[i] == SKYLINEOF_DIFF)
+ 			continue;
+ 
+ 		/*
+ 		 * If we do not have stats, than we can't scale the column, so
+ 		 * skip it.
+ 		 */
+ 		if ((node->colFlags[i] & SKYLINE_FLAGS_HAVE_STATS) == 0)
+ 			continue;
+ 
+ 		attnum =  node->skylineColIdx[i];
+ 		sk_flags = state->compareFlags[i];
+ 
+ 		datum = slot_getattr(slot, attnum, &isnull);
+ 
+ 		if (isnull)
+ 		{
+ 			if (sk_flags & SK_BT_NULLS_FIRST)
+ 				value = SKYLINE_RANK_BOUND_MIN;
+ 			else
+ 				value = SKYLINE_RANK_BOUND_MAX;
+ 		}
+ 		else
+ 		{
+ 			/*
+ 			 * Coerce the datum into FLOAT8OID first if needed.
+ 			 */
+ 			if (node->colFlags[i] & SKYLINE_FLAGS_COERCE_FUNC)
+ 			{
+ 				FunctionCallInfoData fcinfo;
+ 				InitFunctionCallInfoData(fcinfo, &state->coerceFn[i], 1, NULL, NULL);
+ 				fcinfo.arg[0] = datum;
+ 				fcinfo.argnull[0] = false;
+ 				datum = FunctionCallInvoke(&fcinfo);
+ 				/* Check for null result */
+ 				if (fcinfo.isnull)
+ 					elog(ERROR, "function %u returned NULL", state->coerceFn[i].fn_oid);
+ 			}
+ 
+ 			value = DatumGetFloat8(datum);
+ 
+ 			/*
+ 			 * Shift and scale the value into the interval
+ 			 * [SKYLINE_RANK_BOUND_MIN, SKYLINE_RANK_BOUND_MAX].
+ 			 */
+ 			value -= node->colMin[i];
+ 			value *= node->colScale[i];
+ 
+ 			/* 
+ 			 * If we do not have very good estimations for the range, make sure that
+ 			 * 'value' is with the range [SKYLINE_RANK_BOUND_MIN, SKYLINE_RANK_BOUND_MAX].
+ 			 */
+ 			if (value <= SKYLINE_RANK_BOUND_MIN)
+ 				value = SKYLINE_RANK_BOUND_MIN;
+ 			else if (value >= SKYLINE_RANK_BOUND_MAX)
+ 				value = SKYLINE_RANK_BOUND_MAX;
+ 		}
+ 
+ 		if (sk_flags & SK_BT_DESC)
+ 			value = SKYLINE_RANK_BOUND_MAX - value;
+ 
+ 		res -= log(value+1.0);
+ 	}
+ 
+ 	return res;
+ }
+ 
+ /*
+  * ExecSkylineRandom
+  *
+  *  Returns a random number within [0.0, 1.0).
+  */
+ double
+ ExecSkylineRandom()
+ {
+ 	return (double) random() / ((double) MAX_RANDOM_VALUE + 1);
+ }
+ 
+ /*
+  * ExecSkylineCacheCompareFunctionInfo
+  *
+  *	FIXME
+  */
+ void
+ ExecSkylineCacheCompareFunctionInfo(SkylineState *state, Skyline *node)
+ {
+ 	int			i;
+ 
+ 	state->compareOpFn = (FmgrInfo *) palloc(node->numCols * sizeof(FmgrInfo));
+ 	state->compareFlags = (int *) palloc(node->numCols * sizeof(int));
+ 
+ 	for (i = 0; i < node->numCols; ++i)
+ 	{
+ 		Oid			compareFunction;
+ 		SelectSortFunction(node->skylineOfOperators[i], 
+ 						   node->nullsFirst[i], 
+ 						   &compareFunction,
+ 						   &state->compareFlags[i]);
+ 		fmgr_info(compareFunction, &(state->compareOpFn[i]));
+ 	}
+ }
+ 
+ /*
+  * ExecSkylineCacheCoerceFunctionInfo
+  *
+  *  FIXME
+  */
+ void
+ ExecSkylineCacheCoerceFunctionInfo(SkylineState *state, Skyline *node)
+ {
+ 	int			i;
+ 
+ 	state->coerceFn = (FmgrInfo *) palloc(node->numCols * sizeof(FmgrInfo));
+ 
+ 	for (i = 0; i < node->numCols; ++i)
+ 	{
+ 		if (node->colCoerceFunc[i] != InvalidOid)
+ 			fmgr_info(node->colCoerceFunc[i], &(state->coerceFn[i]));
+ 	}
+ }
+ 
+ /*
+  * ExecSkylineNeedExtraSlot
+  *
+  *	FIXME
+  */
+ static bool
+ ExecSkylineNeedExtraSlot(Skyline *node)
+ {
+ 	switch (node->skyline_method)
+ 	{
+ 		case SM_BLOCKNESTEDLOOP:
+ 		case SM_SFS:
+ 			return true;
+ 
+ 		default:
+ 			return false;
+ 	}
+ }
+ 
+ /*
+  * ExecSkylineInitTupleWindow
+  *
+  *	FIXME
+  */
+ static void
+ ExecSkylineInitTupleWindow(SkylineState *state, Skyline *node)
+ {
+ 	int			window_size = work_mem;
+ 	int			window_slots = -1;
+ 
+ 	Assert(state != NULL);
+ 
+ 	if (state->skyline_method == SM_BLOCKNESTEDLOOP
+ 		|| state->skyline_method == SM_SFS)
+ 	{
+ 		if (state->window != NULL)
+ 		{
+ 			tuplewindow_end(state->window);
+ 			state->window = NULL;
+ 		}
+ 
+ 		/*
+ 		 * Can be overrided by an option, otherwise use entire
+ 		 * work_mem.
+ 		 */
+ 		skyline_option_get_int(node->skyline_of_options, "window", &window_size) ||
+ 			skyline_option_get_int(node->skyline_of_options, "windowsize", &window_size);
+ 
+ 		skyline_option_get_int(node->skyline_of_options, "slots", &window_slots) ||
+ 			skyline_option_get_int(node->skyline_of_options, "windowslots", &window_slots);
+ 
+ 		if (window_slots == 0)
+ 		{
+ 			/*
+ 			 * If window_slots == -1, then we constrain the tuple window in
+ 			 * terms of memory.
+ 			 */
+ 			elog(ERROR, "tuple window must have at least one slot");
+ 		}
+ 
+ 		state->window = tuplewindow_begin(window_size, window_slots, state->window_policy);
+ 
+ 		state->windowsize = window_size;
+ 		state->windowslots = window_slots;
+ 	}
+ 	else
+ 	{
+ 		state->windowsize = -1;
+ 		state->windowslots = -1;
+ 	}
+ }
+ 
+ /*
+  * ExecInitSkyline
+  *
+  *	FIXME
+  */
+ SkylineState *
+ ExecInitSkyline(Skyline *node, EState *estate, int eflags)
+ {
+ 	SkylineState   *state;
+ 	bool			need_extra_slot = ExecSkylineNeedExtraSlot(node);
+ 
+ 	/* check for unsupported flags */
+ 	Assert(!(eflags & (EXEC_FLAG_BACKWARD | EXEC_FLAG_MARK)));
+ 
+ 	state = makeNode(SkylineState);
+ 	state->ss.ps.plan = (Plan *) node;
+ 	state->ss.ps.state = estate;
+ 
+ 	state->status = SS_INIT;
+ 	state->source = SS_OUTER;
+ 	state->skyline_method = node->skyline_method;
+ 	state->pass = 1;
+ 
+ 	state->cmps_tuples = 0;
+ 	state->cmps_fields = 0;
+ 	state->pass_info = makeStringInfo();
+ 	state->flags = SL_FLAGS_NONE;
+ 	state->window_policy = TUP_WIN_POLICY_APPEND;
+ 
+ 	skyline_option_get_window_policy(node->skyline_of_options, "windowpolicy", &state->window_policy);
+ 
+ 	/*
+ 	 * If we do not have stats for at least one column, fall back from
+ 	 * window policy "ranked" back to "append".
+ 	 */
+ 	if (state->window_policy == TUP_WIN_POLICY_ENTROPY && !(node->flags & SKYLINE_FLAGS_HAVE_STATS))
+ 	{
+ 		state->window_policy = TUP_WIN_POLICY_APPEND;
+ 		elog(INFO, "no stats for skyline expressions available, falling back to window policy \"append\"");
+ 	}
+ 
+ 	if (state->window_policy == TUP_WIN_POLICY_ENTROPY)
+ 		state->flags |= SL_FLAGS_RANKED | SL_FLAGS_ENTROPY;
+ 	else if (state->window_policy == TUP_WIN_POLICY_RANDOM)
+ 		state->flags |= SL_FLAGS_RANKED | SL_FLAGS_RANDOM;
+ 
+ 	ExecSkylineInitTupleWindow(state, node);
+ 
+ 	/*
+ 	 * Miscellaneous initialization
+ 	 *
+ 	 * Skyline nodes don't initialize their ExprContexts because they never
+ 	 * call ExecQual or ExecProject.
+ 	 *
+ 	 * FIXME: We could project the tuples in the tuple window for SFS.
+ 	 *
+ 	 * FIXME: We could project the tuples after the skyline if the
+ 	 * skyline attribues are not part of the result.
+ 	 */
+ 
+ 	/*
+ 	 * create expression context
+ 	 */
+ 	/* ExecAssignExprContext(estate, &slstate->ss.ps); */ /* see above */
+ 
+ 	/*
+ 	 * If ExecSkylineNeedExtraSlot(node) returns true, allocate one slot 
+ 	 * more, see: ExecCountSlotsSkyline
+ 	 */
+ #define SKYLINE_NSLOTS 2
+ 
+ 	/*
+ 	 * tuple table initialization
+ 	 */
+ 	ExecInitScanTupleSlot(estate, &state->ss);
+ 	ExecInitResultTupleSlot(estate, &state->ss.ps);
+ 
+ 	if (need_extra_slot)
+ 	{
+ 		/* for extra slot */
+ 		state->extraSlot = ExecInitExtraTupleSlot(estate);
+ 	}
+ 
+ 	/*
+ 	 * initialize child expressions
+ 	 */
+ 	state->ss.ps.targetlist = (List *)
+ 		ExecInitExpr((Expr *) node->plan.targetlist,
+ 					 (PlanState *) state);
+ 	state->ss.ps.qual = (List *)
+ 		ExecInitExpr((Expr *) node->plan.qual,
+ 					 (PlanState *) state);
+ 
+ 	/*
+ 	 * initialize child nodes
+ 	 */
+ 
+ 	/*
+ 	 * in case of the materialized nested loop, we need the outer plan to
+ 	 * handle mark/rewind which is achived by an extra materialize node
+ 	 */
+ 	if (node->skyline_method == SM_MATERIALIZEDNESTEDLOOP)
+ 		eflags |= EXEC_FLAG_REWIND | EXEC_FLAG_MARK;
+ 
+ 	outerPlanState(state) = ExecInitNode(outerPlan(node), estate, eflags);
+ 
+ 	/*
+ 	 * Initialize tuple type.  
+ 	 *
+ 	 * FIXME: is the following right
+ 	 * No need to initialize projection info because
+ 	 * this node doesn't do projections.
+ 	 */
+ 	ExecAssignResultTypeFromTL(&state->ss.ps);
+ 	ExecAssignScanTypeFromOuterPlan(&state->ss);
+ 
+ 	if (need_extra_slot)
+ 	{
+ 		/* for extra slot */
+ 		ExecSetSlotDescriptor(state->extraSlot, ExecGetResultType(outerPlanState(state)));
+ 	}
+ 	ExecAssignProjectionInfo(&state->ss.ps, NULL);
+ 
+ 	ExecSkylineCacheCompareFunctionInfo(state, node);
+ 	ExecSkylineCacheCoerceFunctionInfo(state, node);
+ 
+ 	return state;
+ }
+ 
+ /*
+  * ExecCountSlotsSkyline
+  *
+  *	FIXME
+  */
+ int
+ ExecCountSlotsSkyline(Skyline *node)
+ {
+ 	return ExecCountSlotsNode(outerPlan(node)) + SKYLINE_NSLOTS + (ExecSkylineNeedExtraSlot(node) ? 1 : 0);
+ }
+ 
+ /*
+  * ExecSkyline_1DimDistinct
+  *
+  *	FIXME
+  */
+ static TupleTableSlot *
+ ExecSkyline_1DimDistinct(SkylineState *state, Skyline *node)
+ {
+ 	switch (state->status)
+ 	{
+ 		case SS_INIT:
+ 			{
+ 				int			compareFlags = state->compareFlags[0];
+ 				FmgrInfo	compareOpFn = state->compareOpFn[0];
+ 				Datum		datum1;
+ 				Datum		datum2;
+ 				bool		isnull1;
+ 				bool		isnull2;
+ 				int			attnum = node->skylineColIdx[0];
+ 				TupleTableSlot *resultSlot = state->ss.ps.ps_ResultTupleSlot;
+ 
+ 				for (;;)
+ 				{
+ 					/* CHECK_FOR_INTERRUPTS(); is done in ExecProcNode */
+ 					TupleTableSlot *slot = ExecProcNode(outerPlanState(state));
+ 
+ 					if (TupIsNull(slot))
+ 						break;
+ 
+ 					if (TupIsNull(resultSlot))
+ 					{
+ 						ExecCopySlot(resultSlot, slot);
+ 						datum1 = slot_getattr(resultSlot, attnum, &isnull1);
+ 					}
+ 					else
+ 					{
+ 						datum2 = slot_getattr(slot, attnum, &isnull2);
+ 
+ 						if (inlineApplyCompareFunction(&compareOpFn, compareFlags, datum1, isnull1, datum2, isnull2) > 0)
+ 						{
+ 							/*
+ 							 * Using the result slot avoids copying of varlen
+ 							 * attrs.
+ 							 */
+ 							ExecCopySlot(resultSlot, slot);
+ 							datum1 = slot_getattr(resultSlot, attnum, &isnull1);
+ 						}
+ 					}
+ 				}
+ 
+ 				state->status = SS_DONE;
+ 				return resultSlot;
+ 			}
+ 
+ 		case SS_DONE:
+ 			return NULL;
+ 
+ 		default:
+ 			/* Invalid State */
+ 			AssertState(0);
+ 			return NULL;
+ 	}
+ }
+ 
+ /*
+  * ExecSkyline_1Dim
+  *
+  *	FIXME
+  */
+ static TupleTableSlot *
+ ExecSkyline_1Dim(SkylineState *state, Skyline *node)
+ {
+ 	for (;;)
+ 	{
+ 		switch (state->status)
+ 		{
+ 			case SS_INIT:
+ 				{
+ 					int			compareFlags = state->compareFlags[0];
+ 					FmgrInfo	compareOpFn = state->compareOpFn[0];
+ 					Datum		datum1;
+ 					Datum		datum2;
+ 					bool		isnull1;
+ 					bool		isnull2;
+ 					bool		first = true;
+ 					int			attnum = node->skylineColIdx[0];
+ 					TupleTableSlot *resultSlot = state->ss.ps.ps_ResultTupleSlot;
+ 					int16		typlen;
+ 					bool		typbyval;
+ 
+ 					get_typlenbyval(resultSlot->tts_tupleDescriptor->attrs[node->skylineColIdx[0] - 1]->atttypid, &typlen, &typbyval);
+ 
+ 					state->tuplestorestate = tuplestore_begin_heap(false, false, work_mem);
+ 					tuplestore_set_eflags(state->tuplestorestate, EXEC_FLAG_MARK);
+ 					for (;;)
+ 					{
+ 						/* CHECK_FOR_INTERRUPTS(); is done in ExecProcNode */
+ 						TupleTableSlot *slot = ExecProcNode(outerPlanState(state));
+ 
+ 						if (TupIsNull(slot))
+ 							break;
+ 
+ 						if (first)
+ 						{
+ 							datum1 = datumCopy(slot_getattr(slot, attnum, &isnull1), typbyval, typlen);
+ 							tuplestore_puttupleslot(state->tuplestorestate, slot);
+ 
+ 							first = false;
+ 						}
+ 						else
+ 						{
+ 							int			cmp;
+ 
+ 							datum2 = slot_getattr(slot, attnum, &isnull2);
+ 
+ 							cmp = inlineApplyCompareFunction(&compareOpFn, compareFlags, datum1, isnull1, datum2, isnull2);
+ 
+ 							if (cmp == 0)
+ 							{
+ 								tuplestore_puttupleslot(state->tuplestorestate, slot);
+ 							}
+ 							else if (cmp > 0)
+ 							{
+ 								if (!typbyval && !isnull1 && DatumGetPointer(datum1) != NULL)
+ 									pfree(DatumGetPointer(datum1));
+ 								datum1 = datumCopy(datum2, typbyval, typlen);
+ 								isnull1 = isnull2;
+ 
+ 								tuplestore_catchup(state->tuplestorestate);
+ 								tuplestore_puttupleslot(state->tuplestorestate, slot);
+ 							}
+ 						}
+ 					}
+ 
+ 					if (!typbyval && !isnull1 && DatumGetPointer(datum1) != NULL)
+ 						pfree(DatumGetPointer(datum1));
+ 
+ 					state->status = SS_PIPEOUT;
+ 				}
+ 
+ 				/* fall through */
+ 
+ 			case SS_PIPEOUT:
+ 				Assert(state->tuplestorestate != NULL);
+ 
+ 				if (tuplestore_gettupleslot(state->tuplestorestate, true, state->ss.ps.ps_ResultTupleSlot))
+ 					return state->ss.ps.ps_ResultTupleSlot;
+ 				else
+ 				{
+ 					tuplestore_end(state->tuplestorestate);
+ 					state->tuplestorestate = NULL;
+ 
+ 					state->status = SS_DONE;
+ 					return NULL;
+ 				}
+ 
+ 			case SS_DONE:
+ 				return NULL;
+ 
+ 			default:
+ 				/* Invalid State */
+ 				AssertState(0);
+ 				return NULL;
+ 		}
+ 	}
+ }
+ 
+ /*
+  * ExecSkyline_2DimPreSort
+  *
+  *	FIXME
+  */
+ static TupleTableSlot *
+ ExecSkyline_2DimPreSort(SkylineState *state, Skyline *node)
+ {
+ 	TupleTableSlot *resultSlot = state->ss.ps.ps_ResultTupleSlot;
+ 	TupleTableSlot *slot;
+ 
+ 	switch (state->status)
+ 	{
+ 		case SS_INIT:
+ 			slot = ExecProcNode(outerPlanState(state));
+ 			if (!TupIsNull(slot))
+ 			{
+ 				ExecCopySlot(resultSlot, slot);
+ 				state->status = SS_PROCESS;
+ 			}
+ 			else
+ 			{
+ 				state->status = SS_DONE;
+ 			}
+ 			return slot;
+ 
+ 		case SS_PROCESS:
+ 			AssertState(!TupIsNull(resultSlot));
+ 			for (;;)
+ 			{
+ 				int			cmp;
+ 
+ 				/* CHECK_FOR_INTERRUPTS(); is done in ExecProcNode */
+ 				slot = ExecProcNode(outerPlanState(state));
+ 				if (TupIsNull(slot))
+ 				{
+ 					state->status = SS_DONE;
+ 					return NULL;
+ 				}
+ 
+ 				cmp = ExecSkylineIsDominating(state, slot, resultSlot);
+ 
+ 				if (cmp == SKYLINE_CMP_INCOMPARABLE || (cmp == SKYLINE_CMP_ALL_EQ && !node->skyline_distinct))
+ 				{
+ 					ExecCopySlot(resultSlot, slot);
+ 					return resultSlot;
+ 				}
+ 			}
+ 
+ 		case SS_DONE:
+ 			return NULL;
+ 
+ 		default:
+ 			/* Invalid State */
+ 			AssertState(0);
+  			return NULL;
+ 	}
+ }
+ 
+ /*
+  * ExecSkyline_MaterializedNestedLoop
+  *
+  *	FIXME
+  */
+ static TupleTableSlot *
+ ExecSkyline_MaterializedNestedLoop(SkylineState *state, Skyline *node)
+ {
+ 	/* nested loop using materialize as outer plan */
+ 	TupleTableSlot *resultSlot = state->ss.ps.ps_ResultTupleSlot;
+ 
+ 	switch (state->status)
+ 	{
+ 		case SS_INIT:
+ 			ExecMarkPos(outerPlanState(state));
+ 			state->sl_pos = 0;
+ 			state->status = SS_PROCESS;
+ 			
+ 			/* fall trough */
+ 
+ 		case SS_PROCESS:
+ 			for (;;)
+ 			{
+ 				TupleTableSlot *slot;
+ 				int64		sl_innerpos = 0;
+ 
+ 				ExecRestrPos(outerPlanState(state));
+ 				slot = ExecProcNode(outerPlanState(state));
+ 				state->sl_pos++;
+ 				ExecMarkPos(outerPlanState(state));
+ 
+ 				if (TupIsNull(slot))
+ 				{
+ 					state->status = SS_DONE;
+ 					return NULL;
+ 				}
+ 
+ 				ExecCopySlot(resultSlot, slot);
+ 
+ 				ExecReScan(outerPlanState(state), NULL);
+ 
+ 				for (;;)
+ 				{
+ 					int			cmp;
+ 
+ 					TupleTableSlot *inner_slot = ExecProcNode(outerPlanState(state));
+ 
+ 					sl_innerpos++;
+ 
+ 					if (TupIsNull(inner_slot))
+ 					{
+ 						/* the tuple in the resultSlot is not dominated, return it */
+ 						return resultSlot;
+ 					}
+ 
+ 					/* is inner_slot dominating resultSlot? */
+ 					cmp = ExecSkylineIsDominating(state, inner_slot, resultSlot);
+ 
+ 					if (node->skyline_distinct)
+ 					{
+ 						if (cmp == SKYLINE_CMP_ALL_EQ)
+ 						{
+ 							/*
+ 							 * the inner tuple is before the result tuple, so don't
+ 							 * output the result tuple
+ 							 */
+ 							if (sl_innerpos < state->sl_pos)
+ 								break;
+ 						}
+ 					}
+ 
+ 					if (cmp == SKYLINE_CMP_FIRST_DOMINATES)
+ 						break;
+ 				}
+ 			}
+ 
+ 			break;	/* never reached */
+ 
+ 		case SS_DONE:
+ 			return NULL;
+ 
+ 		default:
+ 			/* Invalid State */
+ 			AssertState(0);
+ 			return NULL;
+ 	}
+ }
+ 
+ /*
+  * ExecSkyline_BlockNestedLoop
+  *
+  *	FIXME
+  */
+ static TupleTableSlot *
+ ExecSkyline_BlockNestedLoop(SkylineState *state, Skyline *node)
+ {
+ 	for (;;)
+ 	{
+ 		switch (state->status)
+ 		{
+ 			case SS_INIT:
+ 				{
+ 					state->source = SS_OUTER;
+ 					state->tempIn = NULL;
+ 
+ 					/*
+ 					 * tempOut should go directly to a temporary file,
+ 					 * therefore we set work_mem = 0.
+ 					 */
+ 					state->tempOut = tuplestore_begin_heap(false, false, 0);
+ 
+ 					state->timestampIn = 0;
+ 					state->timestampOut = 0;
+ 
+ 					state->status = SS_PROCESS;
+ 				}
+ 				break;
+ 
+ 			case SS_PROCESS:
+ 				{
+ 					TupleWindowState *window = state->window;
+ 
+ 					TupleTableSlot *inner_slot = state->ss.ps.ps_ResultTupleSlot;
+ 					TupleTableSlot *slot;
+ 
+ 					Assert(state->source == SS_OUTER || state->source == SS_TEMP);
+ 					if (state->source == SS_OUTER)
+ 					{
+ 						slot = ExecProcNode(outerPlanState(state));
+ 					}
+ 					else
+ 					{
+ 						/*
+ 						 * We need to call CHECK_FOR_INTERRUPTS() here
+ 						 * since if we are processing only from temp files,
+ 						 * ExecProcNode is not called.
+ 						 */
+ 						CHECK_FOR_INTERRUPTS();
+ 
+ 						slot = state->extraSlot;
+ 						tuplestore_gettupleslot(state->tempIn, true, slot);
+ 					}
+ 
+ 					if (TupIsNull(slot))
+ 					{
+ 						if (state->source == SS_OUTER)
+ 							appendStringInfo(state->pass_info, "%lld", state->timestampIn);
+ 
+ 						/*
+ 						 * If we have read all tuples for the outer node
+ 						 * switch to temp (FIXME: comment is wrong)
+ 						 */
+ 						if (state->source == SS_TEMP)
+ 						{
+ 							tuplestore_end(state->tempIn);
+ 							state->tempIn = NULL;
+ 						}
+ 
+ 						if (state->timestampOut == 0)
+ 						{
+ 							/*
+ 							 * We haven't written any tuples to the temp, so
+ 							 * we are done.
+ 							 */
+ 							tuplestore_end(state->tempOut);
+ 							state->tempOut = NULL;
+ 
+ 							tuplewindow_rewind(window);
+ 							state->status = SS_FINALPIPEOUT;
+ 						}
+ 						else
+ 						{
+ 							state->pass++;
+ 							appendStringInfo(state->pass_info, ", %lld", state->timestampOut);
+ 							elog(DEBUG1, "start pass %lld with %lld tuples in temp", state->pass, state->timestampOut);
+ 
+ 							state->source = SS_TEMP;
+ 							state->tempIn = state->tempOut;
+ 
+ 							/*
+ 							 * tempOut should go directly to a temporary file,
+ 							 * therefore we set work_mem = 0.
+ 							 */
+ 							state->tempOut = tuplestore_begin_heap(false, false, 0);
+ 
+ 							state->timestampIn = 0;
+ 							state->timestampOut = 0;
+ 
+ 							tuplewindow_rewind(window);
+ 							state->status = SS_PIPEOUT;
+ 						}
+ 						break;
+ 					}
+ 
+ 					state->timestampIn++;
+ 
+ 					tuplewindow_rewind(window);
+ 					if (state->flags & SL_FLAGS_RANKED)
+ 					{
+ 						if (state->flags & SL_FLAGS_ENTROPY)
+ 							tuplewindow_setinsertrank(window, ExecSkylineRank(state, slot));
+ 						else if (state->flags & SL_FLAGS_RANDOM)
+ 							tuplewindow_setinsertrank(window, ExecSkylineRandom());
+ 						else
+ 							Assert(0);
+ 					}
+ 					for (;;)
+ 					{
+ 						int			cmp;
+ 
+ 						if (tuplewindow_ateof(window))
+ 						{
+ 							/*
+ 							 * The tuple in slot is not dominated, by one in
+ 							 * the window put it in the window or write 
+ 							 * it to temp.
+ 							 */
+ 							if (tuplewindow_has_freespace(window))
+ 							{
+ 								tuplewindow_puttupleslot(window, slot, state->timestampOut, false);
+ 							}
+ 							else
+ 							{
+ 								tuplestore_puttupleslot(state->tempOut, slot);
+ 								state->timestampOut++;
+ 							}
+ 							break;
+ 						}
+ 
+ 						tuplewindow_gettupleslot(window, inner_slot, false);
+ 
+ 						cmp = ExecSkylineIsDominating(state, inner_slot, slot);
+ 
+ 						/*
+ 						 * The tuple in slot is dominated by a inner_slot in
+ 						 * the window, so fetch the next.
+ 						 */
+ 						if (cmp == SKYLINE_CMP_FIRST_DOMINATES || (cmp == SKYLINE_CMP_ALL_EQ && node->skyline_distinct))
+ 							break;
+ 
+ 						if (cmp == SYKLINE_CMP_SECOND_DOMINATES)
+ 						{
+ 							/*
+ 							 * In case were we remove a tuple from the window,
+ 						     * the window cursor (current) is move the the
+ 							 * next by tuplewindow_removecurrent.
+ 							 */
+ 							tuplewindow_removecurrent(window);
+ 						}
+ 						else
+ 						{
+ 							tuplewindow_movenext(window);
+ 						}
+ 					}
+ 
+ 					tuplewindow_rewind(window);
+ 					state->status = SS_PIPEOUT;
+ 				}
+ 
+ 				break;
+ 
+ 			case SS_PIPEOUT:
+ 
+ 				/*
+ 				 * Before switching to this state call
+ 				 * tuplewindow_rewind(node->window);
+ 				 */
+ 				for (;;)
+ 				{
+ 					if (tuplewindow_ateof(state->window))
+ 					{
+ 						state->status = SS_PROCESS;
+ 						break;
+ 					}
+ 					else
+ 					{
+ 						if (tuplewindow_timestampcurrent(state->window) == state->timestampIn)
+ 						{
+ 							TupleTableSlot *resultSlot = state->ss.ps.ps_ResultTupleSlot;
+ 
+ 							tuplewindow_gettupleslot(state->window, resultSlot, true);
+ 							return resultSlot;
+ 						}
+ 						else
+ 						{
+ 							tuplewindow_movenext(state->window);
+ 						}
+ 
+ 					}
+ 				}
+ 				break;
+ 
+ 			case SS_FINALPIPEOUT:
+ 				if (tuplewindow_ateof(state->window))
+ 				{
+ 					tuplewindow_end(state->window);
+ 					state->status = SS_DONE;
+ 					return NULL;
+ 				}
+ 				else
+ 				{
+ 					TupleTableSlot *resultSlot = state->ss.ps.ps_ResultTupleSlot;
+ 
+ 					tuplewindow_gettupleslot(state->window, resultSlot, true);
+ 					return resultSlot;
+ 				}
+ 
+ 			case SS_DONE:
+ 				return NULL;
+ 
+ 			default:
+ 				/* Invalid State */
+ 				AssertState(0);
+ 				return NULL;
+ 		}
+ 	}
+ }
+ 
+ /*
+  * ExecSkyline_SortFilterSkyline
+  *
+  *	FIXME
+  */
+ static TupleTableSlot *
+ ExecSkyline_SortFilterSkyline(SkylineState *state, Skyline *node)
+ {
+ 	for (;;)
+ 	{
+ 		switch (state->status)
+ 		{
+ 			case SS_INIT:
+ 				{
+ 					state->source = SS_OUTER;
+ 					state->tempIn = NULL;
+ 
+ 					/*
+ 					 * tempOut should go directly to a temporary file,
+ 					 * therefore we set work_mem = 0.
+ 					 */
+ 					state->tempOut = tuplestore_begin_heap(false, false, 0);
+ 
+ 					state->timestampOut = 0;
+ 
+ 					state->status = SS_PROCESS;
+ 				}
+ 				break;
+ 
+ 			case SS_PROCESS:
+ 				{
+ 					TupleWindowState *window = state->window;
+ 
+ 					TupleTableSlot *inner_slot = state->ss.ps.ps_ResultTupleSlot;
+ 					TupleTableSlot *slot;
+ 
+ 					Assert(state->source == SS_OUTER || state->source == SS_TEMP);
+ 					if (state->source == SS_OUTER)
+ 					{
+ 						slot = ExecProcNode(outerPlanState(state));
+ 					}
+ 					else
+ 					{
+ 						/*
+ 						 * We need to call CHECK_FOR_INTERRUPTS() here
+ 						 * since if we are processing only from temp files,
+ 						 * ExecProcNode is not called
+ 						 */
+ 						CHECK_FOR_INTERRUPTS();
+ 
+ 						slot = state->extraSlot;
+ 						tuplestore_gettupleslot(state->tempIn, true, slot);
+ 					}
+ 
+ 					if (TupIsNull(slot))
+ 					{
+ 						if (state->source == SS_OUTER)
+ 							appendStringInfo(state->pass_info, "%lld", state->timestampIn);
+ 
+ 						/*
+ 						 * If we have read all tuples for the outer node
+ 						 * switch to temp (FIXME: comment is wrong)
+ 						 */
+ 						if (state->source == SS_TEMP)
+ 						{
+ 							tuplestore_end(state->tempIn);
+ 							state->tempIn = NULL;
+ 						}
+ 
+ 						if (state->timestampOut == 0)
+ 						{
+ 							/*
+ 							 * We haven't written any tuples to the temp, so
+ 							 * we are done.
+ 							 */
+ 							tuplestore_end(state->tempOut);
+ 							state->tempOut = NULL;
+ 
+ 							state->status = SS_DONE;
+ 							return NULL;
+ 						}
+ 						else
+ 						{
+ 							state->pass++;
+ 							appendStringInfo(state->pass_info, ", %lld", state->timestampOut);
+ 							elog(DEBUG1, "start pass %lld with %lld tuples in temp", state->pass, state->timestampOut);
+ 
+ 							state->source = SS_TEMP;
+ 							state->tempIn = state->tempOut;
+ 
+ 							/*
+ 							 * By using work_mem = 0 we force the tuples in
+ 							 * the tuplestore to go directly to the temp
+ 							 * file
+ 							 */
+ 							state->tempOut = tuplestore_begin_heap(false, false, 0 /* work_mem */);
+ 
+ 							state->timestampOut = 0;
+ 
+ 							/*
+ 							 * We just clean the window here, the tuples have
+ 							 * allready been piped out.
+ 							 */
+ 							tuplewindow_clean(window);
+ 						}
+ 						break;
+ 					}
+ 
+ 					state->timestampIn++;
+ 
+ 					tuplewindow_rewind(window);
+ 					if (state->flags & SL_FLAGS_RANKED)
+ 					{
+ 						if (state->flags & SL_FLAGS_ENTROPY)
+ 							tuplewindow_setinsertrank(window, ExecSkylineRank(state, slot));
+ 						else if (state->flags & SL_FLAGS_RANDOM)
+ 							tuplewindow_setinsertrank(window, ExecSkylineRandom());
+ 						else
+ 							Assert(0);
+ 					}
+ 					for (;;)
+ 					{
+ 						int			cmp;
+ 
+ 						if (tuplewindow_ateof(window))
+ 						{
+ 							/*
+ 							 * The tuple in the slot is not dominated by one
+ 							 * in the window, so put into the window and pipe 
+ 							 * it out or write it to temp, if the window does
+ 							 * not have enough free space.
+ 							 */ 
+ 							if (tuplewindow_has_freespace(window))
+ 							{
+ 								tuplewindow_puttupleslot(window, slot, 0, false);
+ 
+ 								/*
+ 								 * We can pipe out the tuple here.
+ 								 */
+ 								return slot;
+ 							}
+ 							else
+ 							{
+ 								tuplestore_puttupleslot(state->tempOut, slot);
+ 								state->timestampOut++;
+ 							}
+ 							break;
+ 						}
+ 
+ 						tuplewindow_gettupleslot(window, inner_slot, false);
+ 
+ 						cmp = ExecSkylineIsDominating(state, inner_slot, slot);
+ 
+ 						/*
+ 						 * The tuple in slot is dominated by a inner_slot in
+ 						 * the window, so fetch the next.
+ 						 */
+ 						if (cmp == SKYLINE_CMP_FIRST_DOMINATES || (cmp == SKYLINE_CMP_ALL_EQ && node->skyline_distinct))
+ 							break;
+ 
+ 						Assert(cmp != SYKLINE_CMP_SECOND_DOMINATES);
+ 						tuplewindow_movenext(window);
+ 					}
+ 				}
+ 
+ 				break;
+ 
+ 			case SS_DONE:
+ 				return NULL;
+ 
+ 			default:
+ 				/* Invalid State */
+ 				AssertState(0);
+ 				return NULL;
+ 		}						/* switch */
+ 	}							/* for */
+ }
+ 
+ /*
+  * ExecSkyline
+  *
+  *	FIXME
+  */
+ TupleTableSlot *
+ ExecSkyline(SkylineState *state)
+ {
+ 	Skyline    *node = (Skyline *) state->ss.ps.plan;
+ 
+ 	switch (state->skyline_method)
+ 	{
+ 		case SM_1DIM:
+ 			return ExecSkyline_1Dim(state, node);
+ 		case SM_1DIM_DISTINCT:
+ 			return ExecSkyline_1DimDistinct(state, node);
+ 		case SM_2DIM_PRESORT:
+ 			return ExecSkyline_2DimPreSort(state, node);
+ 		case SM_MATERIALIZEDNESTEDLOOP:
+ 			return ExecSkyline_MaterializedNestedLoop(state, node);
+ 		case SM_BLOCKNESTEDLOOP:
+ 			return ExecSkyline_BlockNestedLoop(state, node);
+ 		case SM_SFS:
+ 			return ExecSkyline_SortFilterSkyline(state, node);
+ 		default:
+ 			/* Invalid Skyline Method */
+ 			AssertState(0);
+ 			return NULL;
+ 	}
+ }
+ 
+ /*
+  * ExecEndSkyline
+  *
+  *	FIXME
+  */
+ void
+ ExecEndSkyline(SkylineState *state)
+ {
+ 	/*
+ 	 * clean out the tuple table
+ 	 */
+ 	ExecClearTuple(state->ss.ss_ScanTupleSlot);
+ 	ExecClearTuple(state->ss.ps.ps_ResultTupleSlot);
+ 	if (ExecSkylineNeedExtraSlot((Skyline *)state->ss.ps.plan))
+ 	{
+ 		ExecClearTuple(state->extraSlot);
+ 	}
+ 
+ 	/*
+ 	 * shut down the subplan
+ 	 */
+ 	ExecEndNode(outerPlanState(state));
+ }
+ 
+ /*
+  * ExecReScanSkyline
+  *
+  *	FIXME
+  */
+ void
+ ExecReScanSkyline(SkylineState *state, ExprContext *exprCtxt)
+ {
+ 	/* FIXME: code coverage = 0 !!! */
+ 
+ 	state->status = SS_INIT;
+ 
+ 	/* must clear first tuple */
+ 	ExecClearTuple(state->ss.ss_ScanTupleSlot);
+ 
+ 	if (((PlanState *) state)->lefttree &&
+ 		((PlanState *) state)->lefttree->chgParam == NULL)
+ 		ExecReScan(((PlanState *) state)->lefttree, exprCtxt);
+ 
+ 	state->status = SS_OUTER;
+ 	state->pass = 1;
+ 
+ 	state->cmps_tuples = 0;
+ 	state->cmps_fields = 0;
+ 	resetStringInfo(state->pass_info);
+ 
+ 	/* reinit tuple window */
+ 	ExecSkylineInitTupleWindow(state, (Skyline *) state->ss.ps.plan);
+ 
+ 
+ 	/* close temp files */
+ 	if (state->tempIn)
+ 	{
+ 		tuplestore_end(state->tempIn);
+ 		state->tempIn = NULL;
+ 	}
+ 
+ 	if (state->tempOut)
+ 	{
+ 		tuplestore_end(state->tempOut);
+ 		state->tempOut = NULL;
+ 	}
+ 
+ 	/* FIXME: there is maybe more that need to be done here */
+ }
diff -cr --new-file -b --tabsize 4 -x CVS -x .svn -x tools pgsql-REL8_3_STABLE/src/backend/nodes/copyfuncs.c pgsql/src/backend/nodes/copyfuncs.c
*** pgsql-REL8_3_STABLE/src/backend/nodes/copyfuncs.c	Thu Feb  7 21:19:47 2008
--- pgsql/src/backend/nodes/copyfuncs.c	Mon Mar  3 15:42:26 2008
***************
*** 556,561 ****
--- 556,590 ----
  	return newnode;
  }
  
+ /*
+  * _copySkyline
+  */
+ static Skyline *
+ _copySkyline(Skyline *from)
+ {
+ 	Skyline    *newnode = makeNode(Skyline);
+ 
+ 	/*
+ 	 * copy node superclass fields
+ 	 */
+ 	CopyPlanFields((Plan *) from, (Plan *) newnode);
+ 
+ 	COPY_SCALAR_FIELD(skyline_distinct);
+ 	COPY_SCALAR_FIELD(numCols);
+ 	COPY_SCALAR_FIELD(flags);
+ 	COPY_POINTER_FIELD(skylineColIdx, from->numCols * sizeof(AttrNumber));
+ 	COPY_POINTER_FIELD(skylineOfOperators, from->numCols * sizeof(Oid));
+ 	COPY_POINTER_FIELD(nullsFirst, from->numCols * sizeof(bool));
+ 	COPY_POINTER_FIELD(skylineOfDir, from->numCols * sizeof(int));
+ 	COPY_POINTER_FIELD(colFlags, from->numCols * sizeof(int));
+ 	COPY_POINTER_FIELD(colMin, from->numCols * sizeof(float8));
+ 	COPY_POINTER_FIELD(colScale, from->numCols * sizeof(float8));
+ 	COPY_POINTER_FIELD(colCoerceFunc, from->numCols * sizeof(Oid));
+ 	COPY_NODE_FIELD(skyline_of_options);
+ 	COPY_SCALAR_FIELD(skyline_method);
+ 
+ 	return newnode;
+ }
  
  /*
   * _copyGroup
***************
*** 1570,1575 ****
--- 1599,1641 ----
  	return newnode;
  }
  
+ static SkylineClause *
+ _copySkylineClause(SkylineClause *from)
+ {
+ 	SkylineClause *newnode = makeNode(SkylineClause);
+ 
+ 	COPY_SCALAR_FIELD(skyline_distinct);
+ 	COPY_NODE_FIELD(skyline_of_list);
+ 	COPY_NODE_FIELD(skyline_of_options);
+ 
+ 	return newnode;
+ }
+ 
+ static SkylineOf *
+ _copySkylineOf(SkylineOf *from)
+ {
+ 	SkylineOf  *newnode = makeNode(SkylineOf);
+ 
+ 	COPY_SCALAR_FIELD(tleSortGroupRef);
+ 	COPY_SCALAR_FIELD(restype);
+ 	COPY_SCALAR_FIELD(skylineop);
+ 	COPY_SCALAR_FIELD(nulls_first);
+ 	COPY_SCALAR_FIELD(skylineof_dir);
+ 
+ 	return newnode;
+ }
+ 
+ static SkylineOption *
+ _copySkylineOption(SkylineOption *from)
+ {
+ 	SkylineOption *newnode = makeNode(SkylineOption);
+ 
+ 	COPY_STRING_FIELD(name);
+ 	COPY_NODE_FIELD(value);
+ 
+ 	return newnode;
+ }
+ 
  static RowMarkClause *
  _copyRowMarkClause(RowMarkClause *from)
  {
***************
*** 1728,1733 ****
--- 1794,1824 ----
  	return newnode;
  }
  
+ static SkylineOfClause *
+ _copySkylineOfClause(SkylineOfClause *from)
+ {
+ 	SkylineOfClause *newnode = makeNode(SkylineOfClause);
+ 
+ 	COPY_SCALAR_FIELD(skyline_distinct);
+ 	COPY_NODE_FIELD(skyline_of_list);
+ 	COPY_NODE_FIELD(skyline_of_options);
+ 
+ 	return newnode;
+ }
+ 
+ static SkylineOfExpr *
+ _copySkylineOfExpr(SkylineOfExpr *from)
+ {
+ 	SkylineOfExpr *newnode = makeNode(SkylineOfExpr);
+ 
+ 	COPY_SCALAR_FIELD(skylineof_dir);
+ 	COPY_SCALAR_FIELD(skylineof_nulls);
+ 	COPY_NODE_FIELD(useOp);
+ 	COPY_NODE_FIELD(node);
+ 
+ 	return newnode;
+ }
+ 
  static RangeSubselect *
  _copyRangeSubselect(RangeSubselect *from)
  {
***************
*** 1865,1870 ****
--- 1956,1962 ----
  	COPY_NODE_FIELD(havingQual);
  	COPY_NODE_FIELD(distinctClause);
  	COPY_NODE_FIELD(sortClause);
+ 	COPY_NODE_FIELD(skylineClause);
  	COPY_NODE_FIELD(limitOffset);
  	COPY_NODE_FIELD(limitCount);
  	COPY_NODE_FIELD(rowMarks);
***************
*** 1925,1930 ****
--- 2017,2023 ----
  	COPY_NODE_FIELD(whereClause);
  	COPY_NODE_FIELD(groupClause);
  	COPY_NODE_FIELD(havingClause);
+ 	COPY_NODE_FIELD(skylineOfClause);
  	COPY_NODE_FIELD(valuesLists);
  	COPY_NODE_FIELD(sortClause);
  	COPY_NODE_FIELD(limitOffset);
***************
*** 3083,3088 ****
--- 3176,3184 ----
  		case T_Group:
  			retval = _copyGroup(from);
  			break;
+ 		case T_Skyline:
+ 			retval = _copySkyline(from);
+ 			break;
  		case T_Agg:
  			retval = _copyAgg(from);
  			break;
***************
*** 3552,3557 ****
--- 3648,3662 ----
  		case T_SortBy:
  			retval = _copySortBy(from);
  			break;
+ 		case T_SkylineOfClause:
+ 			retval = _copySkylineOfClause(from);
+ 			break;
+ 		case T_SkylineOfExpr:
+ 			retval = _copySkylineOfExpr(from);
+ 			break;
+ 		case T_SkylineOption:
+ 			retval = _copySkylineOption(from);
+ 			break;
  		case T_RangeSubselect:
  			retval = _copyRangeSubselect(from);
  			break;
***************
*** 3585,3590 ****
--- 3690,3701 ----
  		case T_GroupClause:
  			retval = _copyGroupClause(from);
  			break;
+ 		case T_SkylineClause:
+ 			retval = _copySkylineClause(from);
+ 			break;
+ 		case T_SkylineOf:
+ 			retval = _copySkylineOf(from);
+ 			break;
  		case T_RowMarkClause:
  			retval = _copyRowMarkClause(from);
  			break;
diff -cr --new-file -b --tabsize 4 -x CVS -x .svn -x tools pgsql-REL8_3_STABLE/src/backend/nodes/equalfuncs.c pgsql/src/backend/nodes/equalfuncs.c
*** pgsql-REL8_3_STABLE/src/backend/nodes/equalfuncs.c	Thu Feb  7 21:19:47 2008
--- pgsql/src/backend/nodes/equalfuncs.c	Tue Nov 11 22:01:22 2008
***************
*** 764,769 ****
--- 764,770 ----
  	COMPARE_NODE_FIELD(havingQual);
  	COMPARE_NODE_FIELD(distinctClause);
  	COMPARE_NODE_FIELD(sortClause);
+ 	COMPARE_NODE_FIELD(skylineClause);
  	COMPARE_NODE_FIELD(limitOffset);
  	COMPARE_NODE_FIELD(limitCount);
  	COMPARE_NODE_FIELD(rowMarks);
***************
*** 816,821 ****
--- 817,823 ----
  	COMPARE_NODE_FIELD(whereClause);
  	COMPARE_NODE_FIELD(groupClause);
  	COMPARE_NODE_FIELD(havingClause);
+ 	COMPARE_NODE_FIELD(skylineOfClause);
  	COMPARE_NODE_FIELD(valuesLists);
  	COMPARE_NODE_FIELD(sortClause);
  	COMPARE_NODE_FIELD(limitOffset);
***************
*** 1777,1782 ****
--- 1779,1814 ----
  }
  
  static bool
+ _equalSkylineOfClause(SkylineOfClause *a, SkylineOfClause *b)
+ {
+ 	COMPARE_SCALAR_FIELD(skyline_distinct);
+ 	COMPARE_NODE_FIELD(skyline_of_list);
+ 	COMPARE_NODE_FIELD(skyline_of_options);
+ 
+ 	return true;
+ }
+ 
+ static bool
+ _equalSkylineOfExpr(SkylineOfExpr *a, SkylineOfExpr *b)
+ {
+ 	COMPARE_SCALAR_FIELD(skylineof_dir);
+ 	COMPARE_SCALAR_FIELD(skylineof_nulls);
+ 	COMPARE_NODE_FIELD(useOp);
+ 	COMPARE_NODE_FIELD(node);
+ 
+ 	return true;
+ }
+ 
+ static bool
+ _equalSkylineOption(SkylineOption *a, SkylineOption *b)
+ {
+ 	COMPARE_STRING_FIELD(name);
+ 	COMPARE_NODE_FIELD(value);
+ 
+ 	return true;
+ }
+ 
+ static bool
  _equalRangeSubselect(RangeSubselect *a, RangeSubselect *b)
  {
  	COMPARE_NODE_FIELD(subquery);
***************
*** 1888,1893 ****
--- 1920,1947 ----
  }
  
  static bool
+ _equalSkylineOf(SkylineOf *a, SkylineOf *b)
+ {
+ 	COMPARE_SCALAR_FIELD(tleSortGroupRef);
+ 	COMPARE_SCALAR_FIELD(restype);
+ 	COMPARE_SCALAR_FIELD(skylineop);
+ 	COMPARE_SCALAR_FIELD(nulls_first);
+ 	COMPARE_SCALAR_FIELD(skylineof_dir);
+ 
+ 	return true;
+ }
+ 
+ static bool
+ _equalSkylineClause(SkylineClause *a, SkylineClause *b)
+ {
+ 	COMPARE_SCALAR_FIELD(skyline_distinct);
+ 	COMPARE_NODE_FIELD(skyline_of_list);
+ 	COMPARE_NODE_FIELD(skyline_of_options);
+ 
+ 	return true;
+ }
+ 
+ static bool
  _equalRowMarkClause(RowMarkClause *a, RowMarkClause *b)
  {
  	COMPARE_SCALAR_FIELD(rti);
***************
*** 2478,2483 ****
--- 2532,2546 ----
  		case T_SortBy:
  			retval = _equalSortBy(a, b);
  			break;
+ 		case T_SkylineOfClause:
+ 			retval = _equalSkylineOfClause(a, b);
+ 			break;
+ 		case T_SkylineOfExpr:
+ 			retval = _equalSkylineOfExpr(a, b);
+ 			break;
+ 		case T_SkylineOption:
+ 			retval = _equalSkylineOption(a, b);
+ 			break;
  		case T_RangeSubselect:
  			retval = _equalRangeSubselect(a, b);
  			break;
***************
*** 2512,2517 ****
--- 2575,2586 ----
  			/* GroupClause is equivalent to SortClause */
  			retval = _equalSortClause(a, b);
  			break;
+ 		case T_SkylineClause:
+ 			retval = _equalSkylineClause(a, b);
+ 			break;
+ 		case T_SkylineOf:
+ 			retval = _equalSkylineOf(a, b);
+ 			break;
  		case T_RowMarkClause:
  			retval = _equalRowMarkClause(a, b);
  			break;
diff -cr --new-file -b --tabsize 4 -x CVS -x .svn -x tools pgsql-REL8_3_STABLE/src/backend/nodes/outfuncs.c pgsql/src/backend/nodes/outfuncs.c
*** pgsql-REL8_3_STABLE/src/backend/nodes/outfuncs.c	Wed Jan  9 09:46:44 2008
--- pgsql/src/backend/nodes/outfuncs.c	Mon Mar  3 15:42:29 2008
***************
*** 574,579 ****
--- 574,628 ----
  }
  
  static void
+ _outSkyline(StringInfo str, Skyline *node)
+ {
+ 	int			i;
+ 
+ 	WRITE_NODE_TYPE("SKYLINE");
+ 
+ 	_outPlanInfo(str, (Plan *) node);
+ 
+ 	WRITE_BOOL_FIELD(skyline_distinct);
+ 	WRITE_INT_FIELD(numCols);
+ 	WRITE_INT_FIELD(flags);
+ 
+ 	appendStringInfo(str, " :skylineColIdx");
+ 	for (i = 0; i < node->numCols; ++i)
+ 		appendStringInfo(str, " %d", node->skylineColIdx[i]);
+ 
+ 	appendStringInfo(str, " :skylineOfOperators");
+ 	for (i = 0; i < node->numCols; ++i)
+ 		appendStringInfo(str, " %u", node->skylineOfOperators[i]);
+ 
+ 	appendStringInfo(str, " :nullsFirst");
+ 	for (i = 0; i < node->numCols; ++i)
+ 		appendStringInfo(str, " %s", booltostr(node->nullsFirst[i]));
+ 
+ 	appendStringInfo(str, " :skylineOfDir");
+ 	for (i = 0; i < node->numCols; ++i)
+ 		appendStringInfo(str, " %d", node->skylineOfDir[i]);
+ 
+ 	appendStringInfo(str, " :colFlags");
+ 	for (i = 0; i < node->numCols; ++i)
+ 		appendStringInfo(str, " %d", node->colFlags[i]);
+ 
+ 	appendStringInfo(str, " :colMin");
+ 	for (i = 0; i < node->numCols; ++i)
+ 		appendStringInfo(str, " %e", node->colMin[i]);
+ 
+ 	appendStringInfo(str, " :colScale");
+ 	for (i = 0; i < node->numCols; ++i)
+ 		appendStringInfo(str, " %e", node->colScale[i]);
+ 
+ 	appendStringInfo(str, " :colCoerceFunc");
+ 		for (i = 0; i < node->numCols; ++i)
+ 		appendStringInfo(str, " %u", node->colCoerceFunc[i]);
+ 
+ 	WRITE_NODE_FIELD(skyline_of_options);
+ 	WRITE_INT_FIELD(skyline_method);
+ }
+ 
+ static void
  _outUnique(StringInfo str, Unique *node)
  {
  	int			i;
***************
*** 1594,1599 ****
--- 1643,1649 ----
  	WRITE_NODE_FIELD(whereClause);
  	WRITE_NODE_FIELD(groupClause);
  	WRITE_NODE_FIELD(havingClause);
+ 	WRITE_NODE_FIELD(skylineOfClause);
  	WRITE_NODE_FIELD(valuesLists);
  	WRITE_NODE_FIELD(sortClause);
  	WRITE_NODE_FIELD(limitOffset);
***************
*** 1742,1747 ****
--- 1792,1798 ----
  	WRITE_NODE_FIELD(returningList);
  	WRITE_NODE_FIELD(groupClause);
  	WRITE_NODE_FIELD(havingQual);
+ 	WRITE_NODE_FIELD(skylineClause);
  	WRITE_NODE_FIELD(distinctClause);
  	WRITE_NODE_FIELD(sortClause);
  	WRITE_NODE_FIELD(limitOffset);
***************
*** 1771,1776 ****
--- 1822,1858 ----
  }
  
  static void
+ _outSkylineClause(StringInfo str, SkylineClause *node)
+ {
+ 	WRITE_NODE_TYPE("SKYLINECLAUSE");
+ 
+ 	WRITE_BOOL_FIELD(skyline_distinct);
+ 	WRITE_NODE_FIELD(skyline_of_list);
+ 	WRITE_NODE_FIELD(skyline_of_options);
+ }
+ 
+ static void
+ _outSkylineOf(StringInfo str, SkylineOf *node)
+ {
+ 	WRITE_NODE_TYPE("SKYLINEOF");
+ 
+ 	WRITE_UINT_FIELD(tleSortGroupRef);
+ 	WRITE_OID_FIELD(restype);
+ 	WRITE_OID_FIELD(skylineop);
+ 	WRITE_BOOL_FIELD(nulls_first);
+ 	WRITE_INT_FIELD(skylineof_dir);
+ }
+ 
+ static void
+ _outSkylineOption(StringInfo str, SkylineOption *node)
+ {
+ 	WRITE_NODE_TYPE("SKYLINEOPTION");
+ 
+ 	WRITE_STRING_FIELD(name);
+ 	WRITE_NODE_FIELD(value);
+ }
+ 
+ static void
  _outRowMarkClause(StringInfo str, RowMarkClause *node)
  {
  	WRITE_NODE_TYPE("ROWMARKCLAUSE");
***************
*** 2139,2144 ****
--- 2221,2229 ----
  			case T_Sort:
  				_outSort(str, obj);
  				break;
+ 			case T_Skyline:
+ 				_outSkyline(str, obj);
+ 				break;
  			case T_Unique:
  				_outUnique(str, obj);
  				break;
***************
*** 2390,2395 ****
--- 2475,2489 ----
  			case T_GroupClause:
  				_outGroupClause(str, obj);
  				break;
+ 			case T_SkylineClause:
+ 				_outSkylineClause(str, obj);
+ 				break;
+ 			case T_SkylineOf:
+ 				_outSkylineOf(str, obj);
+ 				break;
+ 			case T_SkylineOption:
+ 				_outSkylineOption(str, obj);
+ 				break;
  			case T_RowMarkClause:
  				_outRowMarkClause(str, obj);
  				break;
diff -cr --new-file -b --tabsize 4 -x CVS -x .svn -x tools pgsql-REL8_3_STABLE/src/backend/nodes/readfuncs.c pgsql/src/backend/nodes/readfuncs.c
*** pgsql-REL8_3_STABLE/src/backend/nodes/readfuncs.c	Tue Jan  1 20:45:50 2008
--- pgsql/src/backend/nodes/readfuncs.c	Mon Mar  3 15:42:30 2008
***************
*** 148,153 ****
--- 148,154 ----
  	READ_NODE_FIELD(returningList);
  	READ_NODE_FIELD(groupClause);
  	READ_NODE_FIELD(havingQual);
+ 	READ_NODE_FIELD(skylineClause);
  	READ_NODE_FIELD(distinctClause);
  	READ_NODE_FIELD(sortClause);
  	READ_NODE_FIELD(limitOffset);
***************
*** 217,222 ****
--- 218,269 ----
  }
  
  /*
+  * _readSkylineClause
+  */
+ static SkylineClause *
+ _readSkylineClause(void)
+ {
+ 	READ_LOCALS(SkylineClause);
+ 
+ 	READ_BOOL_FIELD(skyline_distinct);
+ 	READ_NODE_FIELD(skyline_of_list);
+ 	READ_NODE_FIELD(skyline_of_options);
+ 
+ 	READ_DONE();
+ }
+ 
+ /*
+  * _readSkylineOf
+  */
+ static SkylineOf *
+ _readSkylineOf(void)
+ {
+ 	READ_LOCALS(SkylineOf);
+ 
+ 	READ_UINT_FIELD(tleSortGroupRef);
+ 	READ_OID_FIELD(restype);
+ 	READ_OID_FIELD(skylineop);
+ 	READ_BOOL_FIELD(nulls_first);
+ 	READ_INT_FIELD(skylineof_dir);
+ 
+ 	READ_DONE();
+ }
+ 
+ /*
+  * _readSkylineOption
+  */
+ static SkylineOption *
+ _readSkylineOption(void)
+ {
+ 	READ_LOCALS(SkylineOption);
+ 
+ 	READ_STRING_FIELD(name);
+ 	READ_NODE_FIELD(value);
+ 
+ 	READ_DONE();
+ }
+ 
+ /*
   * _readRowMarkClause
   */
  static RowMarkClause *
***************
*** 1034,1039 ****
--- 1081,1092 ----
  		return_value = _readSortClause();
  	else if (MATCH("GROUPCLAUSE", 11))
  		return_value = _readGroupClause();
+ 	else if (MATCH("SKYLINECLAUSE", 13))
+ 		return_value = _readSkylineClause();
+ 	else if (MATCH("SKYLINEOF", 9))
+ 		return_value = _readSkylineOf();
+ 	else if (MATCH("SKYLINEOPTION", 13))
+ 		return_value = _readSkylineOption();
  	else if (MATCH("ROWMARKCLAUSE", 13))
  		return_value = _readRowMarkClause();
  	else if (MATCH("SETOPERATIONSTMT", 16))
diff -cr --new-file -b --tabsize 4 -x CVS -x .svn -x tools pgsql-REL8_3_STABLE/src/backend/optimizer/path/allpaths.c pgsql/src/backend/optimizer/path/allpaths.c
*** pgsql-REL8_3_STABLE/src/backend/optimizer/path/allpaths.c	Tue Apr  1 02:48:44 2008
--- pgsql/src/backend/optimizer/path/allpaths.c	Thu Nov 13 10:26:37 2008
***************
*** 804,809 ****
--- 804,812 ----
   * component queries to see if any of them have different output types;
   * differentTypes[k] is set true if column k has different type in any
   * component.
+  *
+  * 4. FIXME: Analzye what the case for a subquery with SKYLINE OF is.
+  * Is it safe to push down quals?  For the moment we disable it.
   */
  static bool
  subquery_is_pushdown_safe(Query *subquery, Query *topquery,
***************
*** 815,820 ****
--- 818,827 ----
  	if (subquery->limitOffset != NULL || subquery->limitCount != NULL)
  		return false;
  
+ 	/* Check point 4 */
+ 	if (subquery->skylineClause != NULL)
+ 		return false;
+ 
  	/* Are we at top level, or looking at a setop component? */
  	if (subquery == topquery)
  	{
diff -cr --new-file -b --tabsize 4 -x CVS -x .svn -x tools pgsql-REL8_3_STABLE/src/backend/optimizer/path/costsize.c pgsql/src/backend/optimizer/path/costsize.c
*** pgsql-REL8_3_STABLE/src/backend/optimizer/path/costsize.c	Mon Mar 24 22:53:12 2008
--- pgsql/src/backend/optimizer/path/costsize.c	Tue Nov 11 17:53:27 2008
***************
*** 73,78 ****
--- 73,79 ----
  #include "parser/parse_expr.h"
  #include "utils/lsyscache.h"
  #include "utils/selfuncs.h"
+ #include "utils/skyline.h"
  #include "utils/tuplesort.h"
  
  
***************
*** 935,940 ****
--- 936,1095 ----
  }
  
  /*
+  * cost_skyline
+  *
+  * FIXME
+  */
+ void
+ cost_skyline(Path *path, PlannerInfo *root, Cost input_cost,
+ 			 double input_tuples, int width, double output_tuples,
+ 			 int skyline_dim, SkylineMethod skyline_method, int limit_tuples)
+ {
+ 	Cost		startup_cost = input_cost;
+ 	Cost		run_cost = 0;
+ 	double		input_bytes = relation_byte_size(input_tuples, width);
+ 	double		output_bytes;
+ 	long		work_mem_bytes = work_mem * 1024L;
+ 	bool		enough_memory;
+ 
+ 	/*
+ 	 * The number of compare operator call for comparing two tuples. For the
+ 	 * moment we assume have to compare all dims in any case.
+ 	 *
+ 	 * FIXME: see ticket:39 and [165]
+ 	 */
+ 	double		cmps = 1.0 * skyline_dim;
+ 
+ 	/* Do we have useful LIMIT? */
+ 	bool		limit_is_useful = limit_tuples > 0 && 
+ 		limit_tuples < input_tuples	&& 
+ 		limit_tuples < output_tuples && 
+ 		skyline_methode_can_use_limit(skyline_method);
+ 
+ 	output_bytes = relation_byte_size((limit_is_useful ? limit_tuples : output_tuples), width);
+ 
+ 	/* let's assume a sane default if unknown */
+ 	if (skyline_method == SM_UNKNOWN)
+ 		skyline_method = SM_BLOCKNESTEDLOOP;
+ 
+ 	/*
+ 	 * Note that we do not take into account here that the user might has
+ 	 * overwritten window size in terms of memory or slot count
+ 	 *
+ 	 * FIXME: should we take it into account?
+ 	 */
+ 	enough_memory = output_bytes < work_mem_bytes;
+ 
+ 	switch (skyline_method)
+ 	{
+ 		case SM_1DIM:
+ 			/*
+ 			 * We cheat a bit here, we assume that in general there are no
+ 			 * duplicates or at least very little compared to the
+ 			 * input_tuples. Since we only keep the current dominating tuple
+ 			 * in a slot we are not constraint by enough_memory.
+ 			 * LIMIT is not useful here, since we only know after scanning
+ 			 * all input_tuples how many tuples we wrote to the tuplestore
+ 			 * and will finally be piped out.
+ 			 */
+ 			startup_cost += cmps * cpu_operator_cost * input_tuples;
+ 			break;
+ 
+ 		case SM_1DIM_DISTINCT:
+ 			/*
+ 			 * We have to compare all input_tuples to the current
+ 			 * dominating, so extra memory needed.
+ 			 * LIMIT is not useful here, since at most one tuple will be
+ 			 * piped out.
+ 			 */
+ 			startup_cost += cmps * cpu_operator_cost * input_tuples;
+ 			break;
+ 
+ 		case SM_2DIM_PRESORT:
+ 			/*
+ 			 * We just have to compare all input_tuples to the current
+ 			 * dominating, so no extra memory needed.
+ 			 *
+ 			 * If LIMIT is useful we assume the skyline tuples are 
+ 			 * equally distributed over the input_tuples.
+ 			 */
+ 			if (limit_is_useful)
+ 				startup_cost += cmps * cpu_operator_cost * input_tuples * (limit_tuples / output_tuples);
+ 			else
+ 				startup_cost += cmps * cpu_operator_cost * input_tuples;
+ 			break;
+ 
+ 		case SM_MATERIALIZEDNESTEDLOOP:
+ 			/*
+ 			 * If no LIMIT is given we compare every tuples against every
+ 			 * tuples.
+ 			 *
+ 			 * If LIMIT is useful we assume the skyline tuples are 
+ 			 * equally distributed over the input_tuples.
+ 			 */
+ 			if (limit_is_useful)
+ 				startup_cost += cmps * cpu_operator_cost * input_tuples * (input_tuples * limit_tuples / output_tuples);
+ 			else
+ 				startup_cost += cmps * cpu_operator_cost * input_tuples * input_tuples;
+ 			break;
+ 
+ 		case SM_BLOCKNESTEDLOOP:
+ 			/*
+ 			 * We assume that on average we have to compare the
+ 			 * input_tuples to the half of the tuples in the window
+ 			 * (output_tuples). FIXME: this is the ERWARTUNGSWERT?
+ 			 *
+ 			 * We don't gain anything by LIMIT, because tuples could be
+ 			 * kicked out of the tuplewindow, for instance there could be a
+ 			 * single best tuple at the very end.
+ 			 *
+ 			 * We further assume that if the output_tuples fit into the
+ 			 * window (enough_memory), that at no stage during the processing
+ 			 * the window would hold more than this tuples.
+ 			 */
+ 			if (enough_memory)
+ 				startup_cost += cmps * cpu_operator_cost * input_tuples * 0.5 * output_tuples;
+ 			else
+ 			{
+ 				/* FIXME */
+ 				startup_cost += cmps * cpu_operator_cost * input_tuples * 0.5 * output_tuples;
+ 			}
+ 			break;
+ 
+ 		case SM_SFS:
+ 			/*
+ 			 * We assume that on average we have to compare the
+ 			 * input_tuples to the half of the tuples in the window
+ 			 * (output_tuples).
+ 			 * 
+ 			 * In case of SFS we can make use of LIMIT an break earlier.
+ 			 */
+ 			startup_cost += cmps * cpu_operator_cost * input_tuples * 0.5 * (limit_is_useful ? limit_tuples : output_tuples);
+ 			break;
+ 
+ 		case SM_ELIMFILTER:
+ 			/* FIXME */
+ 			startup_cost += cmps * cpu_operator_cost * input_tuples * 0.5 * output_tuples;
+ 			break;
+ 
+ 		default:
+ 			elog(WARNING, "FIXME: skyline method `%d' unknown at %s:%d", skyline_method, __FILE__, __LINE__);
+ 			break;
+ 	}
+ 
+ 	/*
+ 	 * Also charge a small amount (arbitrarily set equal to operator cost) per
+ 	 * extracted tuple.  Note it's correct to use tuples not output_tuples
+ 	 * here --- the upper LIMIT will pro-rate the run cost so we'd be double
+ 	 * counting the LIMIT otherwise.
+ 	 */
+ 	run_cost += cpu_operator_cost * input_tuples;
+ 
+ 	path->startup_cost = startup_cost;
+ 	path->total_cost = startup_cost + run_cost;
+ }
+ 
+ /*
   * cost_sort
   *	  Determines and returns the cost of sorting a relation, including
   *	  the cost of reading the input data.
diff -cr --new-file -b --tabsize 4 -x CVS -x .svn -x tools pgsql-REL8_3_STABLE/src/backend/optimizer/path/pathkeys.c pgsql/src/backend/optimizer/path/pathkeys.c
*** pgsql-REL8_3_STABLE/src/backend/optimizer/path/pathkeys.c	Wed Jan  9 21:42:28 2008
--- pgsql/src/backend/optimizer/path/pathkeys.c	Thu Jan 10 19:37:02 2008
***************
*** 361,366 ****
--- 361,407 ----
  	return PATHKEYS_BETTER2;	/* key2 is longer */
  }
  
+ bool
+ skyline_pathkeys_contained_in(List *keys1, List *keys2, int *nuseful)
+ {
+ 	ListCell   *key1,
+ 			   *key2;
+ 	int			maxidx = 0;
+ 	bool		contained = true;		/* It's contained if it's empty but
+ 										 * that will never happen */
+ 
+ 	foreach(key1, keys1)
+ 	{
+ 		int			idx = 0;
+ 		PathKey    *pathkey1 = (PathKey *) lfirst(key1);
+ 
+ 		contained = false;
+ 
+ 		foreach(key2, keys2)
+ 		{
+ 			PathKey    *pathkey2 = (PathKey *) lfirst(key2);
+ 
+ 			++idx;
+ 
+ 			if (pathkey1 == pathkey2)
+ 			{
+ 				if (maxidx < idx)
+ 					maxidx = idx;
+ 
+ 				contained = true;
+ 				break;
+ 			}
+ 		}
+ 		if (!contained)
+ 			break;
+ 	}
+ 
+ 	if (nuseful)
+ 		*nuseful = maxidx;
+ 
+ 	return contained;
+ }
+ 
  /*
   * pathkeys_contained_in
   *	  Common special case of compare_pathkeys: we just want to know
***************
*** 453,458 ****
--- 494,525 ----
  	return matched_path;
  }
  
+ Path *
+ get_cheapest_fractional_path_for_skyline_pathkeys(List *paths,
+ 												  List *pathkeys,
+ 												  double fraction)
+ {
+ 	Path	   *matched_path = NULL;
+ 	ListCell   *l;
+ 
+ 	foreach(l, paths)
+ 	{
+ 		Path	   *path = (Path *) lfirst(l);
+ 
+ 		/*
+ 		 * Since cost comparison is a lot cheaper than pathkey comparison, do
+ 		 * that first.
+ 		 */
+ 		if (matched_path != NULL &&
+ 			compare_fractional_path_costs(matched_path, path, fraction) <= 0)
+ 			continue;
+ 
+ 		if (skyline_pathkeys_contained_in(pathkeys, path->pathkeys, NULL))
+ 			matched_path = path;
+ 	}
+ 	return matched_path;
+ }
+ 
  /****************************************************************************
   *		NEW PATHKEY FORMATION
   ****************************************************************************/
***************
*** 870,875 ****
--- 937,980 ----
  	return pathkeys;
  }
  
+ List *
+ make_pathkeys_for_skylineclause(PlannerInfo *root,
+ 								SkylineClause *skylineclause,
+ 								List *tlist,
+ 								bool canonicalize)
+ {
+ 	List	   *pathkeys = NIL;
+ 	ListCell   *l;
+ 
+ 	if (skylineclause != NULL)
+ 	{
+ 		foreach(l, skylineclause->skyline_of_list)
+ 		{
+ 			SkylineOf  *skylineof = (SkylineOf *) lfirst(l);
+ 			Expr	   *sortkey;
+ 			PathKey    *pathkey;
+ 
+ 			sortkey = (Expr *) get_sortgroupclause_expr((SortClause *) skylineof, tlist);
+ 			pathkey = make_pathkey_from_sortinfo(root,
+ 												 sortkey,
+ 												 skylineof->skylineop,
+ 												 skylineof->nulls_first,
+ 												 skylineof->tleSortGroupRef,
+ 												 canonicalize);
+ 
+ 			/* Canonical form eliminates redundant ordering keys */
+ 			if (canonicalize)
+ 			{
+ 				if (!pathkey_is_redundant(pathkey, pathkeys))
+ 					pathkeys = lappend(pathkeys, pathkey);
+ 			}
+ 			else
+ 				pathkeys = lappend(pathkeys, pathkey);
+ 		}
+ 	}
+ 	return pathkeys;
+ }
+ 
  /****************************************************************************
   *		PATHKEYS AND MERGECLAUSES
   ****************************************************************************/
***************
*** 1423,1428 ****
--- 1528,1535 ----
  int
  pathkeys_useful_for_ordering(PlannerInfo *root, List *pathkeys)
  {
+ 	int nuseful;
+ 
  	if (root->query_pathkeys == NIL)
  		return 0;				/* no special ordering requested */
  
***************
*** 1435,1440 ****
--- 1542,1553 ----
  		return list_length(root->query_pathkeys);
  	}
  
+ 	if (skyline_pathkeys_contained_in(root->skyline_pathkeys, pathkeys, &nuseful))
+ 	{
+ 		/* It's useful ... or at least the first nuseful keys are */
+ 		return nuseful;
+ 	}
+ 
  	return 0;					/* path ordering not useful */
  }
  
diff -cr --new-file -b --tabsize 4 -x CVS -x .svn -x tools pgsql-REL8_3_STABLE/src/backend/optimizer/plan/createplan.c pgsql/src/backend/optimizer/plan/createplan.c
*** pgsql-REL8_3_STABLE/src/backend/optimizer/plan/createplan.c	Thu Apr 17 23:22:23 2008
--- pgsql/src/backend/optimizer/plan/createplan.c	Wed Nov 12 00:04:36 2008
***************
*** 17,24 ****
--- 17,27 ----
  #include "postgres.h"
  
  #include <limits.h>
+ #include <math.h>
  
  #include "access/skey.h"
+ #include "access/printtup.h"
+ #include "catalog/pg_type.h"
  #include "nodes/makefuncs.h"
  #include "optimizer/clauses.h"
  #include "optimizer/cost.h"
***************
*** 29,37 ****
--- 32,44 ----
  #include "optimizer/tlist.h"
  #include "optimizer/var.h"
  #include "parser/parse_clause.h"
+ #include "parser/parse_coerce.h"
  #include "parser/parse_expr.h"
  #include "parser/parsetree.h"
  #include "utils/lsyscache.h"
+ #include "utils/selfuncs.h"
+ #include "utils/skyline.h"
+ #include "utils/syscache.h"
  
  
  static Plan *create_scan_plan(PlannerInfo *root, Path *best_path);
***************
*** 2691,2696 ****
--- 2698,2905 ----
  	return numCols + 1;
  }
  
+ static double
+ factorial(int d)
+ {
+ 	/* FIXME: take care for over runs */
+ 	double		res = 1.0;
+ 
+ 	for (; d > 1; d--)
+ 		res *= d;
+ 
+ 	return res;
+ }
+ 
+ /*	FIXME: ticket:34 */
+ static double
+ estimate_skyline_cardinality(double n, int d)
+ {
+ 	double		res;
+ 
+ 	if (n <= 1.0)
+ 		return 1.0;
+ 
+ 	res = pow(log(n + 1.0), d - 1) / factorial(d - 1);
+ 
+ 	/* avoid patological cases */
+ 	if (res > n)
+ 		res = n;
+ 
+ 	if (res < 1.0)
+ 		res = 1.0;
+ 
+ 	return res;
+ }
+ 
+ Skyline *
+ make_skyline(PlannerInfo *root, Plan *lefttree, Node *skyline_clause, SkylineMethod skyline_method, int limit_tuples)
+ {
+ 	Plan	   *outertree = lefttree;
+ 	List	   *sub_tlist = outertree->targetlist;
+ 	ListCell   *l;
+ 	Skyline    *node = makeNode(Skyline);
+ 	Plan	   *plan = &node->plan;
+ 	int			numskylinecols;
+ 	SkylineClause *sc = (SkylineClause *) skyline_clause;
+ 	List	   *skylinecls = sc->skyline_of_list;
+ 	bool		have_stats = false;
+ 
+ 	plan->targetlist = outertree->targetlist;
+ 	plan->qual = NIL;
+ 	plan->lefttree = outertree;
+ 	plan->righttree = NULL;
+ 
+ 	numskylinecols = list_length(skylinecls);
+ 
+ 	node->flags = 0;
+ 	node->skylineColIdx = (AttrNumber *) palloc(numskylinecols * sizeof(AttrNumber));
+ 	node->skylineOfOperators = (Oid *) palloc(numskylinecols * sizeof(Oid));
+ 	node->nullsFirst = (bool *) palloc(numskylinecols * sizeof(bool));
+ 	node->skylineOfDir = (int *) palloc(numskylinecols * sizeof(int));
+ 	node->colFlags = (int *) palloc(numskylinecols * sizeof(int));
+ 	node->colMin = (float8 *) palloc(numskylinecols * sizeof(float8));
+ 	node->colScale = (float8 *) palloc(numskylinecols * sizeof(float8));
+ 	node->colCoerceFunc = (Oid *) palloc(numskylinecols * sizeof(Oid));
+ 
+ 	numskylinecols = 0;
+ 	foreach(l, skylinecls)
+ 	{
+ 		SkylineOf		   *skylineof = (SkylineOf *) lfirst(l);
+ 		TargetEntry		   *tle = get_skylineclause_tle(skylineof, sub_tlist);
+ 		Oid					coerce_func = InvalidOid;
+ 		CoercionPathType	pathtype = find_coercion_pathway(FLOAT8OID, skylineof->restype, COERCION_IMPLICIT, &coerce_func);
+ 
+ 		node->skylineColIdx[numskylinecols] = tle->resno;
+ 		node->skylineOfOperators[numskylinecols] = skylineof->skylineop;
+ 		node->nullsFirst[numskylinecols] = skylineof->nulls_first;
+ 		node->skylineOfDir[numskylinecols] = (int) skylineof->skylineof_dir;
+ 		node->colFlags[numskylinecols] = SKYLINE_FLAGS_NONE;
+ 		node->colCoerceFunc[numskylinecols] = InvalidOid;
+ 	
+ 		if (pathtype != COERCION_PATH_NONE)
+ 		{
+ 			VariableStatData	vardata;
+ 
+ 			node->colFlags[numskylinecols] |= SKYLINE_FLAGS_COERCE;
+ 
+ 			/* examine stats */
+ 			examine_variable(root, (Node *)tle->expr, 0, &vardata);
+ 			if (vardata.statsTuple != NULL)
+ 			{
+ 				Datum	min;
+ 				Datum	max;
+ 
+ 				if(get_variable_range(root, &vardata, skylineof->skylineop,
+ 									  &min, &max))
+ 				{
+ 					char	   *min_value;
+ 					char	   *max_value;
+ 					double		min_as_double;
+ 					double		max_as_double;
+ 					double		range;
+ 
+ 					/* for debugging */
+ 					min_value = datum_to_text(min, false, skylineof->restype);
+ 					max_value = datum_to_text(max, false, skylineof->restype);
+ 					elog(DEBUG1, "stats for column '%s': [%s,%s]", (tle->resname ? tle->resname : "?"), min_value, max_value);
+ 					pfree(min_value);
+ 					pfree(max_value);
+ 
+ 					switch (pathtype)
+ 					{
+ 					case COERCION_PATH_FUNC:		/* apply the specified coercion function */
+ 						min = OidFunctionCall1(coerce_func, min);
+ 						max = OidFunctionCall1(coerce_func, max);
+ 
+ 						node->colCoerceFunc[numskylinecols] = coerce_func;
+ 						node->colFlags[numskylinecols] |= SKYLINE_FLAGS_COERCE_FUNC;
+ 						/* fall throught */
+ 
+ 					case COERCION_PATH_RELABELTYPE:	/* binary-compatible cast, no function */
+ 						min_as_double = DatumGetFloat8(min);
+ 						max_as_double = DatumGetFloat8(max);
+ 
+ 						range = max_as_double - min_as_double;
+ 
+ 						if (range < SKYLINE_RANK_EPSILON)
+ 							range = SKYLINE_RANK_EPSILON;
+ 
+ 						node->colMin[numskylinecols] = min_as_double - SKYLINE_RANK_BOUND_MIN;
+ 						node->colScale[numskylinecols] = SKYLINE_RANK_RANGE / range;
+ 
+ 						node->colFlags[numskylinecols] |= SKYLINE_FLAGS_HAVE_STATS;
+ 
+ 						have_stats = true;
+ 						break;
+ 						
+ 					case COERCION_PATH_ARRAYCOERCE:	/* need an ArrayCoerceExpr node */
+ 					case COERCION_PATH_COERCEVIAIO:	/* need a CoerceViaIO node */
+ 					case COERCION_PATH_NONE:		/* failed to find any coercion pathway */
+ 					default:
+ 						/* do nothing */
+ 						break;
+ 					}
+ 				}
+ 			}
+ 			else
+ 				elog(DEBUG1, "no stats for column '%s'", (tle->resname ? tle->resname : "?"));
+ 			ReleaseVariableStats(vardata);
+ 		}
+ 
+ 		if (!(node->colFlags[numskylinecols] & SKYLINE_FLAGS_HAVE_STATS))
+ 		{
+ 			/* just place some sane values there */
+ 			node->colMin[numskylinecols] = 0.0 - SKYLINE_RANK_BOUND_MIN;
+ 			node->colScale[numskylinecols] = SKYLINE_RANK_RANGE;
+ 		}
+ 
+ 		numskylinecols++;
+ 	}
+ 
+ 	node->numCols = numskylinecols;
+ 
+ 	if (have_stats)
+ 		node->flags |= SKYLINE_FLAGS_HAVE_STATS;
+ 
+ 	/* only care about copying size */
+ 	copy_plan_costsize(plan, outertree);
+ 
+ 	plan->plan_rows = estimate_skyline_cardinality(outertree->plan_rows, numskylinecols);
+ 	{
+ 		Path		path;		/* just a dummy */
+ 
+ 		/*
+ 		 * FIXME: in the presents of a Elimination Filter we must estimate
+ 		 * the rows different, in fact we just should take the
+ 		 * outertree->plan_rows
+ 		 */
+ 		cost_skyline(&path, root, outertree->startup_cost, outertree->plan_rows, outertree->plan_width, plan->plan_rows, numskylinecols, skyline_method, limit_tuples);
+ 
+ 		plan->startup_cost = path.startup_cost;
+ 		plan->total_cost = path.total_cost;
+ 	}
+ 
+ 	node->skyline_distinct = sc->skyline_distinct;
+ 	node->skyline_of_options = sc->skyline_of_options;
+ 	node->skyline_method = skyline_method;
+ 
+ 	/* To disable use: return (Skyline *) lefttree; */
+ 	return node;
+ }
+ 
+ ElimFilter *
+ make_elimfilter(PlannerInfo *root, Plan *lefttree, Node *skyline_clause, int limit_tuples)
+ {
+ 	ElimFilter *node = (ElimFilter *) make_skyline(root, lefttree, skyline_clause, SM_ELIMFILTER, limit_tuples);
+ 	/*
+ 	 * This is bit of a hack, we change the node type for T_Skyline to 
+ 	 * T_ElimFilter.
+ 	 */
+ 	node->plan.type = T_ElimFilter;
+ 
+ 	return node;
+ }
+ 
  /*
   * make_sort_from_pathkeys
   *	  Create sort plan to sort according to given pathkeys
diff -cr --new-file -b --tabsize 4 -x CVS -x .svn -x tools pgsql-REL8_3_STABLE/src/backend/optimizer/plan/planmain.c pgsql/src/backend/optimizer/plan/planmain.c
*** pgsql-REL8_3_STABLE/src/backend/optimizer/plan/planmain.c	Fri Jan 11 05:02:18 2008
--- pgsql/src/backend/optimizer/plan/planmain.c	Fri Feb  8 09:53:14 2008
***************
*** 83,95 ****
  void
  query_planner(PlannerInfo *root, List *tlist,
  			  double tuple_fraction, double limit_tuples,
! 			  Path **cheapest_path, Path **sorted_path,
  			  double *num_groups)
  {
  	Query	   *parse = root->parse;
  	List	   *joinlist;
  	RelOptInfo *final_rel;
  	Path	   *cheapestpath;
  	Path	   *sortedpath;
  	Index		rti;
  	ListCell   *lc;
--- 83,96 ----
  void
  query_planner(PlannerInfo *root, List *tlist,
  			  double tuple_fraction, double limit_tuples,
! 			  Path **cheapest_path, Path **sorted_path, Path **skyline_path,
  			  double *num_groups)
  {
  	Query	   *parse = root->parse;
  	List	   *joinlist;
  	RelOptInfo *final_rel;
  	Path	   *cheapestpath;
+ 	Path	   *skylinepath;
  	Path	   *sortedpath;
  	Index		rti;
  	ListCell   *lc;
***************
*** 110,115 ****
--- 111,117 ----
  		*cheapest_path = (Path *)
  			create_result_path((List *) parse->jointree->quals);
  		*sorted_path = NULL;
+ 		*skyline_path = NULL;
  
  		/*
  		 * We still are required to canonicalize any pathkeys, in case it's
***************
*** 120,125 ****
--- 122,129 ----
  													 root->query_pathkeys);
  		root->group_pathkeys = canonicalize_pathkeys(root,
  													 root->group_pathkeys);
+ 		root->skyline_pathkeys = canonicalize_pathkeys(root,
+ 													 root->skyline_pathkeys);
  		root->sort_pathkeys = canonicalize_pathkeys(root,
  													root->sort_pathkeys);
  		return;
***************
*** 241,246 ****
--- 245,251 ----
  	 */
  	root->query_pathkeys = canonicalize_pathkeys(root, root->query_pathkeys);
  	root->group_pathkeys = canonicalize_pathkeys(root, root->group_pathkeys);
+ 	root->skyline_pathkeys = canonicalize_pathkeys(root, root->skyline_pathkeys);
  	root->sort_pathkeys = canonicalize_pathkeys(root, root->sort_pathkeys);
  
  	/*
***************
*** 350,355 ****
--- 355,365 ----
  	 */
  	cheapestpath = final_rel->cheapest_total_path;
  
+ 	skylinepath =
+ 		get_cheapest_fractional_path_for_skyline_pathkeys(final_rel->pathlist,
+ 														  root->query_pathkeys,
+ 														  tuple_fraction);
+ 
  	sortedpath =
  		get_cheapest_fractional_path_for_pathkeys(final_rel->pathlist,
  												  root->query_pathkeys,
***************
*** 359,369 ****
--- 369,414 ----
  	if (sortedpath == cheapestpath)
  		sortedpath = NULL;
  
+ 	if (sortedpath == skylinepath)
+ 		sortedpath = NULL;
+ 
+ 	if (skylinepath == cheapestpath)
+ 		skylinepath = NULL;
+ 
  	/*
  	 * Forget about the presorted path if it would be cheaper to sort the
  	 * cheapest-total path.  Here we need consider only the behavior at the
  	 * tuple fraction point.
  	 */
+ 	if (skylinepath)
+ 	{
+ 		Path		path;		/* dummy for result of cost_sort */
+ 
+ 		if (root->query_pathkeys == NIL ||
+ 			skyline_pathkeys_contained_in(root->query_pathkeys,
+ 										  cheapestpath->pathkeys, NULL))
+ 		{
+ 			/* No sort needed for cheapest path */
+ 			path.startup_cost = cheapestpath->startup_cost;
+ 			path.total_cost = cheapestpath->total_cost;
+ 		}
+ 		else
+ 		{
+ 			/* Figure cost for sorting */
+ 			cost_sort(&path, root, root->query_pathkeys,
+ 					  cheapestpath->total_cost,
+ 					  final_rel->rows, final_rel->width,
+ 					  limit_tuples);
+ 		}
+ 
+ 		if (compare_fractional_path_costs(skylinepath, &path,
+ 										  tuple_fraction) > 0)
+ 		{
+ 			/* Presorted path is a loser */
+ 			skylinepath = NULL;
+ 		}
+ 	}
+ 
  	if (sortedpath)
  	{
  		Path		sort_path;	/* dummy for result of cost_sort */
***************
*** 395,398 ****
--- 440,444 ----
  
  	*cheapest_path = cheapestpath;
  	*sorted_path = sortedpath;
+ 	*skyline_path = skylinepath;
  }
diff -cr --new-file -b --tabsize 4 -x CVS -x .svn -x tools pgsql-REL8_3_STABLE/src/backend/optimizer/plan/planner.c pgsql/src/backend/optimizer/plan/planner.c
*** pgsql-REL8_3_STABLE/src/backend/optimizer/plan/planner.c	Thu Apr 17 23:22:23 2008
--- pgsql/src/backend/optimizer/plan/planner.c	Tue Nov 11 19:50:14 2008
***************
*** 39,44 ****
--- 39,45 ----
  #include "parser/parse_oper.h"
  #include "parser/parsetree.h"
  #include "utils/lsyscache.h"
+ #include "utils/skyline.h"
  #include "utils/syscache.h"
  
  
***************
*** 229,235 ****
   *--------------------
   */
  Plan *
! subquery_planner(PlannerGlobal *glob, Query *parse,
  				 Index level, double tuple_fraction,
  				 PlannerInfo **subroot)
  {
--- 230,236 ----
   *--------------------
   */
  Plan *
! subquery_planner(PlannerGlobal * glob, Query *parse,
  				 Index level, double tuple_fraction,
  				 PlannerInfo **subroot)
  {
***************
*** 814,824 ****
--- 815,827 ----
  		/* No set operations, do regular planning */
  		List	   *sub_tlist;
  		List	   *group_pathkeys;
+ 		List	   *skyline_pathkeys;
  		AttrNumber *groupColIdx = NULL;
  		Oid		   *groupOperators = NULL;
  		bool		need_tlist_eval = true;
  		QualCost	tlist_cost;
  		Path	   *cheapest_path;
+ 		Path	   *skyline_path;
  		Path	   *sorted_path;
  		Path	   *best_path;
  		long		numGroups = 0;
***************
*** 848,853 ****
--- 851,862 ----
  										  parse->groupClause,
  										  tlist,
  										  false);
+ 
+ 		root->skyline_pathkeys =
+ 			make_pathkeys_for_skylineclause(root,
+ 											(SkylineClause *) parse->skylineClause,
+ 											tlist,
+ 											false);
  		root->sort_pathkeys =
  			make_pathkeys_for_sortclauses(root,
  										  parse->sortClause,
***************
*** 871,876 ****
--- 880,886 ----
  			count_agg_clauses(parse->havingQual, &agg_counts);
  		}
  
+ 		/* FIXME: update comment */
  		/*
  		 * Figure out whether we need a sorted result from query_planner.
  		 *
***************
*** 883,888 ****
--- 893,900 ----
  		 */
  		if (parse->groupClause)
  			root->query_pathkeys = root->group_pathkeys;
+ 		else if (parse->skylineClause)
+ 			root->query_pathkeys = root->skyline_pathkeys;
  		else if (parse->sortClause)
  			root->query_pathkeys = root->sort_pathkeys;
  		else
***************
*** 895,903 ****
  		 * the pathkeys.
  		 */
  		query_planner(root, sub_tlist, tuple_fraction, limit_tuples,
! 					  &cheapest_path, &sorted_path, &dNumGroups);
  
  		group_pathkeys = root->group_pathkeys;
  		sort_pathkeys = root->sort_pathkeys;
  
  		/*
--- 907,926 ----
  		 * the pathkeys.
  		 */
  		query_planner(root, sub_tlist, tuple_fraction, limit_tuples,
! 					  &cheapest_path, &sorted_path, &skyline_path, &dNumGroups);
  
  		group_pathkeys = root->group_pathkeys;
+ 		skyline_pathkeys = root->skyline_pathkeys;
+ 		/* on "SKYLINE OF ... WITH NOINDEX" drop skyline_pathkeys */
+ 		if (parse->skylineClause != NULL)
+ 		{
+ 			int		no_index;
+ 			if (skyline_option_get_int(((SkylineClause *) parse->skylineClause)->skyline_of_options, "noindex", &no_index))
+ 			{
+ 				skyline_path = NULL;
+ 				skyline_pathkeys = NULL;
+ 			}
+ 		}
  		sort_pathkeys = root->sort_pathkeys;
  
  		/*
***************
*** 922,929 ****
  		 * always read all the input tuples, so use the cheapest-total path.
  		 * Otherwise, trust query_planner's decision about which to use.
  		 */
! 		if (use_hashed_grouping || !sorted_path)
  			best_path = cheapest_path;
  		else
  			best_path = sorted_path;
  
--- 945,969 ----
  		 * always read all the input tuples, so use the cheapest-total path.
  		 * Otherwise, trust query_planner's decision about which to use.
  		 */
! 		if (use_hashed_grouping || (!sorted_path && !(parse->skylineClause && skyline_path)))
! 			best_path = cheapest_path;
! 		else if (parse->skylineClause && skyline_path)
! 		{
! 			SkylineMethod	skyline_method = skyline_method_forced_by_options((SkylineClause *) parse->skylineClause);
! 			int				skyline_dim = skyline_get_dim((SkylineClause *) parse->skylineClause);
! 
! 			if (skyline_dim == 2 && (skyline_method == SM_UNKNOWN || skyline_method == SM_2DIM_PRESORT))
! 				best_path = skyline_path;
! 			else if (skyline_dim >= 2 && (skyline_method == SM_UNKNOWN || skyline_method == SM_SFS))
! 				best_path = skyline_path;
! 			else
! 			{
! 				if (sorted_path)
! 					best_path = sorted_path;
! 				else
  					best_path = cheapest_path;
+ 			}
+ 		}
  		else
  			best_path = sorted_path;
  
***************
*** 1146,1151 ****
--- 1186,1247 ----
  		}						/* end of non-minmax-aggregate case */
  	}							/* end of if (setOperations) */
  
+ 	if (parse->skylineClause)
+ 	{
+ 		/*
+ 		 * FIXME: refactor this, the method needs to be known here, maybe
+ 		 * store it in the analyzed clause
+ 		 */
+ 		bool			has_matching_path = skyline_pathkeys_contained_in(root->skyline_pathkeys, current_pathkeys, NULL);
+ 		SkylineMethod	skyline_method = skyline_choose_method((SkylineClause *) parse->skylineClause, has_matching_path);
+ 
+ 		Assert(skyline_method != SM_UNKNOWN);
+ 
+ 		{
+ 			int	use_elim_filter = 0;
+ 
+ 			if (skyline_option_get_int(((SkylineClause *) parse->skylineClause)->skyline_of_options, "ef", &use_elim_filter))
+ 			{
+ 				result_plan = (Plan *) make_elimfilter(root, result_plan, parse->skylineClause, limit_tuples);
+ 
+ 				/*
+ 				 * Note that the relative tuple order is preserved by the elimination filter.
+ 				 */
+ 			}
+ 		}
+ 
+ 		if (skyline_method == SM_2DIM_PRESORT || skyline_method == SM_SFS)
+ 		{
+ 			if (!has_matching_path)
+ 			{
+ 				result_plan = (Plan *) make_sort_from_pathkeys(root,
+ 															   result_plan,
+ 															   root->skyline_pathkeys,
+ 															   limit_tuples);
+ 				current_pathkeys = root->skyline_pathkeys;
+ 			}
+ 		}
+ 		else if (skyline_method == SM_MATERIALIZEDNESTEDLOOP)
+ 		{
+ 			/*
+ 			 * for the materialized nested loop we need a materialize as outer
+ 			 * plan
+ 			 */
+ 			result_plan = materialize_finished_plan(result_plan);
+ 		}
+ 
+ 		result_plan = (Plan *) make_skyline(root, result_plan, parse->skylineClause, skyline_method, limit_tuples);
+ 
+ 		if (!skyline_method_preserves_tuple_order(skyline_method))
+ 		{
+ 			/*
+ 			 * the skyline method used eventually changes the realtive order
+ 			 * of the tuples, so we drop the current_pathkeys here
+ 			 */
+ 			current_pathkeys = NIL;
+ 		}
+ 	}
+ 
  	/*
  	 * If we were not able to make the plan come out in the right order, add
  	 * an explicit sort step.
diff -cr --new-file -b --tabsize 4 -x CVS -x .svn -x tools pgsql-REL8_3_STABLE/src/backend/optimizer/plan/setrefs.c pgsql/src/backend/optimizer/plan/setrefs.c
*** pgsql-REL8_3_STABLE/src/backend/optimizer/plan/setrefs.c	Tue Jun 17 16:51:38 2008
--- pgsql/src/backend/optimizer/plan/setrefs.c	Tue Nov 11 17:53:27 2008
***************
*** 346,351 ****
--- 346,353 ----
  		case T_Hash:
  		case T_Material:
  		case T_Sort:
+ 		case T_Skyline:
+ 		case T_ElimFilter:
  		case T_Unique:
  		case T_SetOp:
  
diff -cr --new-file -b --tabsize 4 -x CVS -x .svn -x tools pgsql-REL8_3_STABLE/src/backend/optimizer/plan/subselect.c pgsql/src/backend/optimizer/plan/subselect.c
*** pgsql-REL8_3_STABLE/src/backend/optimizer/plan/subselect.c	Thu Jul 10 03:17:36 2008
--- pgsql/src/backend/optimizer/plan/subselect.c	Tue Nov 11 17:53:26 2008
***************
*** 1289,1294 ****
--- 1289,1296 ----
  		case T_Unique:
  		case T_SetOp:
  		case T_Group:
+ 		case T_Skyline:
+ 		case T_ElimFilter:
  			break;
  
  		default:
diff -cr --new-file -b --tabsize 4 -x CVS -x .svn -x tools pgsql-REL8_3_STABLE/src/backend/optimizer/prep/prepjointree.c pgsql/src/backend/optimizer/prep/prepjointree.c
*** pgsql-REL8_3_STABLE/src/backend/optimizer/prep/prepjointree.c	Thu Aug 14 22:31:59 2008
--- pgsql/src/backend/optimizer/prep/prepjointree.c	Tue Nov 11 17:53:26 2008
***************
*** 648,659 ****
  		return false;
  
  	/*
! 	 * Can't pull up a subquery involving grouping, aggregation, sorting, or
! 	 * limiting.
  	 */
  	if (subquery->hasAggs ||
  		subquery->groupClause ||
  		subquery->havingQual ||
  		subquery->sortClause ||
  		subquery->distinctClause ||
  		subquery->limitOffset ||
--- 648,660 ----
  		return false;
  
  	/*
! 	 * Can't pull up a subquery involving grouping, aggregation, skylining,
! 	 * sorting, or limiting.
  	 */
  	if (subquery->hasAggs ||
  		subquery->groupClause ||
  		subquery->havingQual ||
+ 		subquery->skylineClause ||
  		subquery->sortClause ||
  		subquery->distinctClause ||
  		subquery->limitOffset ||
diff -cr --new-file -b --tabsize 4 -x CVS -x .svn -x tools pgsql-REL8_3_STABLE/src/backend/optimizer/util/tlist.c pgsql/src/backend/optimizer/util/tlist.c
*** pgsql-REL8_3_STABLE/src/backend/optimizer/util/tlist.c	Tue Jan  1 20:45:50 2008
--- pgsql/src/backend/optimizer/util/tlist.c	Thu Jan 10 19:37:03 2008
***************
*** 154,159 ****
--- 154,179 ----
  	return NULL;				/* keep compiler quiet */
  }
  
+ TargetEntry *
+ get_skylineclause_tle(SkylineOf *skylineOf,
+ 					  List *targetList)
+ {
+ 	Index		refnumber = skylineOf->tleSortGroupRef;
+ 	ListCell   *l;
+ 
+ 	foreach(l, targetList)
+ 	{
+ 		TargetEntry *tle = (TargetEntry *) lfirst(l);
+ 
+ 		if (tle->ressortgroupref == refnumber)
+ 			return tle;
+ 	}
+ 
+ 	elog(ERROR, "ORDER/GROUP BY/SKYLINE OF expression not found in targetlist");
+ 	return NULL;				/* keep compiler quiet */
+ }
+ 
+ 
  /*
   * get_sortgroupclause_tle
   *		Find the targetlist entry matching the given SortClause
diff -cr --new-file -b --tabsize 4 -x CVS -x .svn -x tools pgsql-REL8_3_STABLE/src/backend/parser/analyze.c pgsql/src/backend/parser/analyze.c
*** pgsql-REL8_3_STABLE/src/backend/parser/analyze.c	Tue Jan  1 20:45:50 2008
--- pgsql/src/backend/parser/analyze.c	Thu Jan 10 19:37:12 2008
***************
*** 26,31 ****
--- 26,32 ----
  
  #include "catalog/pg_type.h"
  #include "nodes/makefuncs.h"
+ #include "nodes/print.h"
  #include "optimizer/clauses.h"
  #include "optimizer/var.h"
  #include "parser/analyze.h"
***************
*** 725,730 ****
--- 726,736 ----
  												  &qry->targetList,
  												  &qry->sortClause);
  
+ 	qry->skylineClause = transformSkylineClause(pstate,
+ 												stmt->skylineOfClause,
+ 												&qry->targetList,
+ 												true /* fix unknowns */ );
+ 
  	qry->limitOffset = transformLimitClause(pstate, stmt->limitOffset,
  											"OFFSET");
  	qry->limitCount = transformLimitClause(pstate, stmt->limitCount,
diff -cr --new-file -b --tabsize 4 -x CVS -x .svn -x tools pgsql-REL8_3_STABLE/src/backend/parser/gram.y pgsql/src/backend/parser/gram.y
*** pgsql-REL8_3_STABLE/src/backend/parser/gram.y	Thu Feb  7 22:07:55 2008
--- pgsql/src/backend/parser/gram.y	Tue Nov 11 23:29:50 2008
***************
*** 135,140 ****
--- 135,142 ----
  	FuncWithArgs		*funwithargs;
  	DefElem				*defelt;
  	SortBy				*sortby;
+ 	SkylineOfExpr		*skyline_of_expr;
+ 	SkylineOption		*slopt;
  	JoinExpr			*jexpr;
  	IndexElem			*ielem;
  	Alias				*alias;
***************
*** 239,245 ****
  				sort_clause opt_sort_clause sortby_list index_params
  				name_list from_clause from_list opt_array_bounds
  				qualified_name_list any_name any_name_list
! 				any_operator expr_list attrs
  				target_list insert_column_list set_target_list
  				set_clause_list set_clause multiple_set_clause
  				ctext_expr_list ctext_row def_list indirection opt_indirection
--- 241,247 ----
  				sort_clause opt_sort_clause sortby_list index_params
  				name_list from_clause from_list opt_array_bounds
  				qualified_name_list any_name any_name_list
! 				any_operator expr_list skyline_of_list attrs
  				target_list insert_column_list set_target_list
  				set_clause_list set_clause multiple_set_clause
  				ctext_expr_list ctext_row def_list indirection opt_indirection
***************
*** 251,256 ****
--- 253,260 ----
  				execute_param_clause using_clause returning_clause
  				enum_val_list
  
+ %type <node>	skyline_clause
+ 
  %type <range>	OptTempTableName
  %type <into>	into_clause create_as_target
  
***************
*** 294,299 ****
--- 298,306 ----
  
  %type <vsetstmt> set_rest SetResetClause
  
+ %type <slopt>	skyline_option
+ %type <list>	skyline_options opt_skyline_options
+ 
  %type <node>	TableElement ConstraintElem TableFuncElement
  %type <node>	columnDef
  %type <defelt>	def_elem old_aggr_elem
***************
*** 309,314 ****
--- 316,322 ----
  %type <value>	NumericOnly FloatOnly IntegerOnly
  %type <alias>	alias_clause
  %type <sortby>	sortby
+ %type <skyline_of_expr>	skyline_of_expr
  %type <ielem>	index_elem
  %type <node>	table_ref
  %type <jexpr>	joined_table
***************
*** 429,435 ****
  
  	SAVEPOINT SCHEMA SCROLL SEARCH SECOND_P SECURITY SELECT SEQUENCE
  	SERIALIZABLE SESSION SESSION_USER SET SETOF SHARE
! 	SHOW SIMILAR SIMPLE SMALLINT SOME STABLE STANDALONE_P START STATEMENT
  	STATISTICS STDIN STDOUT STORAGE STRICT_P STRIP_P SUBSTRING SUPERUSER_P
  	SYMMETRIC SYSID SYSTEM_P
  
--- 437,443 ----
  
  	SAVEPOINT SCHEMA SCROLL SEARCH SECOND_P SECURITY SELECT SEQUENCE
  	SERIALIZABLE SESSION SESSION_USER SET SETOF SHARE
! 	SHOW SIMILAR SIMPLE SKYLINE SMALLINT SOME STABLE STANDALONE_P START STATEMENT
  	STATISTICS STDIN STDOUT STORAGE STRICT_P STRIP_P SUBSTRING SUPERUSER_P
  	SYMMETRIC SYSID SYSTEM_P
  
***************
*** 6208,6214 ****
  simple_select:
  			SELECT opt_distinct target_list
  			into_clause from_clause where_clause
! 			group_clause having_clause
  				{
  					SelectStmt *n = makeNode(SelectStmt);
  					n->distinctClause = $2;
--- 6216,6222 ----
  simple_select:
  			SELECT opt_distinct target_list
  			into_clause from_clause where_clause
! 			group_clause having_clause skyline_clause
  				{
  					SelectStmt *n = makeNode(SelectStmt);
  					n->distinctClause = $2;
***************
*** 6218,6223 ****
--- 6226,6232 ----
  					n->whereClause = $6;
  					n->groupClause = $7;
  					n->havingClause = $8;
+ 					n->skylineOfClause = $9;
  					$$ = (Node *)n;
  				}
  			| values_clause							{ $$ = $1; }
***************
*** 6398,6403 ****
--- 6407,6506 ----
  			| /*EMPTY*/								{ $$ = NULL; }
  		;
  
+ skyline_clause:
+ 			SKYLINE	OF skyline_of_list opt_skyline_options
+ 				{
+ 					SkylineOfClause *n = makeNode(SkylineOfClause);
+ 					n->skyline_of_list = $3; 
+ 					n->skyline_distinct = false;
+ 					n->skyline_of_options = $4;
+ 					$$ = (Node *)n;
+ 				}
+ 			| SKYLINE OF DISTINCT skyline_of_list opt_skyline_options
+ 				{
+ 					SkylineOfClause *n = makeNode(SkylineOfClause);
+ 					n->skyline_of_list = $4;
+ 					n->skyline_distinct = true;
+ 					n->skyline_of_options = $5;
+ 					$$ = (Node *)n;
+ 				}
+ 			| /*EMPTY*/								{ $$ = NULL; }
+ 		;
+ 
+ skyline_of_list:
+ 			skyline_of_expr
+ 				{
+ 					$$ = list_make1($1);
+ 				}
+ 			| skyline_of_list ',' skyline_of_expr
+ 				{
+ 					$$ = lappend($1, $3);
+ 				}
+ 		;
+ 
+ /*
+  * FIMXE: skyline attr is a restricted to c_expr instead of a_expr
+  * to avoid shift/reduce conflicts.
+  */
+ skyline_of_expr: 
+ 			c_expr IDENT opt_nulls_order
+ 				{
+ 					$$ = makeNode(SkylineOfExpr);
+ 					$$->node = $1;
+ 					if (strcmp($2, "min") == 0)
+ 						$$->skylineof_dir = SKYLINEOF_MIN;
+ 					else if (strcmp($2, "max") == 0)
+ 						$$->skylineof_dir = SKYLINEOF_MAX;
+ 					else if (strcmp($2, "diff") == 0)
+ 						$$->skylineof_dir = SKYLINEOF_DIFF;
+ 					else
+ 						yyerror("syntax error");
+ 					$$->useOp = NIL;
+ 					$$->skylineof_nulls = $3;
+ 				}
+ 			| c_expr USING qual_all_Op opt_nulls_order
+ 				{
+ 					$$ = makeNode(SkylineOfExpr);
+ 					$$->node = $1;
+ 					$$->skylineof_dir = SKYLINEOF_USING;
+ 					$$->useOp = $3;
+ 					$$->skylineof_nulls = $4;
+ 				}
+ 		;
+ 
+ opt_skyline_options:
+ 			WITH skyline_options					{ $$ = $2; }
+ 			| /* EMPTY */							{ $$ = NIL; }
+ 		;
+ 
+ skyline_options:
+ 			skyline_option
+ 				{ 
+ 					$$ = list_make1($1);
+ 				}
+ 			| skyline_options skyline_option
+ 				{
+ 					$$ = lappend($1, $2);
+ 				}
+ 		;
+ 
+ skyline_option:
+ 			var_name
+ 				{
+ 					SkylineOption *n = makeNode(SkylineOption);
+ 					n->name = $1;
+ 					n->value = makeIntConst(1);
+ 					$$ = n;
+ 				}
+ 			| var_name '=' var_value
+ 				{
+ 					SkylineOption *n = makeNode(SkylineOption);
+ 					n->name = $1;
+ 					n->value = $3;
+ 					$$ = n;
+ 				}
+ 		;
+ 
  for_locking_clause:
  			for_locking_items						{ $$ = $1; }
  			| FOR READ ONLY							{ $$ = NIL; }
***************
*** 9393,9398 ****
--- 9496,9502 ----
  			| RETURNING
  			| SELECT
  			| SESSION_USER
+ 			| SKYLINE
  			| SOME
  			| SYMMETRIC
  			| TABLE
diff -cr --new-file -b --tabsize 4 -x CVS -x .svn -x tools pgsql-REL8_3_STABLE/src/backend/parser/keywords.c pgsql/src/backend/parser/keywords.c
*** pgsql-REL8_3_STABLE/src/backend/parser/keywords.c	Tue Jan  1 20:45:50 2008
--- pgsql/src/backend/parser/keywords.c	Thu Jan 10 19:37:12 2008
***************
*** 327,332 ****
--- 327,333 ----
  	{"show", SHOW, UNRESERVED_KEYWORD},
  	{"similar", SIMILAR, TYPE_FUNC_NAME_KEYWORD},
  	{"simple", SIMPLE, UNRESERVED_KEYWORD},
+ 	{"skyline", SKYLINE, RESERVED_KEYWORD},
  	{"smallint", SMALLINT, COL_NAME_KEYWORD},
  	{"some", SOME, RESERVED_KEYWORD},
  	{"stable", STABLE, UNRESERVED_KEYWORD},
diff -cr --new-file -b --tabsize 4 -x CVS -x .svn -x tools pgsql-REL8_3_STABLE/src/backend/parser/parse_agg.c pgsql/src/backend/parser/parse_agg.c
*** pgsql-REL8_3_STABLE/src/backend/parser/parse_agg.c	Tue Jan  1 20:45:50 2008
--- pgsql/src/backend/parser/parse_agg.c	Tue Mar 18 23:28:24 2008
***************
*** 144,149 ****
--- 144,153 ----
  		groupClauses = lcons(expr, groupClauses);
  	}
  
+ 	/* FIXME:
+ 	 * No aggregates allowed in SKYLINE OF clauses, either. ???
+ 	 */
+ 
  	/*
  	 * If there are join alias vars involved, we have to flatten them to the
  	 * underlying vars, so that aliased and unaliased vars will be correctly
diff -cr --new-file -b --tabsize 4 -x CVS -x .svn -x tools pgsql-REL8_3_STABLE/src/backend/parser/parse_clause.c pgsql/src/backend/parser/parse_clause.c
*** pgsql-REL8_3_STABLE/src/backend/parser/parse_clause.c	Tue Jan  1 20:45:50 2008
--- pgsql/src/backend/parser/parse_clause.c	Tue Nov 11 22:30:58 2008
***************
*** 31,36 ****
--- 31,37 ----
  #include "parser/parse_oper.h"
  #include "parser/parse_relation.h"
  #include "parser/parse_target.h"
+ #include "parser/parse_type.h"
  #include "rewrite/rewriteManip.h"
  #include "utils/guc.h"
  #include "utils/lsyscache.h"
***************
*** 39,46 ****
  #define ORDER_CLAUSE 0
  #define GROUP_CLAUSE 1
  #define DISTINCT_ON_CLAUSE 2
  
! static char *clauseText[] = {"ORDER BY", "GROUP BY", "DISTINCT ON"};
  
  static void extractRemainingColumns(List *common_colnames,
  						List *src_colnames, List *src_colvars,
--- 40,48 ----
  #define ORDER_CLAUSE 0
  #define GROUP_CLAUSE 1
  #define DISTINCT_ON_CLAUSE 2
+ #define SKYLINE_CLAUSE 3
  
! static char *clauseText[] = {"ORDER BY", "GROUP BY", "DISTINCT ON", "SKYLINE OF"};
  
  static void extractRemainingColumns(List *common_colnames,
  						List *src_colnames, List *src_colvars,
***************
*** 1186,1191 ****
--- 1188,1197 ----
  		char	   *name = strVal(linitial(((ColumnRef *) node)->fields));
  		int			location = ((ColumnRef *) node)->location;
  
+ 		/*
+ 		 * FIXME: should SKYLINE be treated like GROUP?  || clause ==
+ 		 * SKYLINE_CLAUSE
+ 		 */
  		if (clause == GROUP_CLAUSE)
  		{
  			/*
***************
*** 1425,1430 ****
--- 1431,1482 ----
  }
  
  /*
+  * transformSkylineClause
+  *
+  * FIXME
+  */
+ Node *
+ transformSkylineClause(ParseState *pstate,
+ 					   Node *skylineOfClause,
+ 					   List **targetlist,
+ 					   bool resolveUnknown)
+ {
+ 	if (skylineOfClause == NULL)
+ 		return NULL;
+ 
+ 	{
+ 		SkylineOfClause *sbc = (SkylineOfClause *) skylineOfClause;
+ 		List	   *resultlist = NIL;
+ 		ListCell   *slitem;
+ 		List	   *skylinelist = sbc->skyline_of_list;
+ 		SkylineClause *node = makeNode(SkylineClause);
+ 
+ 		foreach(slitem, skylinelist)
+ 		{
+ 			SkylineOfExpr *skylineof = lfirst(slitem);
+ 			TargetEntry *tle;
+ 
+ 			tle = findTargetlistEntry(pstate, skylineof->node,
+ 									  targetlist, SKYLINE_CLAUSE);
+ 
+ 			resultlist = addTargetToSkylineList(pstate, tle,
+ 												resultlist, *targetlist,
+ 												skylineof->skylineof_dir,
+ 												skylineof->skylineof_nulls,
+ 												skylineof->useOp,
+ 												resolveUnknown);
+ 		}
+ 
+ 		node->skyline_distinct = sbc->skyline_distinct;
+ 		node->skyline_of_list = resultlist;
+ 		node->skyline_of_options = sbc->skyline_of_options;
+ 
+ 		return (Node *) node;
+ 	}
+ }
+ 
+ 
+ /*
   * transformSortClause -
   *	  transform an ORDER BY clause
   *
***************
*** 1718,1723 ****
--- 1770,1877 ----
  }
  
  /*
+  * addTargetToSkylineList
+  *
+  * FIXME
+  */
+ List *
+ addTargetToSkylineList(ParseState *pstate, TargetEntry *tle,
+ 					   List *skylinelist, List *targetlist,
+ 					   SkylineOfDir skylineof_dir, SkylineOfNulls skylineof_nulls,
+ 					   List *skylineof_opname, bool resolveUnknown)
+ {
+ 	Oid			restype = exprType((Node *) tle->expr);
+ 	Oid			skylineop;
+ 	Oid			cmpfunc;
+ 	bool		reverse;
+ 
+ 	/* if tlist item is an UNKNOWN literal, change it to TEXT */
+ 	if (restype == UNKNOWNOID && resolveUnknown)
+ 	{
+ 		tle->expr = (Expr *) coerce_type(pstate, (Node *) tle->expr,
+ 										 restype, TEXTOID, -1,
+ 										 COERCION_IMPLICIT,
+ 										 COERCE_IMPLICIT_CAST);
+ 		restype = TEXTOID;
+ 	}
+ 
+ 	/* determine the sortop */
+ 	switch (skylineof_dir)
+ 	{
+ 		case SKYLINEOF_DEFAULT:
+ 		case SKYLINEOF_MIN:
+ 		case SKYLINEOF_DIFF:
+ 			/* skyline diff must be treated special later */
+ 			skylineop = ordering_oper_opid(restype);
+ 			reverse = false;
+ 			break;
+ 		case SKYLINEOF_MAX:
+ 			skylineop = reverse_ordering_oper_opid(restype);
+ 			reverse = true;
+ 			break;
+ 		case SKYLINEOF_USING:
+ 			Assert(skylineof_opname != NIL);
+ 			skylineop = compatible_oper_opid(skylineof_opname,
+ 											 restype,
+ 											 restype,
+ 											 false);
+ 
+ 			/*
+ 			 * Verify it's a valid ordering operator, and determine whether to
+ 			 * consider it like ASC or DESC.
+ 			 */
+ 			if (!get_compare_function_for_ordering_op(skylineop,
+ 													  &cmpfunc, &reverse))
+ 				ereport(ERROR,
+ 						(errcode(ERRCODE_WRONG_OBJECT_TYPE),
+ 					   errmsg("operator %s is not a valid ordering operator",
+ 							  strVal(llast(skylineof_opname))),
+ 						 errhint("Ordering operators must be \"<\" or \">\" members of btree operator families.")));
+ 
+ 			break;
+ 		default:
+ 			elog(ERROR, "unrecognized skylineof_dir: %d", skylineof_dir);
+ 			skylineop = InvalidOid;		/* keep compiler quiet */
+ 			reverse = false;
+ 			break;
+ 	}
+ 
+ 	/* FIXME: avoid making duplicate skyline list entries */
+ 	if (!targetIsInSkylineList(tle, skylineop, skylinelist))
+ 	{
+ 		SkylineOf  *skylineof = makeNode(SkylineOf);
+ 		Oid			targetType = FLOAT8OID;
+ 
+ 		skylineof->tleSortGroupRef = assignSortGroupRef(tle, targetlist);
+ 		skylineof->restype = restype;
+ 		skylineof->skylineop = skylineop;
+ 		skylineof->skylineof_dir = skylineof_dir;
+ 
+ 		switch (skylineof_nulls)
+ 		{
+ 			case SKYLINEOF_NULLS_DEFAULT:
+ 				/* NULLS FIRST is default for DESC; other way for ASC */
+ 				skylineof->nulls_first = reverse;
+ 				break;
+ 			case SKYLINEOF_NULLS_FIRST:
+ 				skylineof->nulls_first = true;
+ 				break;
+ 			case SKYLINEOF_NULLS_LAST:
+ 				skylineof->nulls_first = false;
+ 				break;
+ 			default:
+ 				elog(ERROR, "unrecognized skylineof_nulls: %d", skylineof_nulls);
+ 				break;
+ 		}
+ 
+ 		skylinelist = lappend(skylinelist, skylineof);
+ 	}
+ 
+ 	return skylinelist;
+ }
+ 
+ 
+ /*
   * assignSortGroupRef
   *	  Assign the targetentry an unused ressortgroupref, if it doesn't
   *	  already have one.  Return the assigned or pre-existing refnumber.
***************
*** 1786,1788 ****
--- 1940,1970 ----
  	}
  	return false;
  }
+ 
+ /*
+  * targetIsInSkylineList
+  *
+  *	FIXME
+  */
+ bool
+ targetIsInSkylineList(TargetEntry *tle, Oid skylineop, List *skylineList)
+ {
+ 	Index		ref = tle->ressortgroupref;
+ 	ListCell   *l;
+ 
+ 	/* no need to scan list if tle has no marker */
+ 	if (ref == 0)
+ 		return false;
+ 
+ 	foreach(l, skylineList)
+ 	{
+ 		SkylineOf *skylineof = (SkylineOf *) lfirst(l);
+ 
+ 		if (skylineof->tleSortGroupRef == ref &&
+ 			(skylineop == InvalidOid ||
+ 			 skylineop == skylineof->skylineop ||
+ 			 skylineop == get_commutator(skylineof->skylineop)))
+ 			return true;
+ 	}
+ 	return false;
+ }
diff -cr --new-file -b --tabsize 4 -x CVS -x .svn -x tools pgsql-REL8_3_STABLE/src/backend/utils/Makefile pgsql/src/backend/utils/Makefile
*** pgsql-REL8_3_STABLE/src/backend/utils/Makefile	Fri Feb  9 16:55:58 2007
--- pgsql/src/backend/utils/Makefile	Wed Sep 19 23:46:44 2007
***************
*** 8,14 ****
  top_builddir = ../../..
  include $(top_builddir)/src/Makefile.global
  
! SUBDIRS     = adt cache error fmgr hash init mb misc mmgr resowner sort time
  SUBDIROBJS  = $(SUBDIRS:%=%/SUBSYS.o)
  
  
--- 8,14 ----
  top_builddir = ../../..
  include $(top_builddir)/src/Makefile.global
  
! SUBDIRS     = adt cache error fmgr hash init mb misc mmgr resowner skyline sort time
  SUBDIROBJS  = $(SUBDIRS:%=%/SUBSYS.o)
  
  
diff -cr --new-file -b --tabsize 4 -x CVS -x .svn -x tools pgsql-REL8_3_STABLE/src/backend/utils/adt/selfuncs.c pgsql/src/backend/utils/adt/selfuncs.c
*** pgsql-REL8_3_STABLE/src/backend/utils/adt/selfuncs.c	Mon Jul  7 22:25:06 2008
--- pgsql/src/backend/utils/adt/selfuncs.c	Wed Nov 12 00:08:45 2008
***************
*** 128,135 ****
  							int rangelo, int rangehi);
  static char *convert_string_datum(Datum value, Oid typid);
  static double convert_timevalue_to_scalar(Datum value, Oid typid);
- static bool get_variable_range(PlannerInfo *root, VariableStatData *vardata,
- 					 Oid sortop, Datum *min, Datum *max);
  static Selectivity prefix_selectivity(VariableStatData *vardata,
  				   Oid vartype, Oid opfamily, Const *prefixcon);
  static Selectivity pattern_selectivity(Const *patt, Pattern_Type ptype);
--- 128,133 ----
***************
*** 3961,3967 ****
   * sortop is the "<" comparison operator to use.  This should generally
   * be "<" not ">", as only the former is likely to be found in pg_statistic.
   */
! static bool
  get_variable_range(PlannerInfo *root, VariableStatData *vardata, Oid sortop,
  				   Datum *min, Datum *max)
  {
--- 3959,3965 ----
   * sortop is the "<" comparison operator to use.  This should generally
   * be "<" not ">", as only the former is likely to be found in pg_statistic.
   */
! bool
  get_variable_range(PlannerInfo *root, VariableStatData *vardata, Oid sortop,
  				   Datum *min, Datum *max)
  {
diff -cr --new-file -b --tabsize 4 -x CVS -x .svn -x tools pgsql-REL8_3_STABLE/src/backend/utils/skyline/Makefile pgsql/src/backend/utils/skyline/Makefile
*** pgsql-REL8_3_STABLE/src/backend/utils/skyline/Makefile	Thu Jan  1 01:00:00 1970
--- pgsql/src/backend/utils/skyline/Makefile	Mon Nov 19 11:07:52 2007
***************
*** 0 ****
--- 1,23 ----
+ #-------------------------------------------------------------------------
+ #
+ # Makefile--
+ #    Makefile for utils/skyline
+ #
+ # IDENTIFICATION
+ #    $PostgreSQL: $
+ #
+ #-------------------------------------------------------------------------
+ 
+ subdir = src/backend/utils/skyline
+ top_builddir = ../../../..
+ include $(top_builddir)/src/Makefile.global
+ 
+ OBJS = skyline.o tuplewindow.o
+ 
+ all: SUBSYS.o
+ 
+ SUBSYS.o: $(OBJS)
+ 	$(LD) $(LDREL) $(LDOUT) SUBSYS.o $(OBJS)
+ 
+ clean: 
+ 	rm -f SUBSYS.o $(OBJS)
diff -cr --new-file -b --tabsize 4 -x CVS -x .svn -x tools pgsql-REL8_3_STABLE/src/backend/utils/skyline/skyline.c pgsql/src/backend/utils/skyline/skyline.c
*** pgsql-REL8_3_STABLE/src/backend/utils/skyline/skyline.c	Thu Jan  1 01:00:00 1970
--- pgsql/src/backend/utils/skyline/skyline.c	Tue Nov 11 21:15:24 2008
***************
*** 0 ****
--- 1,463 ----
+ /*-------------------------------------------------------------------------
+  *
+  * skyline.c
+  *		SKYLINE OF-clause support functions.
+  *
+  *
+  * Portions Copyright (c) 2008, PostgreSQL Global Development Group
+  * Portions Copyright (c) 2007-2008, Hannes Eder
+  *
+  *
+  * DESCRIPTION
+  *	  FIXME
+  *
+  * IDENTIFICATION
+  *	  $PostgreSQL: $
+  *
+  *-------------------------------------------------------------------------
+  */
+ 
+ #include "postgres.h"
+ 
+ #include "utils/skyline.h"
+ 
+ typedef enum
+ {
+ 	SOT_UNKNOWN,
+ 	SOT_METHOD,
+ 	SOT_PARAM
+ } SkylineOptionType;
+ 
+ typedef struct
+ {
+ 	const char		   *name;
+ 	SkylineOptionType	option_type;
+ 	SkylineMethod		skyline_method;
+ } SkylineAnOption;
+ 
+ /* NOTE: keep this list sorted, we are using bsearch */
+ static SkylineAnOption
+ skyline_options[] = {
+ 	{ "blocknestedloop"			, SOT_METHOD, SM_BLOCKNESTEDLOOP },
+ 	{ "bnl"						, SOT_METHOD, SM_BLOCKNESTEDLOOP } ,
+ 	{ "ef"						, SOT_PARAM , SM_UNKNOWN },
+ 	{ "efslots"					, SOT_PARAM , SM_UNKNOWN },
+ 	{ "efwindow"				, SOT_PARAM , SM_UNKNOWN },
+ 	{ "efwindowpolicy"			, SOT_PARAM	, SM_UNKNOWN },
+ 	{ "efwindowsize"			, SOT_PARAM , SM_UNKNOWN },
+ 	{ "efwindowslots"			, SOT_PARAM , SM_UNKNOWN },
+ /*
+  * "elimfilter" can not be selected as method on its own, it is the
+  * method used for elimination filter nodes.
+  */
+ /*  { "elimfilter"				, SOT_METHOD, SM_ELIMFILTER }, */ 
+ 	{ "materializednestedloop"	, SOT_METHOD, SM_MATERIALIZEDNESTEDLOOP },
+ 	{ "mnl"						, SOT_METHOD, SM_MATERIALIZEDNESTEDLOOP },
+ 	{ "noindex"					, SOT_PARAM	, SM_UNKNOWN },
+ 	{ "presort"					, SOT_METHOD, SM_2DIM_PRESORT },
+ 	{ "ps"						, SOT_METHOD, SM_2DIM_PRESORT },
+ 	{ "sfs"						, SOT_METHOD, SM_SFS },
+ 	{ "slots"					, SOT_PARAM	, SM_UNKNOWN },
+ 	{ "window"					, SOT_PARAM	, SM_UNKNOWN },
+ 	{ "windowpolicy"			, SOT_PARAM , SM_UNKNOWN },
+ 	{ "windowsize"				, SOT_PARAM	, SM_UNKNOWN },
+ 	{ "windowslots"				, SOT_PARAM	, SM_UNKNOWN },
+ };
+ 
+ static int
+ cmp_skyline_option(const void *m1, const void *m2)
+ {
+ 	return strcmp(((SkylineAnOption *) m1)->name, ((SkylineAnOption *) m2)->name);
+ }
+ 
+ static SkylineAnOption *
+ skyline_lookup_option(const char *name)
+ {
+ 	SkylineAnOption key;
+ 
+ 	Assert(name != NULL);
+ 	Assert(strlen(name) > 0);
+ 
+ 	key.name = name;
+ 	return (SkylineAnOption *) bsearch(&key, skyline_options, lengthof(skyline_options), sizeof(skyline_options[0]), cmp_skyline_option);
+ }
+ 
+ /*
+  * skyline_option_get_int
+  *
+  *	Query the SKYLINE OF ... WITH param=xxx list for the param `name' with
+  *  data type T_Integer
+  *	returns true if value is present.
+  */
+ bool
+ skyline_option_get_int(List *skyline_of_options, char *name, int *value)
+ {
+ 	ListCell   *l;
+ 
+ 	AssertArg(name != NULL);
+ 	AssertArg(value != NULL);
+ 
+ 	/* ensure we only lookup known options */
+ 	Assert(skyline_lookup_option(name) != NULL);
+ 
+ 	foreach(l, skyline_of_options)
+ 	{
+ 		SkylineOption *option = (SkylineOption *) lfirst(l);
+ 
+ 		if (strcmp(option->name, name) == 0)
+ 		{
+ 			A_Const    *arg = (A_Const *) option->value;
+ 
+ 			if (!IsA(arg, A_Const))
+ 				elog(ERROR, "unrecognized node type: %d", (int) nodeTag(arg));
+ 
+ 			switch (nodeTag(&arg->val))
+ 			{
+ 				case T_Integer:
+ 					*value = intVal(&arg->val);
+ 					return true;
+ 
+ 				default:
+ 					elog(ERROR, "only integer for option `%s' allowed", name);
+ 					return false;
+ 			}
+ 		}
+ 	}
+ 
+ 	return false;
+ }
+ 
+ /*
+  * skyline_option_get_string
+  *
+  *  Query the SKYLINE OF ... WITH param=xxx list for the param `name' with
+  *  data type T_String
+  *  returns true if value is present.
+  */
+ bool
+ skyline_option_get_string(List *skyline_of_options, char *name, char **value)
+ {
+ 	ListCell   *l;
+ 
+ 	AssertArg(name != NULL);
+ 	AssertArg(value != NULL);
+ 
+ 	/* ensure we only lookup known options */
+ 	Assert(skyline_lookup_option(name) != NULL);
+ 
+ 	foreach(l, skyline_of_options)
+ 	{
+ 		SkylineOption *option = (SkylineOption *) lfirst(l);
+ 
+ 		if (strcmp(option->name, name) == 0)
+ 		{
+ 			A_Const    *arg = (A_Const *) option->value;
+ 
+ 			if (!IsA(arg, A_Const))
+ 				elog(ERROR, "unrecognized node type: %d", (int) nodeTag(arg));
+ 
+ 			switch (nodeTag(&arg->val))
+ 			{
+ 				case T_String:
+ 					*value = strVal(&arg->val);
+ 					return true;
+ 
+ 				default:
+ 					elog(ERROR, "only strings for option `%s' allowed", name);
+ 					return false;
+ 			}
+ 		}
+ 	}
+ 
+ 	return false;
+ }
+ 
+ /*
+  * skyline_option_window_policy
+  *
+  *	Query the SKYLINE OF ... WITH param=xxx list for the param `name' with
+  *  data type T_String, return it as "window policy"
+  *	returns true if value is present.
+  */
+ bool
+ skyline_option_get_window_policy(List *skyline_of_options, char *name, TupleWindowPolicy *window_policy)
+ {
+ 	char	   *window_policy_name;
+ 
+ 	if (skyline_option_get_string(skyline_of_options, name, &window_policy_name))
+ 	{
+ 		if (strcmp(window_policy_name, "append") == 0)
+ 			*window_policy = TUP_WIN_POLICY_APPEND;
+ 		else if (strcmp(window_policy_name, "prepend") == 0)
+ 			*window_policy = TUP_WIN_POLICY_PREPEND;
+ 		else if (strcmp(window_policy_name, "entropy") == 0)
+ 			*window_policy = TUP_WIN_POLICY_ENTROPY;
+ 		else if (strcmp(window_policy_name, "random") == 0)
+ 			*window_policy = TUP_WIN_POLICY_RANDOM;
+ 		else
+ 			ereport(ERROR,
+ 				(errcode(ERRCODE_SYNTAX_ERROR),
+ 				 errmsg("unsupported value for \"%s\" \"%s\"",
+ 						name, window_policy_name),
+ 				 errhint("Use \"append\", \"prepend\" or \"entropy\"=\"ranked\".")));
+ 			/* note that ereport(ERROR, ...) does not return */
+ 
+ 		return true;
+ 	}
+ 	else
+ 		return false;
+ }
+ 
+ /*
+  * skyline_window_policy_name
+  *
+  *  FIXME
+  */
+ const char *
+ skyline_window_policy_name(TupleWindowPolicy window_policy)
+ {
+ 	switch (window_policy)
+ 	{
+ 	case TUP_WIN_POLICY_APPEND:
+ 		return "append";
+ 	case TUP_WIN_POLICY_PREPEND:
+ 		return "prepend";
+ 	case TUP_WIN_POLICY_ENTROPY:
+ 		return "entropy";
+ 	case TUP_WIN_POLICY_RANDOM:
+ 		return "random";
+ 	default:
+ 		elog(WARNING, "FIXME: skyline window policy `%d' unknown at %s:%d", window_policy, __FILE__, __LINE__);
+ 		return "?";
+ 	}
+ }
+ 
+ SkylineMethod
+ skyline_method_forced_by_options(SkylineClause *skyline_clause)
+ {
+ 	SkylineMethod skyline_method = SM_UNKNOWN;
+ 
+ 	ListCell   *l;
+ 
+ 	foreach(l, skyline_clause->skyline_of_options)
+ 	{
+ 		SkylineOption *option = (SkylineOption *) lfirst(l);
+ 		SkylineAnOption *anoption = skyline_lookup_option(option->name);
+ 
+ 		if (anoption != NULL)
+ 		{
+ 			if (anoption->option_type == SOT_METHOD)
+ 			{
+ 				if (skyline_method != SM_UNKNOWN)
+ 				{
+ 					if (skyline_method == anoption->skyline_method)
+ 						elog(WARNING, "skyline method `%s' specified more than once", option->name);
+ 					else
+ 						elog(WARNING, "previous skyline method overwritten, now using `%s' for SKYLINE OF", option->name);
+ 				}
+ 
+ 				skyline_method = anoption->skyline_method;
+ 			}
+ 			else
+ 			{
+ 				/* ignore them here, they are used in the executor */
+ 			}
+ 		}
+ 		else
+ 		{
+ 			elog(WARNING, "unknown option `%s' for SKYLINE OF", option->name);
+ 		}
+ 	}
+ 
+ 	return skyline_method;
+ }
+ 
+ int
+ skyline_get_dim(SkylineClause *skyline_clause)
+ {
+ 	if (skyline_clause == NULL)
+ 		return 0;
+ 	else
+ 		return list_length(skyline_clause->skyline_of_list);
+ }
+ 
+ SkylineMethod
+ skyline_choose_method(SkylineClause *skyline_clause, bool has_matching_path)
+ {
+ 	SkylineMethod skyline_method = SM_UNKNOWN;
+ 	int			skyline_dim = skyline_get_dim(skyline_clause);
+ 
+ 	skyline_method = skyline_method_forced_by_options(skyline_clause);
+ 
+ 	if (skyline_method == SM_UNKNOWN)
+ 	{
+ 		/* use a default */
+ 		if (skyline_dim == 1 && !skyline_clause->skyline_distinct)
+ 			skyline_method = SM_1DIM;
+ 		else if (skyline_dim == 1 && skyline_clause->skyline_distinct)
+ 			skyline_method = SM_1DIM_DISTINCT;
+ 		else if (skyline_dim == 2 && has_matching_path)
+ 			skyline_method = SM_2DIM_PRESORT;
+ 		else if (skyline_dim >= 2 && has_matching_path)
+ 			skyline_method = SM_SFS;
+ 		else
+ 			skyline_method = SM_BLOCKNESTEDLOOP;
+ 	}
+ 
+ 	/* performe some sanity checks */
+ 	if (skyline_method == SM_2DIM_PRESORT && skyline_dim > 2)
+ 		elog(ERROR, "skyline method `2d with presort' only works for <= 2 skyline dimensions");
+ 
+ 	if (skyline_dim == 1 && !skyline_clause->skyline_distinct && skyline_method != SM_1DIM)
+ 		elog(WARNING, "for 1d skyline the default method is superior");
+ 	else if (skyline_dim == 1 && skyline_clause->skyline_distinct && skyline_method != SM_1DIM_DISTINCT)
+ 		elog(WARNING, "for 1d skyline the default method is superior");
+ 
+ 	Assert(skyline_method != SM_UNKNOWN);
+ 	return skyline_method;
+ }
+ 
+ /*
+  * This function is used to decide in the planner of the current_paths can be kept
+  *
+  * FIXME: this can't be used if entropy is used
+  */
+ bool
+ skyline_method_preserves_tuple_order(SkylineMethod skyline_method)
+ {
+ 	switch (skyline_method)
+ 	{
+ 		case SM_1DIM:
+ 		case SM_1DIM_DISTINCT:
+ 		case SM_MATERIALIZEDNESTEDLOOP:
+ 			/*
+ 			 * These methods preserve the relative order of the tuples, so
+ 			 * e.g. we may keep the current_pathkeys in the grouping_planner.
+ 			 */
+ 			return true;
+ 		case SM_2DIM_PRESORT:
+ 			/*
+ 			 * 2d with presort may overall change the order of the tuples but
+ 			 * the filtering step of this methodes preserved them and we are
+ 			 * using an extra sort plan node, so this pathkey can be usind by
+ 			 * an eventually following sort plan node
+ 			 */
+ 			return true;
+ 		case SM_BLOCKNESTEDLOOP:
+ 			/*
+ 			 * Block nested loop eventually changes the order of the tuples so
+ 			 * we must drop the current_pathkeys this is still true even if
+ 			 * the relative order in the tuple window is preserved.
+ 			 */
+ 			return false;
+ 		case SM_SFS:
+ 			/*
+ 			 * The order of the tuples is not changed by the Sort Filter
+ 			 * Skyline method, so the current_pathkeys can be kept.
+ 			 */
+ 
+ 			/*
+ 			 * No matter what tuple window policy is used the relative order
+ 			 * is preserved by SFS, as tuple come in are checked against the
+ 			 * tuple window and either dropped or if not dominated then
+ 			 * either directly returned or written to a temp file in the
+ 			 * same order.
+ 			 */
+ 			return true;
+ 		case SM_ELIMFILTER:
+ 			/* 
+ 			 * No matter what tuple window policy is used by the elimination
+ 			 * filter, the relative tuple order is preserved, as the tuple 
+ 			 * is read, compared against the tuples in then window, if it
+ 			 * survives this test, it is passed on.
+ 			 */
+ 			return true;
+ 		default:
+ 			/* 
+ 			 * We drop it on default.
+ 			 */
+ 			elog(WARNING, "FIXME: skyline method `%d' unknown at %s:%d", skyline_method, __FILE__, __LINE__);
+ 			return false;
+ 	}
+ }
+ 
+ 
+ const char *
+ skyline_method_name(SkylineMethod skyline_method)
+ {
+ 	switch (skyline_method)
+ 	{
+ 		case SM_UNKNOWN:
+ 			return "unknown";
+ 		case SM_1DIM:
+ 			return "1dim";
+ 		case SM_1DIM_DISTINCT:
+ 			/*
+ 			 * The term "distinct" should be added by the caller, since 
+ 			 * other all methods can handle distinct as well.
+ 			 */
+ 			return "1dim";		
+ 		case SM_2DIM_PRESORT:
+ 			return "presort";
+ 		case SM_MATERIALIZEDNESTEDLOOP:
+ 			return "mnl";
+ 		case SM_BLOCKNESTEDLOOP:
+ 			return "bnl";
+ 		case SM_SFS:
+ 			return "sfs";
+ 		case SM_ELIMFILTER:
+ 			return "elimfilter";
+ 		default:
+ 			return "?";
+ 	}
+ }
+ 
+ /*
+  * skyline_methode_can_use_limit
+  *	 Do we have to process all outer at least once tuples befor we
+  *	 can return some?
+  */
+ bool
+ skyline_methode_can_use_limit(SkylineMethod skyline_method)
+ {
+ 	switch (skyline_method)
+ 	{
+ 		case SM_UNKNOWN:
+ 		case SM_1DIM:
+ 		case SM_1DIM_DISTINCT:
+ 			/* We have to read them all. */
+ 		case SM_BLOCKNESTEDLOOP:
+ 			/*
+ 			 * We have to read them all at least once befor we can be sure
+ 			 * that the first tuple survived.
+ 			 */
+ 			return false;
+ 
+ 		case SM_MATERIALIZEDNESTEDLOOP:
+ 			/*
+ 			 * We are cheating here, since the for every tuple the entire
+ 			 * outerplan is read, but once it survived this we can return it.
+ 			 */
+ 		case SM_2DIM_PRESORT:
+ 			/*
+ 			 * If it's not dominated by the current we can return it and make
+ 			 * it the new current.
+ 			 */
+ 		case SM_SFS:
+ 			/*
+ 			 * We can return a tuple if it is not dominated by one in the
+ 			 * tuple window.
+ 			 */
+ 			return true;
+ 
+ 		case SM_ELIMFILTER:
+ 			/*
+ 			 * FIXME: comment this?
+ 			 */
+ 			return true;
+ 
+ 		default:
+ 			elog(WARNING, "FIXME: skyline method `%d' unknown at %s:%d", skyline_method, __FILE__, __LINE__);
+ 			return false;
+ 	}
+ }
diff -cr --new-file -b --tabsize 4 -x CVS -x .svn -x tools pgsql-REL8_3_STABLE/src/backend/utils/skyline/tuplewindow.c pgsql/src/backend/utils/skyline/tuplewindow.c
*** pgsql-REL8_3_STABLE/src/backend/utils/skyline/tuplewindow.c	Thu Jan  1 01:00:00 1970
--- pgsql/src/backend/utils/skyline/tuplewindow.c	Tue Nov 11 22:13:00 2008
***************
*** 0 ****
--- 1,554 ----
+ /*-------------------------------------------------------------------------
+  *
+  * tuplewindow.c
+  *    Routines to maintain a tuplewindow, used for skyline nodes.
+  *    see: executor/nodeSkyline.c
+  *
+  * Portions Copyright (c) 2008, PostgreSQL Global Development Group
+  * Portions Copyright (c) 2007-2008, Hannes Eder
+  *
+  *
+  * DESCRIPTION
+  *    We are using a double linked list with a sentinel.
+  *
+  *    For double linked list with sentinel see: [COR2002, Ch. 10.2, p 204--209]
+  *    [COR2002] Cormen, Thomas H., Introduction to Algorithms,
+  *    Second Edition, Third printing 2002, MIT Press, ISBN 0-262-03293-7
+  *
+  * IDENTIFICATION
+  *	  $PostgreSQL: $
+  *
+  *-------------------------------------------------------------------------
+  */
+ 
+ #include "postgres.h"
+ 
+ #include <float.h>
+ 
+ #include "utils/tuplewindow.h"
+ #include "utils/memutils.h"
+ 
+ /* FIXME: This is from tuplestore.c and could be factored out. */
+ #define LACKMEM(state)		((state)->availMem < 0)
+ #define USEMEM(state,amt)	((state)->availMem -= (amt))
+ #define FREEMEM(state,amt)	((state)->availMem += (amt))
+ 
+ typedef struct TupleWindowSlot
+ {
+ 	void	   *tuple;
+ 	int64		timestamp;
+ 	double		rank;
+ 	struct TupleWindowSlot *next;
+ 	struct TupleWindowSlot *prev;
+ } TupleWindowSlot;
+ 
+ struct TupleWindowState
+ {
+ 	long		availMem;
+ 	int			availSlots;		/* if -1 only restrict mem */
+ 
+ 	int			maxKBytes;
+ 	int			maxSlots;
+ 
+ 	TupleWindowPolicy	policy;
+ 
+ 	TupleWindowSlot *nil;
+ 	TupleWindowSlot *current;
+ 
+ 	double		insertrank;
+ 	TupleWindowSlot *rankinsert;
+ };
+ 
+ /* forward decl's */
+ static void tuplewindow_puttupleslot_impl(TupleWindowState *state, TupleTableSlot *slot, int64 timestamp, TupleWindowSlot *insertbefore, double rank);
+ 
+ /*
+  * tuplewindow_begin
+  *
+  *	Initialize a tuplewindow. If maxSlots is unequal to -1 then the tuple-
+  *	window is only restricted by the number of slots, memory is not
+  *	considered in that case. If maxSlots is equal to -1 maxKBytes is the
+  *	limiting factor.
+  */
+ TupleWindowState *
+ tuplewindow_begin(int maxKBytes, int maxSlots, TupleWindowPolicy policy)
+ {
+ 	TupleWindowState *state;
+ 
+ 	state = (TupleWindowState *) palloc0(sizeof(TupleWindowState));
+ 
+ 	state->maxKBytes = maxKBytes;
+ 	state->maxSlots = maxSlots;
+ 
+ 	state->availMem = maxKBytes * 1024L;
+ 	state->availSlots = maxSlots;
+ 
+ 	/*
+ 	 * NOTE: currently only these policies are suppored
+ 	 */
+ 	AssertArg(   (policy == TUP_WIN_POLICY_APPEND)
+ 			  || (policy == TUP_WIN_POLICY_PREPEND)
+ 		      || (policy == TUP_WIN_POLICY_ENTROPY)
+ 			  || (policy == TUP_WIN_POLICY_RANDOM)
+ 			  );
+ 
+ 	state->policy = policy;
+ 
+ 	/*
+ 	 * Create sentinel, we don't count this memory usage.
+ 	 */
+ 	state->nil = (TupleWindowSlot *) palloc(sizeof(TupleWindowSlot));
+ 	state->nil->next = state->nil;
+ 	state->nil->prev = state->nil;
+ 	state->nil->tuple = NULL;
+ 	state->nil->timestamp = 0;
+ 	state->nil->rank = DBL_MAX;
+ 
+ 	/*
+ 	 * Set cursor (current) to sentinel.
+ 	 */
+ 	state->current = state->nil;
+ 
+ 	/*
+ 	 * Set rank cursor
+ 	 */
+ 	state->insertrank = -DBL_MAX;
+ 	state->rankinsert = state->nil;
+ 
+ 	return state;
+ }
+ 
+ /*
+  * tuplewindow_has_freespace
+  *
+  *	Returns true, if the tuple window is large enough to store at least
+  *	one more tuple.
+  */
+ bool
+ tuplewindow_has_freespace(TupleWindowState *state)
+ {
+ 	if (state->availSlots != -1)
+ 		return (state->availSlots > 0);
+ 	else
+ 		return !LACKMEM(state);
+ }
+ 
+ /*
+  * tuplewindow_removeslot
+  *
+  *	Helper for tuplewindow_removecurrent.
+  */
+ static void
+ tuplewindow_removeslot(TupleWindowState *state,
+ 					   TupleWindowSlot *slot,
+ 					   bool freetuple)
+ {
+ 	TupleWindowSlot *next;
+ 
+ 	AssertArg(state != NULL);
+ 	AssertArg(slot != NULL);
+ 	Assert(slot != state->nil);
+ 
+ 	next = slot->next;
+ 
+ 	/* remove from linked list */
+ 	slot->prev->next = slot->next;
+ 	slot->next->prev = slot->prev;
+ 
+ 	/* invalidate slot, in production code this is not needed */
+ 	slot->prev = NULL;
+ 	slot->next = NULL;
+ 
+ 	/*
+ 	 * HACK: We reclame the space here, because ExecStoreMinimalTuple called
+ 	 * with true, so it will free the tuple later.
+ 	 */
+ 	FREEMEM(state, GetMemoryChunkSpace(slot->tuple));
+ 	if (freetuple)
+ 	{
+ 		pfree(slot->tuple);
+ 	}
+ 
+ 	FREEMEM(state, GetMemoryChunkSpace(slot));
+ 	pfree(slot);
+ 
+ 	if (state->availSlots != -1)
+ 	{
+ 		/*
+ 		 * If we are restricting the slots, then one more becomes available
+ 		 * here.
+ 		 */
+ 		state->availSlots++;
+ 	}
+ 
+ 	/*
+ 	 * NOTE: If we are removing the current slot, reposition the cursor
+ 	 * (current) to the next slot. So don't call tuplewindow_movenext in that
+ 	 * case.
+ 	 */
+ 	if (state->current == slot)
+ 		state->current = next;
+ 
+ 	if (state->rankinsert == slot)
+ 		state->rankinsert = next;
+ }
+ 
+ /*
+  * tuplewindow_rewind
+  *
+  *	Resets the cursor (current) to the first tuple in the window.
+  */
+ void
+ tuplewindow_rewind(TupleWindowState *state)
+ {
+ 	AssertArg(state != NULL);
+ 
+ 	state->current = state->nil->next;
+ 	state->rankinsert = state->nil->next;
+ }
+ 
+ /*
+  * tuplewindow_ateof
+  *
+  *	Returns true if the cursor (current) is at the end of the tuplewindow.
+  */
+ bool
+ tuplewindow_ateof(TupleWindowState *state)
+ {
+ 	AssertArg(state != NULL);
+ 
+ 	return (state->current == state->nil);
+ }
+ 
+ /*
+  * tuplewindow_movenext
+  *
+  *	Move the cursor (current) to the next slot, also so
+  *	tuplewindow_removecurrent, which also advances the
+  *	cursor. Use tuplewindow_rewind to reset the cursor to
+  *	the beginning.
+  */
+ void
+ tuplewindow_movenext(TupleWindowState *state)
+ {
+ 	AssertArg(state != NULL);
+ 
+ 	if (state->current != state->nil)
+ 	{
+ 		if ((state->policy == TUP_WIN_POLICY_ENTROPY 
+ 			|| state->policy == TUP_WIN_POLICY_RANDOM
+ 			)
+ 			&& state->current == state->rankinsert)
+ 		{
+ 			if (state->current->rank >= state->insertrank)
+ 				state->rankinsert = state->current->next;
+ 		}
+ 
+ 		state->current = state->current->next;
+ 	}
+ }
+ 
+ /*
+  * tuplewindow_timestampcurrent
+  *
+  *	Returns the timestamp of the current tuple.
+  */
+ int64
+ tuplewindow_timestampcurrent(TupleWindowState *state)
+ {
+ 	AssertArg(state != NULL);
+ 	Assert(state->current != NULL);
+ 	Assert(state->current != state->nil);
+ 
+ 	return state->current->timestamp;
+ }
+ 
+ /*
+  * tuplewindow_gettupleslot
+  *
+  *	FIXME
+  */
+ bool
+ tuplewindow_gettupleslot(TupleWindowState *state,
+ 						 TupleTableSlot *slot,
+ 						 bool removeit)
+ {
+ 	AssertArg(state != NULL);
+ 	AssertArg(slot != NULL);
+ 
+ 	if (state->current != state->nil)
+ 	{
+ 		if (removeit)
+ 		{
+ 			/*
+ 			 * Remove the tuple from the tuple window, but don't free the the
+ 			 * tuple, let the ExecStoreMinimalTuple pfree it.
+ 			 */
+ 			ExecStoreMinimalTuple(state->current->tuple, slot, true);
+ 			tuplewindow_removeslot(state, state->current, false);
+ 		}
+ 		else
+ 		{
+ 			/* Leave the tuple in the window. */
+ 			ExecStoreMinimalTuple(state->current->tuple, slot, false);
+ 		}
+ 		return true;
+ 	}
+ 	else
+ 	{
+ 		ExecClearTuple(slot);
+ 		return false;
+ 	}
+ }
+ 
+ /*
+  * tuplewindow_removecurrent
+  *
+  *	Removes the current slot from the window and moves the
+  *	cursor (current) to the next slot. No extra call to tuplewindow_movenext
+  *	needed in that case.
+  */
+ void
+ tuplewindow_removecurrent(TupleWindowState *state)
+ {
+ 	AssertArg(state != NULL);
+ 	Assert(state->current != NULL);
+ 	Assert(state->current != state->nil);
+ 	tuplewindow_removeslot(state, state->current, true);
+ }
+ 
+ /*
+  * tuplewindow_clean
+  * 
+  *	Removes all tuple from the window. tuplewindow_removeall might be a
+  *	better name, but anyway it's a tuple*window* and windows are cleaned.
+  */
+ void
+ tuplewindow_clean(TupleWindowState *state)
+ {
+ 	TupleWindowSlot *slot;
+ 
+ 	AssertArg(state != NULL);
+ 
+ 	/*
+ 	 * Free all slots and the tuples in the slot.
+ 	 */
+ 	slot = state->nil->next;
+ 
+ 	while (slot != state->nil)
+ 	{
+ 		TupleWindowSlot *next = slot->next;
+ 
+ 		pfree(slot->tuple);
+ 		pfree(slot);
+ 		slot = next;
+ 	}
+ 
+ 	/*
+ 	 * Reset sentinel.
+ 	 */
+ 	state->nil->next = state->nil;
+ 	state->nil->prev = state->nil;
+ 
+ 	/*
+ 	 * Reset cursor (current) to sentinel.
+ 	 */
+ 	state->current = state->nil;
+ 
+ 	/*
+ 	 * We have free'd all slots and all tuples, so all the memory is
+ 	 * available again.
+ 	 */
+ 	state->availMem = state->maxKBytes * 1024L;
+ 	state->availSlots = state->maxSlots;
+ }
+ 
+ /*
+  * tuplewindow_end
+  *
+  *	Release resources and cleanup.
+  */
+ void
+ tuplewindow_end(TupleWindowState *state)
+ {
+ 	AssertArg(state != NULL);
+ 
+ 	/* free all slots */
+ 	tuplewindow_clean(state);
+ 
+ 	/* free the sentinel */
+ 	pfree(state->nil);
+ 
+ 	/* free the state buffer */
+ 	pfree(state);
+ }
+ 
+ /*
+  * tuplewindow_setinsertrank
+  *
+  * FIXME
+  */
+ void
+ tuplewindow_setinsertrank(TupleWindowState *state, double rank)
+ {
+ 	AssertArg(state != NULL);
+ 	
+ 	/*
+ 	 * Setting the rank is only useful when using a ranked policy
+ 	 */
+ 	AssertState(state->policy == TUP_WIN_POLICY_ENTROPY 
+ 				|| state->policy == TUP_WIN_POLICY_RANDOM);
+ 
+ 	/*
+ 	 * When setting the rank the cursor (current) has to be
+ 	 * rewinded
+ 	 */
+ 	AssertState(state->current == state->nil->next);
+ 
+ 	state->insertrank = rank;
+ }
+ 
+ /*
+  * tuplewindow_puttupleslot_impl
+  *
+  *	The workhorse for tuplewindow_puttupleslot.
+  */
+ static void
+ tuplewindow_puttupleslot_impl(TupleWindowState *state, TupleTableSlot *slot, int64 timestamp, TupleWindowSlot *insertbefore, double rank)
+ {
+ 	MinimalTuple tuple;
+ 	TupleWindowSlot *windowSlot;
+ 
+ 	AssertState(state != NULL);
+ 
+ 	/*
+ 	 * Form a MinimalTuple in working memory.
+ 	 */
+ 	tuple = ExecCopySlotMinimalTuple(slot);
+ 	USEMEM(state, GetMemoryChunkSpace(tuple));
+ 
+ 	windowSlot = (TupleWindowSlot *) palloc(sizeof(TupleWindowSlot));
+ 	USEMEM(state, GetMemoryChunkSpace(windowSlot));
+ 
+ 	if (state->availSlots != -1)
+ 	{
+ 		/*
+ 		 * If we are counting the slots, then at this point availSlots must be
+ 		 * > 0.
+ 		 */
+ 		AssertState(state->availSlots > 0);
+ 
+ 		state->availSlots--;
+ 	}
+ 
+ 	windowSlot->tuple = tuple;
+ 	windowSlot->timestamp = timestamp;
+ 	windowSlot->rank = rank;
+ 
+ 
+ 	insertbefore->prev->next = windowSlot;
+ 	windowSlot->prev = insertbefore->prev;
+ 	windowSlot->next = insertbefore;
+ 	insertbefore->prev = windowSlot;
+ }
+ 
+ /*
+  * tuplewindow_puttupleslot
+  *
+  *	Adds the tuple in slot to the tuplewindow.
+  *
+  *  FIXME: on a forced insert we could return the removed tuple to the caller
+  *  so it can be written to a temp file
+  */
+ void
+ tuplewindow_puttupleslot(TupleWindowState *state,
+ 						 TupleTableSlot *slot,
+ 						 int64 timestamp,
+ 						 bool forced)
+ {
+ 	AssertArg(state != NULL);
+ 	AssertArg(slot != NULL);
+ 
+ 	switch (state->policy)
+ 	{
+ 	case TUP_WIN_POLICY_APPEND:
+ 		if (forced)
+ 		{
+ 			/*
+ 			 * We only insert if there is still space in the window.
+ 			 */
+ 			if (tuplewindow_has_freespace(state))
+ 				tuplewindow_puttupleslot_impl(state, slot, timestamp, state->nil, -DBL_MAX);
+ 		}
+ 		else
+ 		{
+ 			/*
+ 			 * We insert at the end of the list, to preserve relative tuple order in
+ 			 * the tuple window.
+ 			 */
+ 			AssertState(tuplewindow_has_freespace(state));
+ 			tuplewindow_puttupleslot_impl(state, slot, timestamp, state->nil, -DBL_MAX);
+ 		}
+ 		break;
+ 
+ 	case TUP_WIN_POLICY_PREPEND:
+ 		if (forced)
+ 		{
+ 			/*
+ 			 * We only insert if there is still space in the window.
+ 			 */
+ 			if (tuplewindow_has_freespace(state))
+ 				tuplewindow_puttupleslot_impl(state, slot, timestamp, state->nil->next, -DBL_MAX);
+ 		}
+ 		else
+ 		{
+ 			/*
+ 			 * We insert at the begining of the list.
+ 			 */
+ 			AssertState(tuplewindow_has_freespace(state));
+ 			tuplewindow_puttupleslot_impl(state, slot, timestamp, state->nil->next, -DBL_MAX);
+ 		}
+ 		break;
+ 
+ 	case TUP_WIN_POLICY_ENTROPY:
+ 	case TUP_WIN_POLICY_RANDOM:
+ 		if (forced && !tuplewindow_has_freespace(state))
+ 		{
+ 			/*
+ 			 * remove the slot with the lowest ranking
+ 			 */
+ 			Assert(state->nil->prev != state->nil);
+ 
+ 			if (state->insertrank > state->nil->prev->rank)
+ 				tuplewindow_removeslot(state, state->nil->prev, true);
+ 		}
+ 
+ 		/*
+ 		 * We insert the tuple at the ranked position, this keeps the window
+ 		 * ordered by the rank.
+ 		 */
+ 		if (tuplewindow_has_freespace(state))
+ 		{
+ 			tuplewindow_puttupleslot_impl(state, slot, timestamp, state->rankinsert, state->insertrank);
+ 		}
+ 		
+ 		/* checking that the tuples in the window are ordered rank desc (\infty .. -\infty) */
+ 		/*
+ 		{
+ 			double		rank = state->nil->rank;
+ 			TupleWindowSlot *next = state->nil->next;
+ 			while (next != state->nil)
+ 			{
+ 				Assert(next->rank <= rank);
+ 				rank = next->rank;
+ 				next = next->next;
+ 			}
+ 		}
+ 		*/
+ 		break;
+ 
+ 	default:
+ 		elog(ERROR, "invalid tuple window policy: %d", state->policy);
+ 		break;
+ 	}
+ }
diff -cr --new-file -b --tabsize 4 -x CVS -x .svn -x tools pgsql-REL8_3_STABLE/src/backend/utils/sort/tuplestore.c pgsql/src/backend/utils/sort/tuplestore.c
*** pgsql-REL8_3_STABLE/src/backend/utils/sort/tuplestore.c	Tue Jan  1 20:45:55 2008
--- pgsql/src/backend/utils/sort/tuplestore.c	Thu Jan 10 19:37:15 2008
***************
*** 711,716 ****
--- 711,753 ----
  	}
  }
  
+ 
+ /*
+  * tuplsestore_catchup	- move current postion to writepos
+  */
+ void
+ tuplestore_catchup(Tuplestorestate *state)
+ {
+ 	Assert(state->eflags & EXEC_FLAG_MARK);
+ 
+ 	switch (state->status)
+ 	{
+ 		case TSS_INMEM:
+ 			state->eof_reached = false;
+ 			state->current = state->memtupcount;
+ 			if (!(state->eflags & (EXEC_FLAG_BACKWARD | EXEC_FLAG_REWIND)))
+ 				tuplestore_trim(state, 0);
+ 			break;
+ 		case TSS_WRITEFILE:
+ 			state->eof_reached = false;
+ 			BufFileTell(state->myfile,
+ 						&state->readpos_file,
+ 						&state->readpos_offset);
+ 			break;
+ 		case TSS_READFILE:
+ 			state->eof_reached = false;
+ 			if (BufFileSeek(state->myfile,
+ 							state->writepos_file,
+ 							state->writepos_offset,
+ 							SEEK_SET) != 0)
+ 				elog(ERROR, "tuplestore_move_readpos_to_writepos failed");
+ 			break;
+ 		default:
+ 			elog(ERROR, "invalid tuplestore state");
+ 			break;
+ 	}
+ }
+ 
  /*
   * tuplestore_markpos	- saves current position in the tuple sequence
   */
diff -cr --new-file -b --tabsize 4 -x CVS -x .svn -x tools pgsql-REL8_3_STABLE/src/include/access/printtup.h pgsql/src/include/access/printtup.h
*** pgsql-REL8_3_STABLE/src/include/access/printtup.h	Tue Jan  1 20:45:56 2008
--- pgsql/src/include/access/printtup.h	Thu Jan 10 19:36:24 2008
***************
*** 25,30 ****
--- 25,32 ----
  			 TupleDesc typeinfo);
  extern void debugtup(TupleTableSlot *slot, DestReceiver *self);
  
+ extern char *datum_to_text(Datum datum, bool isnull, Oid restype);
+ 
  /* XXX these are really in executor/spi.c */
  extern void spi_dest_startup(DestReceiver *self, int operation,
  				 TupleDesc typeinfo);
diff -cr --new-file -b --tabsize 4 -x CVS -x .svn -x tools pgsql-REL8_3_STABLE/src/include/executor/nodeElimFilter.h pgsql/src/include/executor/nodeElimFilter.h
*** pgsql-REL8_3_STABLE/src/include/executor/nodeElimFilter.h	Thu Jan  1 01:00:00 1970
--- pgsql/src/include/executor/nodeElimFilter.h	Tue Nov 11 21:18:46 2008
***************
*** 0 ****
--- 1,30 ----
+ /*-------------------------------------------------------------------------
+  *
+  * nodeElimFilter.c
+  *	  prototypes for nodeElimFilter.c
+  *
+  * Portions Copyright (c) 2008, PostgreSQL Global Development Group
+  * Portions Copyright (c) 2007-2008, Hannes Eder
+  *
+  *
+  * DESCRIPTION
+  *	  FIXME
+  *
+  * IDENTIFICATION
+  *	  $PostgreSQL: $
+  *
+  *-------------------------------------------------------------------------
+  */
+ #ifndef NODEELIMFILTER_H
+ #define NODEELIMFILTER_H
+ 
+ #include "nodes/execnodes.h"
+ 
+ extern int	ExecCountSlotsElimFilter(ElimFilter *node);
+ extern ElimFilterState *ExecInitElimFilter(ElimFilter *node, EState *estate, int eflags);
+ extern TupleTableSlot *ExecElimFilter(ElimFilterState *node);
+ extern void ExecEndElimFilter(ElimFilterState *node);
+ extern void ExecReScanElimFilter(ElimFilterState *node, ExprContext *exprCtxt);
+ 
+ 
+ #endif   /* NODEELIMFILTER_H */
diff -cr --new-file -b --tabsize 4 -x CVS -x .svn -x tools pgsql-REL8_3_STABLE/src/include/executor/nodeSkyline.h pgsql/src/include/executor/nodeSkyline.h
*** pgsql-REL8_3_STABLE/src/include/executor/nodeSkyline.h	Thu Jan  1 01:00:00 1970
--- pgsql/src/include/executor/nodeSkyline.h	Tue Nov 11 21:18:29 2008
***************
*** 0 ****
--- 1,30 ----
+ /*-------------------------------------------------------------------------
+  *
+  * nodeSkyline.h
+  *	  prototypes for nodeSkyline.c
+  *
+  * Portions Copyright (c) 2008, PostgreSQL Global Development Group
+  * Portions Copyright (c) 2007-2008, Hannes Eder
+  *
+  *
+  * DESCRIPTION
+  *	  FIXME
+  *
+  * IDENTIFICATION
+  *	  $PostgreSQL: $
+  *
+  *-------------------------------------------------------------------------
+  */
+ #ifndef NODESKYLINE_H
+ #define NODESKYLINE_H
+ 
+ #include "nodes/execnodes.h"
+ 
+ extern int	ExecCountSlotsSkyline(Skyline *node);
+ extern SkylineState *ExecInitSkyline(Skyline *node, EState *estate, int eflags);
+ extern TupleTableSlot *ExecSkyline(SkylineState *node);
+ extern void ExecEndSkyline(SkylineState *node);
+ extern void ExecReScanSkyline(SkylineState *node, ExprContext *exprCtxt);
+ 
+ 
+ #endif   /* NODESKYLINE_H */
diff -cr --new-file -b --tabsize 4 -x CVS -x .svn -x tools pgsql-REL8_3_STABLE/src/include/nodes/execnodes.h pgsql/src/include/nodes/execnodes.h
*** pgsql-REL8_3_STABLE/src/include/nodes/execnodes.h	Tue Jan  1 20:45:58 2008
--- pgsql/src/include/nodes/execnodes.h	Mon May 26 13:23:05 2008
***************
*** 20,25 ****
--- 20,26 ----
  #include "nodes/tidbitmap.h"
  #include "utils/hsearch.h"
  #include "utils/tuplestore.h"
+ #include "utils/tuplewindow.h"
  
  
  /* ----------------
***************
*** 1343,1348 ****
--- 1344,1413 ----
  	bool		grp_done;		/* indicates completion of Group scan */
  } GroupState;
  
+ /* --------------------------
+  *  SkylineState information
+  * --------------------------
+  */
+ typedef enum
+ {
+ 	SS_INIT,
+ 	SS_PIPEOUT,
+ 	SS_FINALPIPEOUT,
+ 	SS_PROCESS,
+ 	SS_DONE
+ } SkylineStatus;
+ 
+ typedef enum
+ {
+ 	SS_OUTER,
+ 	SS_TEMP
+ } SkylineSource;
+ 
+ #define SL_FLAGS_NONE		0x0000
+ #define SL_FLAGS_RANKED		0x0001
+ #define SL_FLAGS_ENTROPY	0x0002
+ #define SL_FLAGS_RANDOM		0x0004
+ 
+ typedef struct SkylineState
+ {
+ 	ScanState			ss;					/* its first field is NodeTag */
+ 	SkylineStatus		status;
+ 	SkylineMethod		skyline_method;
+ 	int					flags;
+ 	FmgrInfo		   *compareOpFn;		/* compare funtions */
+ 	int				   *compareFlags;
+ 	FmgrInfo		   *coerceFn;
+ 	int64				sl_pos;				/* for MNL */
+ 	Tuplestorestate	   *tuplestorestate;	/* used for 1d distinct */
+ 	TupleWindowState   *window;				/* for BNL and SFS */
+ 	int64				timestampIn;
+ 	int64				timestampOut;
+ 	SkylineSource		source;
+ 	Tuplestorestate	   *tempIn;
+ 	Tuplestorestate	   *tempOut;
+ 	TupleTableSlot	   *extraSlot;
+ 
+ 	int64				pass;
+ 
+ 	TupleWindowPolicy	window_policy;
+ 	int					windowsize;
+ 	int					windowslots;
+ 
+ 	int64				cmps_tuples;
+ 	int64				cmps_fields;
+ 
+ 	StringInfo			pass_info;
+ } SkylineState;
+ 
+ /* -----------------------------
+  *  ElimFilterState information
+  * -----------------------------
+  */
+ 
+ /* it's a little waste of memory but it's simpler for the moment */
+ typedef SkylineState ElimFilterState;
+ 
+ 
  /* ---------------------
   *	AggState information
   *
diff -cr --new-file -b --tabsize 4 -x CVS -x .svn -x tools pgsql-REL8_3_STABLE/src/include/nodes/nodes.h pgsql/src/include/nodes/nodes.h
*** pgsql-REL8_3_STABLE/src/include/nodes/nodes.h	Tue Jan  1 20:45:58 2008
--- pgsql/src/include/nodes/nodes.h	Thu Jan 10 19:36:29 2008
***************
*** 61,66 ****
--- 61,68 ----
  	T_HashJoin,
  	T_Material,
  	T_Sort,
+ 	T_Skyline,
+ 	T_ElimFilter,
  	T_Group,
  	T_Agg,
  	T_Unique,
***************
*** 93,98 ****
--- 95,102 ----
  	T_HashJoinState,
  	T_MaterialState,
  	T_SortState,
+ 	T_SkylineState,
+ 	T_ElimFilterState,
  	T_GroupState,
  	T_AggState,
  	T_UniqueState,
***************
*** 327,332 ****
--- 331,339 ----
  	T_ResTarget,
  	T_TypeCast,
  	T_SortBy,
+ 	T_SkylineOfClause,
+ 	T_SkylineOfExpr,
+ 	T_SkylineOption,
  	T_RangeSubselect,
  	T_RangeFunction,
  	T_TypeName,
***************
*** 337,342 ****
--- 344,351 ----
  	T_RangeTblEntry,
  	T_SortClause,
  	T_GroupClause,
+ 	T_SkylineClause,
+ 	T_SkylineOf,
  	T_FkConstraint,
  	T_PrivGrantee,
  	T_FuncWithArgs,
diff -cr --new-file -b --tabsize 4 -x CVS -x .svn -x tools pgsql-REL8_3_STABLE/src/include/nodes/parsenodes.h pgsql/src/include/nodes/parsenodes.h
*** pgsql-REL8_3_STABLE/src/include/nodes/parsenodes.h	Thu Feb  7 18:09:51 2008
--- pgsql/src/include/nodes/parsenodes.h	Mon Mar  3 15:37:45 2008
***************
*** 43,48 ****
--- 43,71 ----
  	SORTBY_NULLS_LAST
  } SortByNulls;
  
+ /*
+  * Skyline direction options 
+  *
+  * FIXME
+  */
+ typedef enum SkylineOfDir
+ {
+ 	SKYLINEOF_DEFAULT,
+ 	SKYLINEOF_MIN,
+ 	SKYLINEOF_MAX,
+ 	SKYLINEOF_DIFF,
+ 	SKYLINEOF_USING
+ } SkylineOfDir;
+ 
+ /*
+  * FIXME
+  */
+ typedef enum SkylineOfNulls
+ {
+ 	SKYLINEOF_NULLS_DEFAULT	= SORTBY_NULLS_DEFAULT,
+ 	SKYLINEOF_NULLS_FIRST	= SORTBY_NULLS_FIRST,
+ 	SKYLINEOF_NULLS_LAST	= SORTBY_NULLS_LAST
+ } SkylineOfNulls;
  
  /*
   * Grantable rights are encoded so that we can OR them together in a bitmask.
***************
*** 120,125 ****
--- 143,150 ----
  
  	Node	   *havingQual;		/* qualifications applied to groups */
  
+ 	Node	   *skylineClause;	/* a SkylineClause */
+ 
  	List	   *distinctClause; /* a list of SortClause's */
  
  	List	   *sortClause;		/* a list of SortClause's */
***************
*** 344,349 ****
--- 369,401 ----
  } SortBy;
  
  /*
+  * SkylineOfExpr - for SKYLINE OF clause
+  *
+  * FIXME
+  */
+ typedef struct SkylineOfExpr
+ {
+ 	NodeTag			type;
+ 	SkylineOfDir	skylineof_dir;		/* MIN/MAX/DIFF/USING */
+ 	SkylineOfNulls	skylineof_nulls;	/* NULLS FIRST/LAST */
+ 	List		   *useOp;				/* name of op to use, if SKYLINEOF_USING */
+ 	Node		   *node;				/* the expression to skyline of */
+ } SkylineOfExpr;
+ 
+ /*
+  * SkylineOfClause - returned by the Parser for SKYLINE OF clause
+  *
+  * FIXME
+  */
+ typedef struct SkylineOfClause
+ {
+ 	NodeTag		type;
+ 	bool		skyline_distinct;		/* SKYLINE OF _DISTINCT_ */
+ 	List	   *skyline_of_list;		/* a list of SkylineOfExpr */
+ 	List	   *skyline_of_options;		/* a list of SkylineOption */
+ } SkylineOfClause;
+ 
+ /*
   * RangeSubselect - subquery appearing in a FROM clause
   */
  typedef struct RangeSubselect
***************
*** 643,648 ****
--- 695,748 ----
  typedef SortClause GroupClause;
  
  /*
+  * SkylineOption
+  *
+  * FIXME
+  */
+ typedef struct SkylineOption
+ {
+ 	NodeTag		type;
+ 	char	   *name;
+ 	Node	   *value;
+ } SkylineOption;
+ 
+ /*
+  * SkylineClause
+  *
+  * The analyzer transforms a SkylineOfClause into SkylineClause.
+  * While the skyline_of_list is transformed from SkylineOfExpr into SkylineOf
+  *
+  * FIXME
+  */
+ typedef struct SkylineClause
+ {
+ 	NodeTag		type;
+ 	bool		skyline_distinct;
+ 	List	   *skyline_of_list;	/* list of SkylineOf's */
+ 	List	   *skyline_of_options;
+ } SkylineClause;
+ 
+ /*
+  * SkylineOf
+  *
+  * FIXME
+  */
+ #define SKYLINE_FLAGS_NONE			0
+ #define SKYLINE_FLAGS_COERCE		1
+ #define SKYLINE_FLAGS_HAVE_STATS	2
+ #define SKYLINE_FLAGS_COERCE_FUNC	4
+ 
+ typedef struct SkylineOf
+ {
+ 	NodeTag			type;
+ 	Index			tleSortGroupRef;	/* reference into targetlist */
+ 	Oid				restype;		/* type of the skyline expression */
+ 	Oid				skylineop;		/* the ordering operator ('<' op) */
+ 	bool			nulls_first;	/* do NULLs come before normal values? */
+ 	SkylineOfDir	skylineof_dir;
+ } SkylineOf;
+ 
+ /*
   * RowMarkClause -
   *	   representation of FOR UPDATE/SHARE clauses
   *
***************
*** 740,745 ****
--- 840,846 ----
  	Node	   *whereClause;	/* WHERE qualification */
  	List	   *groupClause;	/* GROUP BY clauses */
  	Node	   *havingClause;	/* HAVING conditional-expression */
+ 	Node	   *skylineOfClause;	/* SKYLINE OF clause */
  
  	/*
  	 * In a "leaf" node representing a VALUES list, the above fields are all
diff -cr --new-file -b --tabsize 4 -x CVS -x .svn -x tools pgsql-REL8_3_STABLE/src/include/nodes/plannodes.h pgsql/src/include/nodes/plannodes.h
*** pgsql-REL8_3_STABLE/src/include/nodes/plannodes.h	Tue Jan  1 20:45:58 2008
--- pgsql/src/include/nodes/plannodes.h	Tue Mar 25 20:49:13 2008
***************
*** 454,459 ****
--- 454,504 ----
  	bool	   *nullsFirst;		/* NULLS FIRST/LAST directions */
  } Sort;
  
+ /* ----------------
+  *		skyline node
+  * ----------------
+  */
+ typedef enum SkylineMethod
+ {
+ 	SM_UNKNOWN,
+ 	SM_1DIM,
+ 	SM_1DIM_DISTINCT,
+ 	SM_2DIM_PRESORT,
+ 	SM_MATERIALIZEDNESTEDLOOP,
+ 	SM_BLOCKNESTEDLOOP,
+ 	SM_SFS,
+ 	SM_ELIMFILTER
+ } SkylineMethod;
+ 
+ typedef struct Skyline
+ {
+ 	Plan		plan;
+ 	bool		skyline_distinct;
+ 	int			numCols;
+ 	int			flags;
+ 	AttrNumber *skylineColIdx;
+ 	Oid		   *skylineOfOperators;
+ 	bool	   *nullsFirst;
+ 	int		   *skylineOfDir;
+ 	int		   *colFlags;
+ 	float8	   *colMin;
+ 	float8	   *colScale;
+ 	Oid		   *colCoerceFunc;
+ 	List	   *skyline_of_options;
+ 	SkylineMethod skyline_method;
+ } Skyline;
+ 
+ #define SKYLINE_RANK_EPSILON	(0.0)
+ #define SKYLINE_RANK_BOUND_MIN	(0.0+SKYLINE_RANK_EPSILON)
+ #define SKYLINE_RANK_BOUND_MAX	(1.0-SKYLINE_RANK_EPSILON)
+ #define SKYLINE_RANK_RANGE		(SKYLINE_RANK_BOUND_MAX-SKYLINE_RANK_BOUND_MIN)
+ 
+ /* ----------------
+  *		elimination filter node
+  * ----------------
+  */
+ typedef Skyline ElimFilter;
+ 
  /* ---------------
   *	 group node -
   *		Used for queries with GROUP BY (but no aggregates) specified.
diff -cr --new-file -b --tabsize 4 -x CVS -x .svn -x tools pgsql-REL8_3_STABLE/src/include/nodes/relation.h pgsql/src/include/nodes/relation.h
*** pgsql-REL8_3_STABLE/src/include/nodes/relation.h	Mon Apr 21 22:54:24 2008
--- pgsql/src/include/nodes/relation.h	Tue Nov 11 17:53:22 2008
***************
*** 163,168 ****
--- 163,169 ----
  								 * actual pathkeys afterwards */
  
  	List	   *group_pathkeys;			/* groupClause pathkeys, if any */
+ 	List	   *skyline_pathkeys;		/* skylineClause pathkeys, if any */
  	List	   *sort_pathkeys;			/* sortClause pathkeys, if any */
  
  	List	   *initial_rels;	/* RelOptInfos we are now trying to join */
diff -cr --new-file -b --tabsize 4 -x CVS -x .svn -x tools pgsql-REL8_3_STABLE/src/include/optimizer/cost.h pgsql/src/include/optimizer/cost.h
*** pgsql-REL8_3_STABLE/src/include/optimizer/cost.h	Tue Jan  1 20:45:58 2008
--- pgsql/src/include/optimizer/cost.h	Thu Jan 10 19:36:20 2008
***************
*** 72,77 ****
--- 72,78 ----
  				  RelOptInfo *baserel);
  extern void cost_valuesscan(Path *path, PlannerInfo *root,
  				RelOptInfo *baserel);
+ extern void cost_skyline(Path *path, PlannerInfo *root, Cost input_cost, double input_tuples, int width, double output_tuples, int skyline_dim, SkylineMethod skyline_method, int limit_tuples);
  extern void cost_sort(Path *path, PlannerInfo *root,
  		  List *pathkeys, Cost input_cost, double tuples, int width,
  		  double limit_tuples);
diff -cr --new-file -b --tabsize 4 -x CVS -x .svn -x tools pgsql-REL8_3_STABLE/src/include/optimizer/paths.h pgsql/src/include/optimizer/paths.h
*** pgsql-REL8_3_STABLE/src/include/optimizer/paths.h	Mon Mar 31 18:59:33 2008
--- pgsql/src/include/optimizer/paths.h	Tue Nov 11 17:53:19 2008
***************
*** 155,165 ****
--- 155,169 ----
  extern List *canonicalize_pathkeys(PlannerInfo *root, List *pathkeys);
  extern PathKeysComparison compare_pathkeys(List *keys1, List *keys2);
  extern bool pathkeys_contained_in(List *keys1, List *keys2);
+ extern bool skyline_pathkeys_contained_in(List *keys1, List *keys2, int *nuseful);
  extern Path *get_cheapest_path_for_pathkeys(List *paths, List *pathkeys,
  							   CostSelector cost_criterion);
  extern Path *get_cheapest_fractional_path_for_pathkeys(List *paths,
  										  List *pathkeys,
  										  double fraction);
+ extern Path *get_cheapest_fractional_path_for_skyline_pathkeys(List *paths,
+ 										  List *pathkeys,
+ 										  double fraction);
  extern List *build_index_pathkeys(PlannerInfo *root, IndexOptInfo *index,
  					 ScanDirection scandir);
  extern List *convert_subquery_pathkeys(PlannerInfo *root, RelOptInfo *rel,
***************
*** 172,177 ****
--- 176,185 ----
  							  List *sortclauses,
  							  List *tlist,
  							  bool canonicalize);
+ extern List *make_pathkeys_for_skylineclause(PlannerInfo *root,
+ 											 SkylineClause *skylineclause,
+ 											 List *tlist,
+ 											 bool canonicalize);
  extern void cache_mergeclause_eclasses(PlannerInfo *root,
  						   RestrictInfo *restrictinfo);
  extern List *find_mergeclauses_for_pathkeys(PlannerInfo *root,
diff -cr --new-file -b --tabsize 4 -x CVS -x .svn -x tools pgsql-REL8_3_STABLE/src/include/optimizer/planmain.h pgsql/src/include/optimizer/planmain.h
*** pgsql-REL8_3_STABLE/src/include/optimizer/planmain.h	Thu Apr 17 23:22:23 2008
--- pgsql/src/include/optimizer/planmain.h	Tue Nov 11 17:53:18 2008
***************
*** 22,28 ****
   */
  extern void query_planner(PlannerInfo *root, List *tlist,
  			  double tuple_fraction, double limit_tuples,
! 			  Path **cheapest_path, Path **sorted_path,
  			  double *num_groups);
  
  /*
--- 22,28 ----
   */
  extern void query_planner(PlannerInfo *root, List *tlist,
  			  double tuple_fraction, double limit_tuples,
! 			  Path **cheapest_path, Path **sorted_path, Path **skyline_path,
  			  double *num_groups);
  
  /*
***************
*** 38,43 ****
--- 38,45 ----
  extern SubqueryScan *make_subqueryscan(List *qptlist, List *qpqual,
  				  Index scanrelid, Plan *subplan, List *subrtable);
  extern Append *make_append(List *appendplans, bool isTarget, List *tlist);
+ extern Skyline *make_skyline(PlannerInfo *root, Plan *lefttree, Node *skyline_clause, SkylineMethod skyline_method, int limit_tuples);
+ extern ElimFilter *make_elimfilter(PlannerInfo *root, Plan *lefttree, Node *skyline_clause, int limit_tuples);
  extern Sort *make_sort_from_pathkeys(PlannerInfo *root, Plan *lefttree,
  						List *pathkeys, double limit_tuples);
  extern Sort *make_sort_from_sortclauses(PlannerInfo *root, List *sortcls,
diff -cr --new-file -b --tabsize 4 -x CVS -x .svn -x tools pgsql-REL8_3_STABLE/src/include/optimizer/tlist.h pgsql/src/include/optimizer/tlist.h
*** pgsql-REL8_3_STABLE/src/include/optimizer/tlist.h	Tue Jan  1 20:45:58 2008
--- pgsql/src/include/optimizer/tlist.h	Thu Jan 10 19:36:20 2008
***************
*** 27,32 ****
--- 27,34 ----
  					 List *targetList);
  extern TargetEntry *get_sortgroupclause_tle(SortClause *sortClause,
  						List *targetList);
+ extern TargetEntry *get_skylineclause_tle(SkylineOf *skylineOf,
+ 						List *targetList);
  extern Node *get_sortgroupclause_expr(SortClause *sortClause,
  						 List *targetList);
  extern List *get_sortgrouplist_exprs(List *sortClauses,
diff -cr --new-file -b --tabsize 4 -x CVS -x .svn -x tools pgsql-REL8_3_STABLE/src/include/parser/parse_clause.h pgsql/src/include/parser/parse_clause.h
*** pgsql-REL8_3_STABLE/src/include/parser/parse_clause.h	Tue Jan  1 20:45:58 2008
--- pgsql/src/include/parser/parse_clause.h	Thu Jan 10 19:36:33 2008
***************
*** 28,33 ****
--- 28,35 ----
  					const char *constructName);
  extern List *transformGroupClause(ParseState *pstate, List *grouplist,
  					List **targetlist, List *sortClause);
+ extern Node *transformSkylineClause(ParseState *pstate, Node *skylineOfClause,
+ 					List **targetlist, bool resolveUnknown);
  extern List *transformSortClause(ParseState *pstate, List *orderlist,
  					List **targetlist, bool resolveUnknown);
  extern List *transformDistinctClause(ParseState *pstate, List *distinctlist,
***************
*** 36,46 ****
--- 38,53 ----
  extern List *addAllTargetsToSortList(ParseState *pstate,
  					List *sortlist, List *targetlist,
  					bool resolveUnknown);
+ extern List *addTargetToSkylineList(ParseState *pstate, TargetEntry *tle,
+ 					List *skylinelist, List *targetlist,
+ 					SkylineOfDir skylineof_dir, SkylineOfNulls skylineof_nulls,
+ 					List *skylineof_opname, bool resolveUnknown);
  extern List *addTargetToSortList(ParseState *pstate, TargetEntry *tle,
  					List *sortlist, List *targetlist,
  					SortByDir sortby_dir, SortByNulls sortby_nulls,
  					List *sortby_opname, bool resolveUnknown);
  extern Index assignSortGroupRef(TargetEntry *tle, List *tlist);
  extern bool targetIsInSortList(TargetEntry *tle, Oid sortop, List *sortList);
+ extern bool targetIsInSkylineList(TargetEntry *tle, Oid skylineop, List *skylineList);
  
  #endif   /* PARSE_CLAUSE_H */
diff -cr --new-file -b --tabsize 4 -x CVS -x .svn -x tools pgsql-REL8_3_STABLE/src/include/utils/selfuncs.h pgsql/src/include/utils/selfuncs.h
*** pgsql-REL8_3_STABLE/src/include/utils/selfuncs.h	Tue Jan  1 20:45:59 2008
--- pgsql/src/include/utils/selfuncs.h	Thu Jan 10 19:36:39 2008
***************
*** 106,111 ****
--- 106,113 ----
  extern void get_join_variables(PlannerInfo *root, List *args,
  				   VariableStatData *vardata1,
  				   VariableStatData *vardata2);
+ extern bool get_variable_range(PlannerInfo *root, VariableStatData *vardata,
+ 							   Oid sortop, Datum *min, Datum *max);
  extern double get_variable_numdistinct(VariableStatData *vardata);
  extern double mcv_selectivity(VariableStatData *vardata, FmgrInfo *opproc,
  				Datum constval, bool varonleft,
diff -cr --new-file -b --tabsize 4 -x CVS -x .svn -x tools pgsql-REL8_3_STABLE/src/include/utils/skyline.h pgsql/src/include/utils/skyline.h
*** pgsql-REL8_3_STABLE/src/include/utils/skyline.h	Thu Jan  1 01:00:00 1970
--- pgsql/src/include/utils/skyline.h	Tue Nov 11 21:23:37 2008
***************
*** 0 ****
--- 1,49 ----
+ /*-------------------------------------------------------------------------
+  *
+  * skyline.h
+  *	  prototypes for skyline.c
+  *
+  * Portions Copyright (c) 2008, PostgreSQL Global Development Group
+  * Portions Copyright (c) 2007-2008, Hannes Eder
+  *
+  *
+  * DESCRIPTION
+  *	  FIXME
+  *
+  * IDENTIFICATION
+  *	  $PostgreSQL: $
+  *
+  *-------------------------------------------------------------------------
+  */
+ #ifndef SKYLINE_H
+ #define SKYLINE_H
+ 
+ #include "nodes/parsenodes.h"
+ #include "nodes/plannodes.h"
+ #include "nodes/execnodes.h"
+ 
+ #define SKYLINE_CMP_FIRST_DOMINATES -2
+ #define SKYLINE_CMP_INCOMPARABLE -1
+ #define SKYLINE_CMP_ALL_EQ 0
+ #define SKYLINE_CMP_DIFF_GRP_DIFF 1
+ #define SYKLINE_CMP_SECOND_DOMINATES 2
+ 
+ extern SkylineMethod skyline_method_forced_by_options(SkylineClause *skyline_clause);
+ extern SkylineMethod skyline_choose_method(SkylineClause *skyline_clause, bool has_matching_path);
+ extern int	skyline_get_dim(SkylineClause *skyline_clause);
+ extern bool skyline_method_preserves_tuple_order(SkylineMethod skyline_method);
+ extern bool skyline_option_get_int(List *skyline_of_options, char *name, int *value);
+ extern bool skyline_option_get_string(List *skyline_of_options, char *name, char **value);
+ extern bool skyline_option_get_window_policy(List *skyline_of_options, char *name, TupleWindowPolicy *window_policy);
+ extern const char *skyline_method_name(SkylineMethod skyline_method);
+ extern const char *skyline_window_policy_name(TupleWindowPolicy window_policy);
+ extern bool skyline_methode_can_use_limit(SkylineMethod skyline_method);
+ 
+ /* from backend/executor/nodeSkyline.c */
+ extern int ExecSkylineIsDominating(SkylineState *node, TupleTableSlot *inner_slot, TupleTableSlot *slot);
+ extern void ExecSkylineCacheCompareFunctionInfo(SkylineState *slstate, Skyline *node);
+ extern void ExecSkylineCacheCoerceFunctionInfo(SkylineState *slstate, Skyline *node);
+ extern double ExecSkylineRank(SkylineState *node, TupleTableSlot *slot);
+ extern double ExecSkylineRandom();
+ 
+ #endif   /* SKYLINE_H */
diff -cr --new-file -b --tabsize 4 -x CVS -x .svn -x tools pgsql-REL8_3_STABLE/src/include/utils/tuplestore.h pgsql/src/include/utils/tuplestore.h
*** pgsql-REL8_3_STABLE/src/include/utils/tuplestore.h	Tue Jan  1 20:45:59 2008
--- pgsql/src/include/utils/tuplestore.h	Thu Jan 10 19:36:39 2008
***************
*** 66,70 ****
--- 66,71 ----
  extern void tuplestore_rescan(Tuplestorestate *state);
  extern void tuplestore_markpos(Tuplestorestate *state);
  extern void tuplestore_restorepos(Tuplestorestate *state);
+ extern void tuplestore_catchup(Tuplestorestate *state);
  
  #endif   /* TUPLESTORE_H */
diff -cr --new-file -b --tabsize 4 -x CVS -x .svn -x tools pgsql-REL8_3_STABLE/src/include/utils/tuplewindow.h pgsql/src/include/utils/tuplewindow.h
*** pgsql-REL8_3_STABLE/src/include/utils/tuplewindow.h	Thu Jan  1 01:00:00 1970
--- pgsql/src/include/utils/tuplewindow.h	Tue Nov 11 21:24:19 2008
***************
*** 0 ****
--- 1,46 ----
+ /*-------------------------------------------------------------------------
+  *
+  * tuplewindow.h
+  *	  prototypes for tuplewindow.c
+  *
+  * Portions Copyright (c) 2008, PostgreSQL Global Development Group
+  * Portions Copyright (c) 2007-2008, Hannes Eder
+  *
+  *
+  * DESCRIPTION
+  *	  FIXME
+  *
+  * IDENTIFICATION
+  *	  $PostgreSQL: $
+  *
+  *-------------------------------------------------------------------------
+  */
+ #ifndef TUPLEWINDOW_H
+ #define TUPLEWINDOW_H
+ 
+ #include "executor/tuptable.h"
+ 
+ typedef struct TupleWindowState TupleWindowState;
+ 
+ typedef enum TupleWindowPolicy
+ {
+ 	TUP_WIN_POLICY_APPEND,
+ 	TUP_WIN_POLICY_PREPEND,
+ 	TUP_WIN_POLICY_ENTROPY,
+ 	TUP_WIN_POLICY_RANDOM
+ } TupleWindowPolicy;
+ 
+ extern TupleWindowState *tuplewindow_begin(int maxKBytes, int maxSlots, TupleWindowPolicy policy);
+ extern bool tuplewindow_has_freespace(TupleWindowState *state);
+ extern void tuplewindow_setinsertrank(TupleWindowState *state, double rank);
+ extern void tuplewindow_puttupleslot(TupleWindowState *state, TupleTableSlot *slot, int64 timestamp, bool forced);
+ extern void tuplewindow_rewind(TupleWindowState *state);
+ extern bool tuplewindow_ateof(TupleWindowState *state);
+ extern void tuplewindow_movenext(TupleWindowState *state);
+ extern int64 tuplewindow_timestampcurrent(TupleWindowState *state);
+ extern bool tuplewindow_gettupleslot(TupleWindowState *state, TupleTableSlot *slot, bool removeit);
+ extern void tuplewindow_removecurrent(TupleWindowState *state);
+ extern void tuplewindow_clean(TupleWindowState *state);
+ extern void tuplewindow_end(TupleWindowState *state);
+ 
+ #endif   /* TUPLEWINDOW_H */
diff -cr --new-file -b --tabsize 4 -x CVS -x .svn -x tools pgsql-REL8_3_STABLE/src/test/regress/expected/skyline_base.out pgsql/src/test/regress/expected/skyline_base.out
*** pgsql-REL8_3_STABLE/src/test/regress/expected/skyline_base.out	Thu Jan  1 01:00:00 1970
--- pgsql/src/test/regress/expected/skyline_base.out	Tue Dec 11 13:55:19 2007
***************
*** 0 ****
--- 1,43 ----
+ --
+ -- NOTE: the table contains 1000 rows, as only with at least
+ -- this size, real bugs have been found during development
+ --
+ DROP TABLE IF EXISTS "a2d1000";
+ NOTICE:  table "a2d1000" does not exist, skipping
+ CREATE TABLE "a2d1000" (id int, d1 float, d2 float);
+ COPY "a2d1000" (id, d1, d2) FROM STDIN DELIMITERS ',' CSV QUOTE '''';
+                         
+ SELECT ID FROM "a2d1000" SKYLINE OF d1 MIN, d2 MIN ORDER BY ID;
+  id  
+ -----
+   37
+   63
+   93
+  152
+  157
+  169
+  258
+  266
+  277
+  282
+  385
+  401
+  410
+  468
+  533
+  534
+  587
+  606
+  616
+  704
+  711
+  779
+  796
+  872
+  894
+  906
+  914
+  930
+ (28 rows)
+ 
+ DROP TABLE IF EXISTS "a2d1000";
diff -cr --new-file -b --tabsize 4 -x CVS -x .svn -x tools pgsql-REL8_3_STABLE/src/test/regress/parallel_schedule pgsql/src/test/regress/parallel_schedule
*** pgsql-REL8_3_STABLE/src/test/regress/parallel_schedule	Sat Nov 24 20:49:23 2007
--- pgsql/src/test/regress/parallel_schedule	Tue Dec 11 13:26:14 2007
***************
*** 90,92 ****
--- 90,97 ----
  
  # run tablespace by itself
  test: tablespace
+ 
+ # ----------
+ # Another group of parallel tests
+ # ----------
+ test: skyline_base
diff -cr --new-file -b --tabsize 4 -x CVS -x .svn -x tools pgsql-REL8_3_STABLE/src/test/regress/serial_schedule pgsql/src/test/regress/serial_schedule
*** pgsql-REL8_3_STABLE/src/test/regress/serial_schedule	Sat Nov 24 21:41:35 2007
--- pgsql/src/test/regress/serial_schedule	Tue Dec 11 13:26:22 2007
***************
*** 115,117 ****
--- 115,118 ----
  test: xml
  test: stats
  test: tablespace
+ test: skyline_base
diff -cr --new-file -b --tabsize 4 -x CVS -x .svn -x tools pgsql-REL8_3_STABLE/src/test/regress/skyline_schedule pgsql/src/test/regress/skyline_schedule
*** pgsql-REL8_3_STABLE/src/test/regress/skyline_schedule	Thu Jan  1 01:00:00 1970
--- pgsql/src/test/regress/skyline_schedule	Tue Dec 11 13:26:54 2007
***************
*** 0 ****
--- 1 ----
+ test: skyline_base
diff -cr --new-file -b --tabsize 4 -x CVS -x .svn -x tools pgsql-REL8_3_STABLE/src/test/regress/sql/skyline_base.sql pgsql/src/test/regress/sql/skyline_base.sql
*** pgsql-REL8_3_STABLE/src/test/regress/sql/skyline_base.sql	Thu Jan  1 01:00:00 1970
--- pgsql/src/test/regress/sql/skyline_base.sql	Tue Dec 11 13:55:23 2007
***************
*** 0 ****
--- 1,1013 ----
+ --
+ -- NOTE: the table contains 1000 rows, as only with at least
+ -- this size, real bugs have been found during development
+ --
+ 
+ DROP TABLE IF EXISTS "a2d1000";
+ CREATE TABLE "a2d1000" (id int, d1 float, d2 float);
+ COPY "a2d1000" (id, d1, d2) FROM STDIN DELIMITERS ',' CSV QUOTE '''';
+ 1,2.758027734964960e-02,8.944411267944040e-01
+ 2,3.042260865565909e-01,8.140956722710638e-01
+ 3,6.387695135892089e-01,5.551155030665975e-01
+ 4,7.153641819404746e-01,2.068158258172283e-01
+ 5,7.690167872485909e-01,2.106234482066378e-01
+ 6,5.677800025759706e-01,4.734327015534904e-01
+ 7,5.589894289946323e-01,3.932378809502026e-01
+ 8,9.481056315399120e-01,3.499576441994582e-02
+ 9,6.121084842639277e-01,4.227053827804655e-01
+ 10,9.853421426975084e-01,1.276698826653587e-02
+ 11,1.029080557598893e-01,8.952705811661098e-01
+ 12,1.127660640537951e-01,8.731410775633506e-01
+ 13,2.286024706198205e-01,7.743486913950893e-01
+ 14,5.956224886286180e-01,2.585195223691185e-01
+ 15,7.236643335579644e-01,2.069432351539819e-01
+ 16,5.588596968270864e-01,4.508134932477343e-01
+ 17,3.516383266264835e-01,7.305310274125292e-01
+ 18,3.891426934322315e-01,5.826902784969528e-01
+ 19,1.548332426220980e-01,9.765716340704663e-01
+ 20,5.859241453546119e-01,3.692676393956819e-01
+ 21,1.595906393288682e-01,8.185000027974511e-01
+ 22,4.025501874635721e-01,6.085651674154647e-01
+ 23,5.188133753049664e-01,5.147095767481971e-01
+ 24,5.648934415790045e-01,4.825296955621187e-01
+ 25,2.892408931784421e-01,8.914118835999166e-01
+ 26,8.755633131109538e-01,6.608147884121514e-02
+ 27,1.015309814502237e-01,8.663398275174158e-01
+ 28,3.108280866797684e-01,7.646566081519962e-01
+ 29,3.395915157775601e-01,7.261042828984489e-01
+ 30,8.781770861425531e-01,1.738648893525613e-01
+ 31,4.561829991585075e-01,6.611843669533458e-01
+ 32,4.740738038072014e-01,4.659510404580426e-01
+ 33,4.326974126012608e-01,6.409251655283565e-01
+ 34,5.876358510358453e-01,3.158851363659586e-01
+ 35,2.823413331952636e-01,7.251693971064698e-01
+ 36,2.114521462193255e-01,7.038455676868518e-01
+ 37,7.545921928823901e-01,9.563205723813556e-02
+ 38,3.469588319299368e-01,6.872993379453531e-01
+ 39,8.754717244370767e-01,1.391595964861633e-01
+ 40,8.861113106169582e-01,3.292819848809059e-02
+ 41,6.763844019949292e-01,3.835635470134418e-01
+ 42,7.526801923290728e-01,2.633636954624820e-01
+ 43,1.076871320235575e-01,8.930614820977092e-01
+ 44,9.089629244770417e-01,4.387275490450192e-02
+ 45,5.623019545077943e-01,4.539016133122808e-01
+ 46,1.109924632824276e-01,8.545732976707221e-01
+ 47,6.348521230766141e-01,4.534529254538282e-01
+ 48,5.392689002725072e-01,5.113916131313155e-01
+ 49,9.553669088697010e-01,1.365064337712486e-01
+ 50,1.427137764671032e-01,7.764608129836044e-01
+ 51,7.901869710624456e-01,2.525516645548961e-01
+ 52,5.911218117880280e-01,4.967736440230960e-01
+ 53,4.705378703202246e-01,5.049828399351924e-01
+ 54,6.589083208399800e-01,2.994624715096827e-01
+ 55,2.828917817104687e-01,7.945499218537587e-01
+ 56,1.024733453685817e-02,9.807368837704395e-01
+ 57,1.679581289219145e-01,8.915719586584605e-01
+ 58,8.300299202081963e-01,2.048930304763265e-01
+ 59,3.463238364631151e-01,6.740061238966093e-01
+ 60,7.354317310493243e-02,8.228608110135087e-01
+ 61,1.665762392310720e-01,9.835955214637527e-01
+ 62,5.951450843010445e-01,4.655131385288746e-01
+ 63,1.393564415620284e-01,6.690478050431612e-01
+ 64,4.084706993651204e-01,6.822086210674418e-01
+ 65,5.851875533576379e-01,4.779298499371525e-01
+ 66,6.383864606609710e-01,4.464425416092692e-01
+ 67,3.338247222454244e-01,6.396004328984928e-01
+ 68,4.993058616845115e-01,4.661382976441673e-01
+ 69,2.371067725899687e-01,7.368961991386755e-01
+ 70,2.046231277035375e-01,8.294572757036041e-01
+ 71,5.891575428684124e-01,4.093176112941935e-01
+ 72,3.092488516013268e-01,8.050180185295823e-01
+ 73,2.606747151109738e-01,7.384912757053775e-01
+ 74,8.671995450984810e-02,8.636914256192785e-01
+ 75,7.781564926491731e-02,8.995518944175547e-01
+ 76,5.843986434443595e-01,4.033994505233070e-01
+ 77,7.924778232368845e-01,1.085925519841536e-01
+ 78,6.223708113419222e-01,4.040117308856510e-01
+ 79,4.013520547258138e-02,9.951288132728585e-01
+ 80,4.835607627794279e-01,5.437802857769558e-01
+ 81,7.544463074988332e-02,8.516552832345451e-01
+ 82,4.704938573589076e-01,4.956928611361210e-01
+ 83,2.853960934339401e-01,5.583502279243493e-01
+ 84,5.606542109277969e-01,5.402806057212014e-01
+ 85,6.469256782123018e-01,5.309259710269780e-01
+ 86,4.910695896914432e-01,5.031646236397592e-01
+ 87,2.902941482032344e-01,7.469315165625999e-01
+ 88,6.724094745179432e-01,3.595026114851653e-01
+ 89,7.964888293041875e-01,2.465137948969364e-01
+ 90,4.570785421337157e-01,5.290455908913276e-01
+ 91,3.256609055678023e-01,6.343763936514235e-01
+ 92,5.378292802751504e-01,3.542738344608538e-01
+ 93,8.909312993283590e-01,1.132763841649575e-02
+ 94,8.385433455961601e-02,7.839873437011359e-01
+ 95,6.969145260244252e-01,2.362984792913416e-01
+ 96,2.004290432443859e-01,8.532137997768382e-01
+ 97,4.610480188718907e-01,4.829058258206458e-01
+ 98,5.307388344964058e-02,9.549097395101668e-01
+ 99,6.728176715639684e-01,3.956421339183127e-01
+ 100,8.554776652292260e-01,2.665469404603558e-01
+ 101,7.316691748236854e-01,3.130683636363686e-01
+ 102,4.554420806041574e-01,4.493553165949903e-01
+ 103,6.855339899838400e-01,3.717953911992585e-01
+ 104,8.049472207158635e-02,8.957121174288155e-01
+ 105,5.860144457512624e-01,3.652969251660128e-01
+ 106,2.080914918047798e-01,6.868968255769605e-01
+ 107,4.410647795016618e-01,6.474372607112355e-01
+ 108,4.465104828152598e-01,5.510155060287427e-01
+ 109,7.734915189016642e-01,2.620315538925040e-01
+ 110,4.233438823228392e-01,5.455344722294613e-01
+ 111,3.723265951077250e-01,6.005236058325946e-01
+ 112,8.371596840933712e-01,1.088379492318742e-01
+ 113,4.263690909047894e-01,4.741316384184981e-01
+ 114,4.664842232074116e-01,4.918908483366529e-01
+ 115,1.984639846319099e-01,6.681370939218058e-01
+ 116,3.266989211504941e-01,6.581635736293479e-01
+ 117,2.893224541866131e-01,7.530765318517036e-01
+ 118,7.309122529642090e-01,2.599787387891731e-01
+ 119,1.348899584033370e-01,9.455656028026198e-01
+ 120,4.651581276747648e-01,5.359197946584585e-01
+ 121,4.355087007200581e-01,7.564463999202652e-01
+ 122,5.916945730687108e-01,5.470651773642883e-01
+ 123,7.268581658598772e-01,3.622971001654540e-01
+ 124,9.238585383681946e-01,9.038158947137562e-02
+ 125,8.687654290036796e-01,2.361135595113840e-01
+ 126,1.514510221041457e-01,9.079745241679342e-01
+ 127,3.996378857311097e-01,5.508092197379703e-01
+ 128,3.672794478230587e-01,5.330923846708071e-01
+ 129,6.295019352449964e-01,3.942224023789510e-01
+ 130,6.918754534960033e-01,2.457462297065044e-01
+ 131,1.263051952609156e-01,9.111050155357520e-01
+ 132,7.404747124710588e-01,1.761751328412829e-01
+ 133,8.599483872508008e-01,1.664042535073214e-01
+ 134,1.036927404594258e-01,9.193542667059796e-01
+ 135,7.628974825318041e-01,2.105559530758168e-01
+ 136,2.530896567237795e-01,8.299051631276549e-01
+ 137,1.346874564251890e-01,8.642913558218503e-01
+ 138,2.059813504293288e-01,8.551243225676773e-01
+ 139,2.424716279393303e-01,7.218810661900947e-01
+ 140,8.275003402801677e-01,2.392185091431979e-01
+ 141,4.151524387641145e-01,5.840391233761799e-01
+ 142,1.877310735174062e-02,9.937330165579114e-01
+ 143,4.641601197411758e-01,5.934729345731451e-01
+ 144,1.490369892555672e-01,8.656880013371085e-01
+ 145,2.437763737643540e-01,7.649774700392663e-01
+ 146,6.337674026167177e-01,3.883864963895891e-01
+ 147,3.226549089985596e-02,7.891319993507415e-01
+ 148,2.519992935254214e-02,9.975468046299217e-01
+ 149,4.244304534426560e-01,5.611605314014458e-01
+ 150,6.082380451744961e-01,2.851200107048774e-01
+ 151,8.261877859564321e-01,2.161889311113775e-01
+ 152,6.500528545775113e-01,1.840117180067133e-01
+ 153,5.288738074701107e-01,6.203726582081754e-01
+ 154,4.125359739561626e-01,5.516474607935656e-01
+ 155,8.522395003823333e-01,1.351006375175231e-01
+ 156,4.535356358191024e-01,5.491179810507137e-01
+ 157,5.360646482179942e-01,3.208149989544716e-01
+ 158,7.931834466337068e-01,1.669331585832953e-01
+ 159,7.692149747412939e-01,2.320080134618226e-01
+ 160,5.070352618273474e-02,9.942761947967190e-01
+ 161,2.335767474197816e-01,8.505857978546163e-01
+ 162,9.935396222065144e-01,1.651222662364170e-01
+ 163,5.338622613148694e-01,4.037130410532733e-01
+ 164,9.583610246483908e-01,2.530676615613377e-02
+ 165,3.609298479178552e-01,5.241104172261676e-01
+ 166,8.532138186195668e-01,1.441912290240859e-01
+ 167,5.288021685433005e-01,4.131413185821221e-01
+ 168,1.732682032855901e-01,8.479905383027070e-01
+ 169,7.588520135426929e-01,2.737018417167228e-02
+ 170,5.156100763340267e-01,4.093759872501865e-01
+ 171,4.699916404966871e-01,6.694071858544223e-01
+ 172,5.949405987075271e-01,4.540394712440837e-01
+ 173,4.212066804638444e-01,6.229994458393530e-01
+ 174,3.940918359973753e-01,4.273771075330711e-01
+ 175,1.776368127147945e-01,8.896808988551878e-01
+ 176,6.881343262706968e-01,3.225147483405492e-01
+ 177,3.917159646177190e-01,7.646580100506276e-01
+ 178,9.000256775853520e-01,1.472106797477414e-01
+ 179,8.111404157434636e-01,1.297071859317386e-01
+ 180,2.101219019467270e-01,8.146968364052304e-01
+ 181,1.487838612546366e-01,8.222876965722250e-01
+ 182,7.347960921701500e-01,2.720436677913221e-01
+ 183,3.146936520527804e-01,8.405297708973022e-01
+ 184,5.277597556748479e-01,3.584488492934021e-01
+ 185,2.392822307534025e-01,7.371678974059825e-01
+ 186,3.921184353320953e-01,5.613551234508802e-01
+ 187,7.770440996702246e-01,3.040444924330335e-01
+ 188,1.556502939407011e-01,6.758671108962976e-01
+ 189,8.603882634005786e-01,1.018668211585512e-01
+ 190,6.665829071976751e-01,2.356299014415456e-01
+ 191,8.959525463727140e-01,2.250989525664377e-01
+ 192,4.045665587333609e-01,6.023196646785495e-01
+ 193,2.167302444630066e-01,6.753211088388703e-01
+ 194,8.478085086215593e-01,2.265348599405389e-01
+ 195,5.691390320986602e-01,3.569343688303234e-01
+ 196,2.568919415745824e-01,7.049679828547590e-01
+ 197,7.631764619663421e-01,2.127756146317059e-01
+ 198,4.735182704663453e-01,5.257593558527963e-01
+ 199,7.699076903980367e-01,3.186008134263619e-01
+ 200,6.353591511413547e-01,3.128596254849491e-01
+ 201,4.417174315356298e-01,5.376033990038541e-01
+ 202,2.910961115564770e-01,7.203001932306888e-01
+ 203,8.305432152090337e-01,9.283557843322277e-02
+ 204,5.595205306936523e-01,5.027633340846359e-01
+ 205,2.237541411146173e-01,7.512988320128657e-01
+ 206,3.464377018439936e-01,5.798987804441686e-01
+ 207,1.509726259054747e-01,8.846022371550152e-01
+ 208,8.298984516261825e-01,2.494922693795423e-01
+ 209,5.548446147341471e-01,3.602241935872604e-01
+ 210,7.105180103063604e-01,3.793142776381044e-01
+ 211,5.414116623845462e-01,5.520351743881919e-01
+ 212,6.685572008485271e-01,4.459235428939342e-01
+ 213,7.652387218588139e-01,1.900516941431293e-01
+ 214,4.012729892913592e-01,7.335545348845832e-01
+ 215,5.663525316219551e-01,4.953562267979097e-01
+ 216,2.237187694401419e-01,6.324687182124706e-01
+ 217,6.551963779333568e-01,4.788853290382320e-01
+ 218,2.753441708792052e-01,6.831551156968910e-01
+ 219,1.099126838457177e-01,8.872435551900496e-01
+ 220,9.413449890822709e-02,8.825129708780702e-01
+ 221,4.897095010373260e-01,6.156130864707564e-01
+ 222,5.598819205346740e-01,3.837795488231879e-01
+ 223,8.006515758724178e-01,1.394103792691356e-01
+ 224,5.224517812865721e-01,5.666070378654043e-01
+ 225,3.150975392568989e-01,8.094469640459785e-01
+ 226,4.853758202489572e-01,5.107198771447283e-01
+ 227,3.464009653030199e-01,6.556380395136718e-01
+ 228,3.419375674885387e-01,5.709515153481730e-01
+ 229,2.010468838928394e-01,8.014642690671379e-01
+ 230,8.725552147729628e-01,2.057587520496834e-01
+ 231,4.690462280805725e-01,4.924451365379539e-01
+ 232,1.875854443806629e-01,7.516772484464147e-01
+ 233,3.189695420638902e-01,8.464173892853476e-01
+ 234,9.736811565883066e-01,1.781927643765294e-02
+ 235,4.528384409334779e-01,6.144703635838121e-01
+ 236,5.402628070184096e-01,3.750624187775164e-01
+ 237,2.724822596923511e-01,7.964157793171789e-01
+ 238,4.364528848972652e-01,5.294799601472743e-01
+ 239,4.876847285146015e-01,5.421518318659675e-01
+ 240,9.366184172725367e-02,8.996176968138223e-01
+ 241,5.229348356343639e-01,5.877847660021027e-01
+ 242,5.328001825373900e-01,4.409603986764795e-01
+ 243,5.944088988613400e-01,5.607693635585865e-01
+ 244,7.303158714363011e-01,3.132066308020284e-01
+ 245,3.690571782990881e-01,5.930201599317442e-01
+ 246,4.798676316322791e-01,5.165933597343917e-01
+ 247,9.578027614600101e-01,6.370127768980632e-03
+ 248,8.201870994221644e-01,3.972900203286428e-02
+ 249,5.816698903121965e-01,5.220114394902651e-01
+ 250,3.002628689047525e-01,7.198464084008022e-01
+ 251,6.182693426472677e-02,8.926602380963425e-01
+ 252,8.395874771467087e-01,2.309467114581434e-01
+ 253,2.338851296241580e-01,7.730451443366196e-01
+ 254,1.123331122069012e-01,9.524150407973110e-01
+ 255,2.749841770324233e-01,7.689996017103320e-01
+ 256,8.349990388822156e-01,1.857651250943650e-01
+ 257,6.004980883380043e-01,3.807090742607059e-01
+ 258,2.333690887745851e-01,5.779657851140572e-01
+ 259,1.095690458840429e-01,8.899988832277979e-01
+ 260,6.792145064650051e-01,2.200647977636927e-01
+ 261,3.707734231386780e-01,7.604061983267546e-01
+ 262,6.998522536229924e-01,2.749322402384720e-01
+ 263,2.022682452641018e-01,8.691945428450052e-01
+ 264,6.317005856226215e-01,4.400418210689935e-01
+ 265,2.750640809577642e-01,7.657558659317623e-01
+ 266,5.708804993166904e-01,1.988619891655358e-01
+ 267,3.027469246301107e-01,7.344494283874884e-01
+ 268,6.869927576033001e-01,2.401775979342197e-01
+ 269,5.459421094733874e-01,5.872115017230444e-01
+ 270,8.235378695899356e-01,2.674576028426423e-01
+ 271,2.191871341096068e-01,8.037642963093650e-01
+ 272,1.453846976279584e-01,8.104067195503318e-01
+ 273,7.974085752811636e-01,1.275008015724056e-01
+ 274,1.509780098924031e-01,9.709887667576701e-01
+ 275,4.578811812024209e-01,6.615003894984681e-01
+ 276,2.047468510032111e-01,6.932386052666374e-01
+ 277,9.005463820746092e-01,3.096927446092755e-03
+ 278,4.881821033538993e-01,4.575246737790116e-01
+ 279,5.868353204877876e-01,5.606451953052467e-01
+ 280,1.368112192249148e-01,8.245825818256846e-01
+ 281,7.124968045168899e-01,3.842901750752610e-01
+ 282,8.559174666843031e-01,1.347202018086349e-02
+ 283,4.633068011540515e-01,3.689649335248825e-01
+ 284,8.303044262725788e-01,1.872568487431125e-01
+ 285,2.001134993475214e-01,8.781317572118954e-01
+ 286,5.174958364446367e-01,4.993498337426717e-01
+ 287,5.799041154812818e-01,3.830450954345643e-01
+ 288,4.187485446112437e-01,4.616650513469409e-01
+ 289,8.187122433206055e-01,2.460576193561029e-01
+ 290,1.737850519567180e-01,8.659015905325322e-01
+ 291,7.617162577730396e-01,2.629413393828872e-01
+ 292,1.897435680163178e-02,9.858687415449049e-01
+ 293,9.784490321728998e-01,2.466705756280004e-02
+ 294,1.546412463739706e-01,8.890856079831497e-01
+ 295,4.777237692417397e-01,5.277779936470436e-01
+ 296,2.039071162873567e-01,8.246296814987145e-01
+ 297,6.954295519053439e-01,3.456920779566723e-01
+ 298,9.186933669281070e-01,8.091132043803310e-02
+ 299,2.196864787520779e-01,7.929978915284842e-01
+ 300,7.821006051799317e-01,1.677829914191160e-01
+ 301,1.077203096732735e-01,8.286804925986643e-01
+ 302,2.394338692041341e-01,7.812204696055217e-01
+ 303,6.624086387456243e-02,9.409408438596090e-01
+ 304,1.605116159349091e-01,7.417761413153949e-01
+ 305,7.498193896270564e-01,2.640967510344795e-01
+ 306,5.576425234116415e-02,9.018521441590758e-01
+ 307,3.248616535427674e-01,5.461355509976840e-01
+ 308,2.231300554372089e-01,6.707908029816335e-01
+ 309,6.776059349213052e-01,3.243248370572346e-01
+ 310,4.728858376886844e-01,5.255160686130806e-01
+ 311,5.341675333477263e-01,5.028674032292165e-01
+ 312,5.924401072869164e-01,3.993450721448442e-01
+ 313,7.352743862839569e-01,4.031199584173480e-01
+ 314,6.875665459566419e-01,3.212819357814515e-01
+ 315,7.352328338659138e-01,2.442139691889113e-01
+ 316,4.109843398541622e-01,7.670733219356447e-01
+ 317,3.608664023239337e-01,5.037132008830130e-01
+ 318,2.359587993040150e-01,6.595646491996499e-01
+ 319,7.845483941444684e-01,2.354709320686667e-01
+ 320,5.176526162467316e-01,3.981217802183232e-01
+ 321,6.787082502991891e-01,1.943762527900831e-01
+ 322,5.455330733673923e-02,9.364265692611291e-01
+ 323,3.835399737908655e-01,6.069961546471516e-01
+ 324,6.398939829741103e-01,4.303333901007359e-01
+ 325,7.981115194243165e-01,1.778696792814078e-01
+ 326,8.473236167667729e-01,1.457576543739458e-01
+ 327,7.748266857649472e-01,3.781205452305058e-01
+ 328,6.766392484267049e-01,4.181853105563046e-01
+ 329,5.523560268216884e-01,4.649311056718211e-01
+ 330,5.428851026599331e-01,5.518500013927592e-01
+ 331,5.974001315984400e-01,3.792630653545719e-01
+ 332,4.371221769842284e-01,6.770799527623425e-01
+ 333,7.674468758896628e-01,1.946166054254059e-01
+ 334,3.596806258057451e-01,6.282084170888698e-01
+ 335,6.832621399997215e-01,3.082895101411250e-01
+ 336,8.451875304892172e-01,1.041105708480824e-01
+ 337,3.042446525656562e-01,6.055533126308318e-01
+ 338,1.697648383006878e-01,8.516793484327785e-01
+ 339,6.326138385911527e-01,4.122481824233429e-01
+ 340,7.341382655480002e-01,1.982729014538535e-01
+ 341,7.808623410473720e-01,2.623726775504981e-01
+ 342,3.582797364511770e-01,5.789014589577893e-01
+ 343,1.704159758917930e-02,9.965925176418737e-01
+ 344,9.422212314385575e-01,1.151355191419356e-01
+ 345,2.451663077024119e-01,8.791369026105403e-01
+ 346,4.221032256415202e-01,5.595476957884455e-01
+ 347,5.011597690239125e-01,5.612549571311594e-01
+ 348,5.536334305274664e-01,4.411792132852605e-01
+ 349,1.877177712548215e-01,8.599408519635559e-01
+ 350,6.422305177488105e-01,3.312396328095313e-01
+ 351,3.660211893169489e-01,6.465560145286148e-01
+ 352,6.212064454973893e-01,4.428560169923815e-01
+ 353,5.863971489701705e-01,4.801333501636684e-01
+ 354,3.286528859917172e-01,6.292997210237192e-01
+ 355,2.472958985496114e-01,7.287167256185422e-01
+ 356,7.787333231052596e-01,2.291203872238323e-01
+ 357,3.610545931746370e-01,4.851625230947471e-01
+ 358,5.202368104392062e-01,4.820729933740129e-01
+ 359,4.243757209575323e-01,4.886073325598324e-01
+ 360,7.321317980705259e-01,1.943237416628577e-01
+ 361,5.714747239165195e-01,4.654734211574502e-01
+ 362,5.718457551404617e-01,4.153877373217669e-01
+ 363,6.755313286278422e-01,3.128340427678512e-01
+ 364,3.106282090136242e-01,6.577919953289143e-01
+ 365,6.805517777847899e-01,2.087852808860307e-01
+ 366,7.836294838565259e-02,9.062233265958087e-01
+ 367,4.690299165985822e-01,5.525746747323677e-01
+ 368,9.452836673062566e-02,8.848066021392598e-01
+ 369,1.211182206745650e-01,9.649395690280512e-01
+ 370,8.351427525298590e-01,2.177053041131850e-01
+ 371,7.643919467240516e-01,2.657350674398890e-01
+ 372,7.587592442455915e-01,2.497984562716347e-01
+ 373,9.747397566319446e-01,5.585972091365619e-03
+ 374,8.531912483061366e-01,3.509515017153871e-02
+ 375,1.339117751385523e-01,9.064786139979786e-01
+ 376,8.130268892223355e-01,7.498989746226509e-02
+ 377,5.265128405918457e-02,8.605985240312050e-01
+ 378,8.997834432880457e-01,2.182928307831889e-01
+ 379,7.294723234818981e-02,9.079844953242397e-01
+ 380,1.718349431851979e-02,9.849059205444378e-01
+ 381,6.145305685681707e-01,4.475954521676387e-01
+ 382,8.464393019564975e-01,2.746055754731714e-01
+ 383,9.384970402077549e-01,2.299813662451212e-02
+ 384,8.340263648581904e-01,3.183951657429534e-01
+ 385,4.365236161979116e-01,3.492752384401963e-01
+ 386,8.021951326368378e-01,1.152133880297691e-01
+ 387,4.506880659848789e-01,6.702876509259004e-01
+ 388,5.867855021988619e-01,4.525052097239997e-01
+ 389,8.764994247386154e-01,1.921907633284295e-01
+ 390,4.324179619548894e-01,5.255233251838930e-01
+ 391,3.853954032205674e-01,6.415242220258270e-01
+ 392,8.812977591606190e-01,3.947045169970781e-02
+ 393,2.355385034689540e-02,8.569616519751889e-01
+ 394,4.750394322186847e-01,5.297528754034836e-01
+ 395,7.337038424257567e-01,4.022388861290467e-01
+ 396,4.993511691402590e-01,3.870708624047073e-01
+ 397,2.396897835619063e-01,5.927072614620179e-01
+ 398,5.379734662549593e-01,4.675792977206785e-01
+ 399,1.064284579236476e-01,8.065203387554390e-01
+ 400,6.571924689249852e-01,3.939444339039348e-01
+ 401,5.883552077349042e-01,1.968658322975371e-01
+ 402,6.168459009141662e-01,4.887112783686678e-01
+ 403,3.452450039434308e-01,7.319855268447122e-01
+ 404,1.646385969651550e-01,8.883237505753663e-01
+ 405,5.714099729410197e-01,5.364450524776364e-01
+ 406,1.918040990099582e-02,9.486720697070441e-01
+ 407,4.060090150358100e-01,6.934963456756361e-01
+ 408,7.675643532404707e-01,2.061973154865306e-01
+ 409,1.507332456788248e-01,8.971433519972336e-01
+ 410,1.424424103367315e-01,6.301909316685654e-01
+ 411,4.392520294206340e-01,5.968619088352755e-01
+ 412,7.076192311274284e-01,3.865993308079120e-01
+ 413,3.323736999558279e-01,7.928373877400591e-01
+ 414,7.139636801636023e-01,3.058331386896590e-01
+ 415,7.347349615463917e-01,4.100308764151518e-01
+ 416,4.730984684662948e-01,4.170018392063469e-01
+ 417,6.346813788854211e-01,3.883730225543743e-01
+ 418,4.640577972356416e-01,5.775363613313472e-01
+ 419,8.769418668047190e-01,1.498017620684963e-01
+ 420,2.347814542223045e-01,7.734785979670475e-01
+ 421,1.505319418584910e-01,7.486717584572768e-01
+ 422,5.329141412521654e-01,4.536978183048582e-01
+ 423,3.921666379024091e-01,5.821604752545709e-01
+ 424,3.879773157245416e-01,5.320693571617177e-01
+ 425,4.035543658266227e-01,6.081178582909781e-01
+ 426,2.398451444423527e-01,6.443467527746105e-01
+ 427,5.762629998286479e-01,4.896811804438457e-01
+ 428,5.227407721127439e-01,4.326614859903808e-01
+ 429,2.336105678403516e-01,6.499343110231658e-01
+ 430,8.063900600230670e-01,2.411566715788119e-01
+ 431,5.498259878165899e-01,5.041976717250032e-01
+ 432,8.303685965465990e-01,1.907281320113221e-01
+ 433,4.158320022727128e-01,5.073326728589592e-01
+ 434,8.818577602623128e-01,1.839724474309987e-01
+ 435,2.865998859834379e-01,7.221258395618270e-01
+ 436,4.866017165033234e-01,6.719385459067244e-01
+ 437,8.163614904059342e-01,1.559489802311445e-01
+ 438,1.501140666645703e-01,9.199858491339193e-01
+ 439,2.269742284441675e-01,7.378391166901591e-01
+ 440,2.321915491122740e-01,8.307372589551524e-01
+ 441,1.174060783070365e-01,8.310645222780150e-01
+ 442,6.990608785357409e-02,8.228980541842069e-01
+ 443,2.957804236125898e-01,7.359290198695347e-01
+ 444,3.907458881452824e-01,7.498791441284401e-01
+ 445,3.087295931803152e-01,5.840405577565625e-01
+ 446,5.225734855166069e-01,5.771280148723582e-01
+ 447,4.341000209182955e-01,6.061445059123203e-01
+ 448,3.025857402198789e-01,6.394722263958423e-01
+ 449,4.965587095821780e-01,4.787271082365162e-01
+ 450,4.678704049523337e-01,4.401177494117897e-01
+ 451,4.533060920639616e-01,5.583560545224955e-01
+ 452,9.406759392793647e-01,2.550787049623260e-01
+ 453,7.614664611405921e-01,1.307314984775221e-01
+ 454,1.341852482281138e-01,9.984270680043460e-01
+ 455,4.349269316318611e-01,4.929379581040529e-01
+ 456,3.485694343610253e-01,6.752174763432126e-01
+ 457,2.360248050467678e-01,7.286644432946886e-01
+ 458,5.810574044197463e-01,3.772000238924267e-01
+ 459,6.314209272956207e-01,2.187182938887103e-01
+ 460,4.631219612088938e-01,5.445178619656634e-01
+ 461,2.726840928863228e-01,6.192537010331545e-01
+ 462,6.320406325208916e-01,3.573150195239566e-01
+ 463,7.427014674392087e-01,3.667733816452494e-01
+ 464,3.583674489159720e-01,5.220477707255120e-01
+ 465,4.884078704169467e-01,5.583815993067002e-01
+ 466,5.993265770115622e-01,2.975365141341714e-01
+ 467,2.166779029289395e-01,7.787703180558136e-01
+ 468,2.336947936283285e-01,5.688193277593753e-01
+ 469,9.684264823592359e-01,1.278800465040934e-01
+ 470,7.659271578917280e-01,1.677048218601221e-01
+ 471,4.024674539688660e-01,5.202948413040008e-01
+ 472,8.878166880784673e-01,2.446467859650831e-01
+ 473,6.462124600196338e-01,4.098059654297933e-01
+ 474,3.076706894238137e-01,6.926075437387538e-01
+ 475,3.292705569703751e-01,5.708244167990184e-01
+ 476,1.339068176703948e-01,8.405982256346761e-01
+ 477,2.182425008112785e-01,8.546984343706134e-01
+ 478,2.567894315667774e-01,7.064864491241705e-01
+ 479,7.479598555917778e-01,3.087803441548206e-01
+ 480,6.609237477335053e-01,2.416805444068080e-01
+ 481,8.433654187263853e-01,2.096026068550454e-01
+ 482,5.120254344427738e-01,5.103697147514247e-01
+ 483,8.658861623707647e-01,2.048551931977510e-01
+ 484,4.995470907895381e-01,5.329205592423504e-01
+ 485,8.809671193701519e-01,8.940042308406068e-02
+ 486,6.461806477164881e-01,2.405398636333864e-01
+ 487,4.080141040995134e-01,6.876391498629214e-01
+ 488,1.675451442514530e-01,7.318182921274101e-01
+ 489,7.446931602823305e-01,1.366782265937067e-01
+ 490,4.769454508313226e-01,4.509360351892941e-01
+ 491,6.397972311800205e-01,4.058072284721620e-01
+ 492,4.542188425246602e-01,5.018717047933313e-01
+ 493,7.181406998190687e-01,2.320754660567375e-01
+ 494,8.482442861625665e-01,9.828598214607652e-02
+ 495,2.824652660721581e-01,6.548619559823528e-01
+ 496,2.888020979835756e-01,6.987842713993807e-01
+ 497,1.390548998099003e-01,8.665061821957065e-01
+ 498,4.889746920258386e-01,5.520750816040947e-01
+ 499,5.597645659230066e-02,9.942318894955924e-01
+ 500,4.581796981456392e-01,5.338272843332983e-01
+ 501,5.634658176903987e-01,5.107186992158047e-01
+ 502,3.697469460433191e-01,5.696708613914058e-01
+ 503,8.086095138891249e-01,2.940666854809433e-01
+ 504,3.657288480362376e-01,6.494595116262748e-01
+ 505,7.294694374308247e-01,3.638274413897541e-01
+ 506,3.974059521154653e-01,5.839750482835256e-01
+ 507,4.295911738536566e-01,6.590215317731537e-01
+ 508,1.365555791559236e-01,7.820844905085199e-01
+ 509,6.541635388707704e-01,2.971506195725820e-01
+ 510,8.596793673584699e-02,9.341555178216319e-01
+ 511,4.271150162571528e-01,5.572322727368170e-01
+ 512,9.502337232230789e-01,1.231285392261619e-01
+ 513,8.774929771777834e-01,6.383897013366445e-02
+ 514,7.279327280493526e-01,3.844600359594341e-01
+ 515,7.675003872628630e-01,2.609050948162284e-01
+ 516,7.701756618656426e-01,2.887928367273838e-01
+ 517,6.109923991242571e-01,4.064741372577078e-01
+ 518,2.202352726384090e-01,8.131080210424050e-01
+ 519,2.061320568358481e-01,8.493334328159109e-01
+ 520,9.242769760138971e-02,8.201675965798345e-01
+ 521,6.820875701706440e-01,3.742304189879481e-01
+ 522,8.407559180584993e-01,7.871850010145111e-02
+ 523,2.832464503628167e-01,6.209779954031258e-01
+ 524,4.266835151092729e-01,4.256391774943711e-01
+ 525,2.444648374217792e-01,8.310680811765062e-01
+ 526,5.104344982702329e-01,5.313654344675087e-01
+ 527,4.438456631462154e-01,5.888366821565673e-01
+ 528,1.379224506260056e-01,8.186248300496703e-01
+ 529,4.937910445538760e-01,4.201055930643072e-01
+ 530,2.019063947544750e-01,7.505398598145283e-01
+ 531,5.584027877745228e-01,3.201323947334352e-01
+ 532,7.792495255415454e-01,3.190105577012057e-01
+ 533,1.265452299732086e-01,7.411096209044521e-01
+ 534,3.718424123431873e-01,4.143193706697599e-01
+ 535,1.627880912751113e-01,7.951757743825193e-01
+ 536,8.972101556364923e-01,1.987043485497181e-01
+ 537,8.869921369117904e-01,1.191274108909097e-01
+ 538,5.585784885282421e-01,3.045514999147698e-01
+ 539,5.829266705428816e-01,4.649770308708069e-01
+ 540,4.903240900006806e-01,5.419297217323034e-01
+ 541,4.693489826886342e-01,5.975118561357184e-01
+ 542,2.059263273756012e-02,9.255537478593021e-01
+ 543,8.117076048053159e-01,3.592095116043138e-02
+ 544,8.165092085931687e-01,2.529992445329782e-01
+ 545,5.335317169953314e-01,5.307169704282396e-01
+ 546,4.168584236280895e-01,5.287659997927237e-01
+ 547,8.068073702385209e-01,2.826224201900533e-01
+ 548,8.892183797654456e-01,2.101171508595906e-01
+ 549,7.855017868472985e-01,3.105132486826400e-01
+ 550,9.450111689405526e-01,1.160507599127135e-01
+ 551,6.800581961358326e-01,2.554173081703786e-01
+ 552,3.750879547849306e-01,6.828624151393532e-01
+ 553,6.631943380558641e-01,3.832603790216626e-01
+ 554,1.163062348153083e-01,8.307950463397950e-01
+ 555,3.237852247874483e-02,8.592167452391036e-01
+ 556,8.620782013421601e-01,2.110493006465276e-01
+ 557,6.027288810097297e-01,3.616823825606515e-01
+ 558,1.390627517875940e-02,8.944125148812363e-01
+ 559,4.437505006039492e-01,4.998869764097854e-01
+ 560,8.720439452471487e-01,2.343643501404435e-01
+ 561,6.060025088323414e-01,4.202532169076119e-01
+ 562,4.047521130819732e-01,4.772863140694737e-01
+ 563,5.948214251643402e-01,4.398563088294436e-01
+ 564,3.805917832447754e-01,5.859817232557533e-01
+ 565,3.820569207168972e-01,6.664219477075974e-01
+ 566,4.616068026582582e-01,4.158319932703238e-01
+ 567,1.338967425861196e-01,8.786492052201131e-01
+ 568,3.661416863496332e-01,6.363598864830655e-01
+ 569,3.070579544188331e-01,7.241404732588795e-01
+ 570,5.424153673412779e-01,3.826679572086358e-01
+ 571,3.509664777448746e-01,6.589404149244694e-01
+ 572,1.771931952151179e-01,7.463609463281695e-01
+ 573,1.618764628237002e-01,8.932388992491825e-01
+ 574,1.800945095598025e-01,9.477122668969528e-01
+ 575,7.743412012949984e-01,1.020503259292055e-01
+ 576,6.022070562578488e-01,4.945873462856661e-01
+ 577,3.821411330577952e-01,5.443426571817492e-01
+ 578,6.413919446299010e-01,2.811987093281730e-01
+ 579,5.974515362269076e-01,2.450498571802882e-01
+ 580,4.645270528064824e-01,5.911580131389814e-01
+ 581,4.593231092211139e-01,6.018022973371042e-01
+ 582,9.208742465090777e-01,2.120653080709157e-01
+ 583,5.947355105345223e-01,4.879859528309833e-01
+ 584,2.594541763859526e-01,8.562177542309266e-01
+ 585,2.818280958611942e-01,6.131838282971275e-01
+ 586,4.130950913495970e-01,5.391631007085549e-01
+ 587,4.171138740222004e-01,4.012729886849936e-01
+ 588,2.918881156084038e-01,6.857496531430588e-01
+ 589,7.007052244166097e-01,4.575441539778419e-01
+ 590,1.592386655448894e-01,8.097095384333703e-01
+ 591,8.007661009542046e-01,2.440306927106615e-01
+ 592,1.124142522954000e-02,8.339300465232319e-01
+ 593,4.443977217153425e-01,6.484654648620841e-01
+ 594,5.457183355487717e-01,4.035529395850252e-01
+ 595,3.404344217367695e-01,7.259562146711825e-01
+ 596,8.270388239471950e-01,1.704374755389945e-01
+ 597,4.951606964403780e-01,4.098465898231001e-01
+ 598,7.214800129608688e-01,4.309964650513213e-01
+ 599,5.283983151863810e-01,4.863233409998404e-01
+ 600,1.340567776987407e-01,8.000438889360445e-01
+ 601,2.322644052855017e-01,8.145077974459680e-01
+ 602,6.080190094120982e-01,3.195166938822857e-01
+ 603,3.405846915860566e-01,6.308022116766655e-01
+ 604,6.592481213296999e-01,4.122130327739491e-01
+ 605,6.504299273607097e-01,2.025566852384719e-01
+ 606,7.134519014470672e-01,1.074236461405912e-01
+ 607,4.501333537868347e-01,4.934730850782463e-01
+ 608,2.827121303126533e-01,8.966469016896362e-01
+ 609,2.763535985369157e-01,7.969019987617024e-01
+ 610,5.807842067847455e-01,3.301051232997939e-01
+ 611,4.824690215454162e-01,5.267700471017656e-01
+ 612,2.401150096196421e-01,8.063147466934993e-01
+ 613,3.217163848742371e-01,6.586475859330652e-01
+ 614,4.461594571960062e-01,4.080877637220242e-01
+ 615,5.602072011920730e-01,5.155467036058805e-01
+ 616,2.664904821902188e-01,4.834128917732462e-01
+ 617,5.354362887855446e-01,4.702793885765689e-01
+ 618,4.967733908219880e-01,4.869121610025346e-01
+ 619,1.984826988380623e-01,7.395070885256906e-01
+ 620,6.383889615536927e-01,4.000596543175756e-01
+ 621,3.698948319614241e-01,8.463048486035941e-01
+ 622,1.670040356804498e-01,8.676119938853700e-01
+ 623,6.907380503340504e-01,3.417830064685147e-01
+ 624,5.675896935081595e-01,2.888646731654571e-01
+ 625,2.330001955207892e-01,9.342407339200733e-01
+ 626,7.143226859552739e-01,2.123882523857309e-01
+ 627,1.979478589030319e-01,8.771871602353312e-01
+ 628,4.819377839034144e-01,4.488350374444851e-01
+ 629,4.097200190488774e-01,5.179254845383574e-01
+ 630,6.230024491927922e-01,3.875547394645796e-01
+ 631,7.100301773112327e-01,1.761852405532895e-01
+ 632,2.385021741100900e-01,5.886611225611045e-01
+ 633,7.138406653380709e-01,3.988826898571301e-01
+ 634,3.487414169477150e-01,6.103317905683869e-01
+ 635,8.920671742526357e-02,8.866773744486462e-01
+ 636,3.749776252181532e-01,5.464405309872523e-01
+ 637,5.406391074124730e-01,4.695526887457462e-01
+ 638,1.953437557806451e-01,6.985615347276432e-01
+ 639,5.587403472083728e-01,2.816393806052192e-01
+ 640,2.338330712834534e-01,6.171670551372221e-01
+ 641,8.546717695559798e-01,1.282029507157938e-01
+ 642,2.746719757458963e-01,6.792340688682509e-01
+ 643,7.857267762539009e-01,1.215962335807190e-01
+ 644,3.497635225529750e-01,7.386529024561665e-01
+ 645,9.114748661610496e-01,7.966334245352201e-02
+ 646,8.309676605138652e-01,3.543092657183000e-01
+ 647,2.958009291104265e-01,8.609994897055216e-01
+ 648,5.369247695626864e-01,5.794667459672104e-01
+ 649,1.532960851657434e-01,8.928249358899294e-01
+ 650,2.066780760086865e-01,9.273178689206208e-01
+ 651,5.476931482137527e-01,4.014485618666748e-01
+ 652,4.983911353444258e-01,3.960397915685496e-01
+ 653,6.678970134446011e-01,3.918715550359889e-01
+ 654,2.182067681496201e-01,9.026056780184507e-01
+ 655,7.276806811992023e-01,5.032384417594711e-01
+ 656,8.325315808628670e-01,1.504423088485889e-01
+ 657,3.280629625833396e-01,6.044000060547322e-01
+ 658,6.538764266925758e-01,2.552566647176424e-01
+ 659,4.089457588418315e-01,6.934575549422849e-01
+ 660,1.716329048988758e-02,9.044031592002101e-01
+ 661,9.408783823338947e-02,9.236874117139892e-01
+ 662,2.117188023146390e-01,7.381020827474952e-01
+ 663,1.398676229413746e-01,9.493564041042664e-01
+ 664,9.098313339483839e-02,8.171807026330439e-01
+ 665,5.145264410562215e-01,5.579455312996174e-01
+ 666,6.849437232155232e-01,3.814156089959599e-01
+ 667,3.769061183050105e-01,4.805995513683535e-01
+ 668,5.432352216736263e-01,3.649692159827971e-01
+ 669,7.866047855602796e-01,1.579576430447937e-01
+ 670,5.842161192703331e-01,3.297805751827259e-01
+ 671,5.265631203147897e-01,5.729522039183951e-01
+ 672,2.826916699901907e-01,6.469067096243852e-01
+ 673,6.585592950160898e-01,3.421164063264376e-01
+ 674,6.999188986351603e-01,3.218933866716156e-01
+ 675,6.131660442745462e-01,4.045700073921915e-01
+ 676,8.024642980404361e-01,2.818430556319682e-01
+ 677,4.333050319663282e-01,5.948738481543828e-01
+ 678,9.097443634365743e-01,7.963606341858447e-02
+ 679,6.013467793122448e-02,9.083251093669835e-01
+ 680,4.513198572050420e-01,4.209006779159875e-01
+ 681,4.208336946190573e-01,6.389264350700700e-01
+ 682,5.029602560267151e-01,3.857530852829955e-01
+ 683,5.560489675871847e-01,4.138586912719284e-01
+ 684,8.119455103990193e-01,2.337302514259245e-01
+ 685,6.859222886408134e-01,2.443583372632963e-01
+ 686,5.751741328331254e-01,3.475306085672484e-01
+ 687,1.248181567624389e-01,9.393528598329670e-01
+ 688,5.492230312313566e-01,4.132756937938589e-01
+ 689,8.858206522552041e-01,2.199500723091695e-01
+ 690,5.000215136935667e-01,4.759730091337976e-01
+ 691,7.899378916511297e-01,1.313575899297831e-01
+ 692,3.067289756091452e-01,6.106257944735347e-01
+ 693,1.937526536047939e-01,8.536402906405226e-01
+ 694,5.980988316704025e-01,4.794432586885283e-01
+ 695,8.529373873469670e-01,1.959989540993621e-01
+ 696,8.642264972854575e-01,1.221394446434125e-01
+ 697,6.015256642839629e-01,5.578782265884443e-01
+ 698,5.398066163310592e-01,5.447666013759626e-01
+ 699,2.814906309432997e-01,7.795414663285140e-01
+ 700,3.679647696681051e-01,5.708326893097047e-01
+ 701,3.536967207847683e-02,8.129527434588741e-01
+ 702,7.695187504676986e-01,2.159967812213149e-01
+ 703,6.337619181479979e-01,4.479443513402248e-01
+ 704,8.531159539306523e-03,7.497595920689175e-01
+ 705,7.218469718477227e-01,2.430887457745313e-01
+ 706,4.654269134379282e-01,4.305521953845940e-01
+ 707,9.042117523019312e-02,8.619580367250664e-01
+ 708,7.011663593574662e-01,4.540401641236102e-01
+ 709,7.834723965560484e-01,2.823142324973058e-01
+ 710,6.151837663996612e-01,4.309173151560950e-01
+ 711,5.428834542378913e-01,2.864027429994467e-01
+ 712,8.419095443939571e-02,8.281037761414638e-01
+ 713,5.696271554233278e-01,4.998074997407775e-01
+ 714,9.264623306668363e-01,6.192791394107977e-03
+ 715,3.057148344601362e-01,6.230203368737824e-01
+ 716,6.597818741081490e-01,3.407129525935512e-01
+ 717,8.652275598823957e-01,1.949758849403904e-01
+ 718,2.782562934030456e-01,6.343630736429036e-01
+ 719,1.869845551276218e-01,6.678658163670425e-01
+ 720,1.514989610054626e-01,9.463129903420766e-01
+ 721,6.164475892463611e-01,3.470989368893047e-01
+ 722,6.260360627937293e-01,4.079377380554282e-01
+ 723,5.389475066980175e-01,5.271270262551081e-01
+ 724,5.087536499592006e-01,5.099255437361916e-01
+ 725,4.660344833485595e-01,4.447867591006969e-01
+ 726,8.974966650184106e-01,1.210309226331101e-01
+ 727,5.946700954272478e-01,4.412180013339689e-01
+ 728,3.800966616097187e-02,9.195848691716333e-01
+ 729,4.394401282013330e-01,6.411527791028875e-01
+ 730,5.956282625208604e-01,5.146595742833282e-01
+ 731,5.292092100716562e-01,3.579597390352857e-01
+ 732,4.947739573685626e-01,5.197366788560867e-01
+ 733,7.448190819968318e-01,1.529945941135503e-01
+ 734,8.452149194472073e-01,1.158170430311859e-01
+ 735,4.014976901110036e-01,5.788241416094065e-01
+ 736,7.221092190593564e-01,1.380657899939256e-01
+ 737,2.566158586924133e-01,7.429260799227153e-01
+ 738,5.810628750401171e-01,5.162106698792217e-01
+ 739,3.970358922644925e-01,6.454792480149436e-01
+ 740,4.334090661720331e-01,3.773136970018961e-01
+ 741,5.631868997517138e-01,5.109313537084952e-01
+ 742,4.940459745231639e-01,4.315214827781768e-01
+ 743,5.179384114787998e-01,5.476407202630124e-01
+ 744,7.644028865218306e-01,2.334070624200841e-01
+ 745,4.050952272079678e-02,9.866858271320038e-01
+ 746,1.874448495544474e-01,8.420442030964544e-01
+ 747,4.898620671437676e-01,4.442076263409188e-01
+ 748,9.255909792006235e-02,8.290023599198383e-01
+ 749,4.714164017842529e-01,6.007991054832008e-01
+ 750,6.543961959313683e-01,4.195901275370125e-01
+ 751,4.229980165530995e-01,5.058362497923056e-01
+ 752,8.554671538904959e-01,1.822376499527283e-01
+ 753,9.263913476925184e-01,3.105966031508756e-02
+ 754,3.445605376802817e-01,6.688391427814836e-01
+ 755,1.788696939577202e-02,8.391111897773271e-01
+ 756,6.340938981931827e-01,2.653445991375492e-01
+ 757,6.569218116981381e-01,3.066834665729284e-01
+ 758,5.638514593042071e-01,3.886779999728968e-01
+ 759,6.250041595922110e-02,9.527677390334706e-01
+ 760,6.217639186114252e-01,2.517403090166546e-01
+ 761,5.769064537188258e-01,4.692997298402211e-01
+ 762,7.906581586428861e-01,2.582033164203822e-01
+ 763,7.168780688295389e-01,2.940170874770927e-01
+ 764,1.378907231353353e-01,9.112490955298358e-01
+ 765,2.433253395977972e-01,7.056373462245394e-01
+ 766,5.416280097668984e-01,4.835924233785001e-01
+ 767,7.545920129337894e-01,3.678523077485432e-01
+ 768,3.122489917964577e-01,7.020393105271470e-01
+ 769,1.239383845445825e-01,8.810009545037736e-01
+ 770,2.689453703191101e-01,7.377819986429378e-01
+ 771,3.811661333909093e-01,6.260018178939215e-01
+ 772,8.422468499033287e-01,1.048167057025657e-01
+ 773,3.266988573145890e-01,6.991769449269293e-01
+ 774,8.838156644747561e-02,8.092150517042497e-01
+ 775,6.954717420253890e-01,2.506739393034398e-01
+ 776,4.381904842915326e-01,4.945718855787202e-01
+ 777,2.747654157189139e-01,6.400068219312540e-01
+ 778,6.368553039376519e-01,2.966822198368734e-01
+ 779,1.006977788971393e-01,7.474889587735108e-01
+ 780,8.465503604216855e-02,9.021499122564669e-01
+ 781,1.426058628006734e-01,8.030760934990695e-01
+ 782,1.411142749409789e-01,8.463970336453289e-01
+ 783,7.499802008223236e-01,2.764556607092140e-01
+ 784,5.213806435999185e-01,4.367205113841035e-01
+ 785,3.922714394452733e-01,5.534777670755374e-01
+ 786,8.190625419359291e-01,2.613088993046663e-01
+ 787,7.862111687368289e-01,3.372960671407784e-01
+ 788,4.595147388751609e-01,6.651597876917926e-01
+ 789,3.963698913851705e-01,5.649432822373339e-01
+ 790,2.568424324913237e-01,7.577179972052414e-01
+ 791,6.952342586155029e-01,2.618433247402072e-01
+ 792,3.182977216471297e-01,7.527297149124375e-01
+ 793,4.344320414657750e-01,5.046702498682275e-01
+ 794,9.919022211431224e-01,4.186981600431568e-02
+ 795,4.417798555779263e-01,5.416469919094948e-01
+ 796,4.224675836493644e-01,3.717141049434894e-01
+ 797,3.384333970586841e-01,7.357523776374620e-01
+ 798,8.148787280368656e-01,2.281807653206330e-01
+ 799,6.247931828054475e-01,3.306019061317148e-01
+ 800,5.599394217487201e-01,5.085259194373370e-01
+ 801,8.993183951940867e-02,8.114661131669958e-01
+ 802,3.823561977472532e-01,5.773563112998530e-01
+ 803,7.011244797893963e-01,2.587745904377649e-01
+ 804,9.183369977424900e-01,1.215224994972577e-01
+ 805,5.469800343309844e-02,8.914192581993019e-01
+ 806,7.580760657096099e-01,3.166761003775481e-01
+ 807,5.780647696918283e-01,4.475292517466037e-01
+ 808,9.374912287352478e-01,4.882623731031940e-02
+ 809,5.227489696117807e-01,7.563272520335990e-01
+ 810,2.273951931643383e-01,7.238570348501054e-01
+ 811,6.071197473728901e-01,3.259851592539805e-01
+ 812,2.879223331255618e-01,6.048382347348494e-01
+ 813,3.722511156368996e-01,4.891122513984786e-01
+ 814,9.258067613519142e-01,7.260434835714770e-02
+ 815,6.287529991167314e-01,3.946402024970951e-01
+ 816,4.330266436292743e-01,6.181665267604419e-01
+ 817,4.220418931291394e-01,5.087854232786705e-01
+ 818,5.121284480282072e-01,3.929412959091724e-01
+ 819,5.833202009387448e-01,3.221496546213085e-01
+ 820,4.256923135326111e-01,6.158083400150122e-01
+ 821,3.817625218895057e-01,5.314998832312291e-01
+ 822,1.802888926024669e-01,8.607546083370927e-01
+ 823,6.910299972482946e-02,8.194960004735952e-01
+ 824,5.234739195552128e-01,5.111702814707643e-01
+ 825,7.842603989671914e-01,2.039400828143275e-01
+ 826,9.047908194056263e-01,1.230941966224686e-01
+ 827,4.090257985132347e-01,6.930301873640817e-01
+ 828,2.816330252311609e-01,8.091142291684592e-01
+ 829,3.195772328753333e-01,5.988109773624947e-01
+ 830,4.364401656916765e-01,4.847700240096345e-01
+ 831,2.487831997651646e-01,6.992449043575768e-01
+ 832,8.738158389466769e-01,3.486761737488833e-02
+ 833,2.278572003914844e-01,7.953670424270066e-01
+ 834,7.482226468857042e-01,3.139566363045875e-01
+ 835,6.981330318542601e-01,3.319511664617174e-01
+ 836,4.453254191219941e-01,5.960750005618537e-01
+ 837,2.377732302343699e-01,6.905277626672072e-01
+ 838,3.706708312702562e-01,5.284952212229326e-01
+ 839,1.814886656166866e-01,8.837254293911966e-01
+ 840,4.361455356876059e-01,5.567573198143246e-01
+ 841,5.760513435544121e-01,5.053524482715287e-01
+ 842,8.471406229075097e-01,1.707626744254921e-01
+ 843,2.580463352678535e-01,7.772690550368003e-01
+ 844,8.662350884226596e-01,2.429267110136955e-01
+ 845,5.684247345838702e-01,3.989631593366091e-01
+ 846,8.190192047131732e-02,9.874815138914155e-01
+ 847,2.559256559482119e-01,7.525399413841496e-01
+ 848,6.314783822763731e-01,2.006019075221425e-01
+ 849,2.569974345229009e-01,5.935197932651749e-01
+ 850,3.538007703721561e-01,7.725571010272717e-01
+ 851,4.815454165605933e-01,5.975370261566062e-01
+ 852,6.308826891408033e-01,4.459328850144553e-01
+ 853,4.657086270511503e-01,6.801772282091016e-01
+ 854,3.815085014064781e-01,4.768099395317282e-01
+ 855,3.905429527859879e-01,7.016850068743105e-01
+ 856,7.433390621848591e-01,3.072596484976630e-01
+ 857,1.010534477162206e-01,7.497414762105427e-01
+ 858,2.394131255527739e-01,7.818573070054180e-01
+ 859,5.723099280045832e-01,2.850544424166273e-01
+ 860,2.591262877130387e-01,8.476956894820530e-01
+ 861,7.309592998798431e-01,3.981058153014507e-01
+ 862,8.960239912785068e-01,2.398193078035902e-01
+ 863,8.378159927981329e-01,2.748809639810681e-01
+ 864,1.247730331123149e-01,7.803513161302849e-01
+ 865,1.331220645796436e-01,8.621952275462446e-01
+ 866,9.748872088993072e-01,1.276736196271479e-01
+ 867,4.738861506793433e-01,6.329684626587203e-01
+ 868,5.475346136310919e-01,3.769723875934285e-01
+ 869,5.491806069274180e-01,4.816250012669682e-01
+ 870,6.407263712578588e-01,2.841637783635381e-01
+ 871,3.093222085483101e-01,7.028292174333441e-01
+ 872,5.439835329238093e-01,2.234580866211520e-01
+ 873,3.749794843192944e-01,5.064834179218420e-01
+ 874,1.332584947954112e-01,8.914611452854306e-01
+ 875,6.877250385939760e-01,2.773967684546436e-01
+ 876,6.322708608269354e-01,3.913313184744716e-01
+ 877,2.636753768005041e-01,7.286965321670523e-01
+ 878,5.520324183312698e-01,4.781072100924834e-01
+ 879,8.374766942536397e-01,2.602581948462322e-01
+ 880,6.365061033480088e-01,3.998669088248440e-01
+ 881,3.869390339546418e-02,9.539334508622576e-01
+ 882,3.707997225373666e-01,6.020820635483989e-01
+ 883,4.493217299070614e-01,5.233349923383613e-01
+ 884,4.693544972230830e-01,4.606044020557124e-01
+ 885,3.442756081606139e-02,9.852064000644177e-01
+ 886,9.651207774227630e-01,1.511603920204487e-01
+ 887,1.085846755081108e-01,7.507522097007757e-01
+ 888,6.779186656412503e-01,3.336580925184980e-01
+ 889,5.999613077808129e-01,4.420003542443601e-01
+ 890,6.092163564271587e-01,4.252643336136908e-01
+ 891,7.548489100410897e-01,1.099808389977396e-01
+ 892,7.041652359778464e-01,1.998254152642737e-01
+ 893,6.575987106312156e-01,2.813030439409502e-01
+ 894,2.085403165110662e-01,6.133950574629364e-01
+ 895,7.705540244085177e-01,3.033898929938329e-01
+ 896,7.575139512641269e-01,1.934986951820387e-01
+ 897,5.287143388200473e-01,5.782322357149935e-01
+ 898,5.867033646865525e-01,4.669232506596830e-01
+ 899,2.992648864061086e-01,6.921051749247162e-01
+ 900,4.297736990768725e-01,5.728550685156317e-01
+ 901,5.324371981204844e-01,4.207806379934187e-01
+ 902,7.257675953056200e-01,4.020845860758571e-01
+ 903,1.879954252086249e-01,8.546579493791754e-01
+ 904,4.122822555719840e-01,4.908270344378969e-01
+ 905,2.191347578313540e-01,7.163372367469281e-01
+ 906,6.740734398917126e-01,1.755356210273281e-01
+ 907,2.628553645867256e-01,7.321298281922535e-01
+ 908,7.083210343921672e-01,3.676362766112818e-01
+ 909,8.060816783601225e-01,1.516120628501609e-01
+ 910,2.808940229361895e-01,5.106409413500058e-01
+ 911,4.771818493845740e-01,4.104600320004564e-01
+ 912,7.084357081697855e-01,2.318164922699042e-01
+ 913,1.156837797512886e-01,9.354896896347006e-01
+ 914,5.886671046409062e-01,1.892407131906243e-01
+ 915,5.852038647203940e-01,2.957348656984148e-01
+ 916,9.105539317273688e-01,6.801002308350566e-02
+ 917,6.673258053636860e-01,2.931144015414146e-01
+ 918,4.482192395692550e-01,5.898750682101236e-01
+ 919,8.071314537186123e-01,1.615390198560502e-01
+ 920,6.711029288400133e-01,3.123136754960663e-01
+ 921,6.073558042592403e-01,3.922340386399608e-01
+ 922,3.407058661189132e-01,8.083052071576476e-01
+ 923,2.523928216828871e-01,7.913103611319280e-01
+ 924,8.838701581005104e-01,1.261629243539703e-01
+ 925,5.105278985209508e-02,8.195799967406682e-01
+ 926,5.998074162638929e-01,2.017907917076221e-01
+ 927,5.806518931155086e-01,4.372255910601216e-01
+ 928,3.623121262447698e-01,6.591691379926136e-01
+ 929,4.879318700393414e-01,4.440872169493103e-01
+ 930,2.482962555230609e-01,5.225300256514099e-01
+ 931,6.757619631405918e-01,4.049722457440886e-01
+ 932,5.907228251928178e-01,3.064188516210778e-01
+ 933,5.000728752759666e-01,4.803973618818705e-01
+ 934,1.607437241090218e-01,9.795108237369795e-01
+ 935,5.146812756748490e-01,3.856905194885036e-01
+ 936,2.524912264487579e-01,6.895783296226974e-01
+ 937,6.274140413985735e-01,3.498646558952737e-01
+ 938,8.129250121141816e-01,1.442182852460087e-01
+ 939,2.172198254178647e-01,7.523503283100627e-01
+ 940,7.722021702744759e-01,2.108428715503911e-01
+ 941,7.496263184894529e-01,3.195474593291527e-01
+ 942,5.554794795704521e-02,8.131451656580825e-01
+ 943,7.035362603559815e-01,3.422898326874487e-01
+ 944,4.053131277505309e-01,6.771074068585504e-01
+ 945,4.641051148630994e-01,5.238112458957275e-01
+ 946,5.802421316421370e-01,4.928327054519153e-01
+ 947,6.827018354858736e-01,2.873979209555624e-01
+ 948,3.283358867791817e-01,6.261397523159487e-01
+ 949,2.457659774195274e-01,7.249393847588759e-01
+ 950,5.110626403601016e-01,6.460922673019263e-01
+ 951,3.886175098745867e-01,5.153916047211686e-01
+ 952,1.612485587941002e-01,8.064779016936647e-01
+ 953,1.511082019700918e-01,8.736150504005777e-01
+ 954,6.276782700433758e-01,4.888242449347977e-01
+ 955,4.609900048015393e-01,4.953518386481305e-01
+ 956,7.571591573214030e-02,9.552132039188774e-01
+ 957,3.331014505821059e-01,7.236181075637697e-01
+ 958,5.646730405888282e-01,4.520749804652914e-01
+ 959,3.567126066553383e-01,5.960985976077381e-01
+ 960,1.793637306081737e-01,7.491979666457349e-01
+ 961,9.565812287885117e-01,1.179572860015537e-01
+ 962,9.070151921153716e-01,1.461637456658481e-01
+ 963,4.309379664896050e-01,4.416554011561883e-01
+ 964,1.512424270178359e-01,8.040192618348134e-01
+ 965,9.218316000877917e-01,4.689128265584886e-02
+ 966,2.369915198234892e-01,7.775337378551475e-01
+ 967,9.021077983837966e-01,6.144546847064154e-02
+ 968,4.380534666681625e-01,4.694776725355873e-01
+ 969,8.934229857890653e-01,1.240592819505655e-01
+ 970,9.362700218066637e-01,2.022150389133355e-01
+ 971,4.784344690117296e-01,3.843279143037167e-01
+ 972,4.246246293725525e-01,5.075912760337499e-01
+ 973,5.215668598963880e-01,5.157952308210058e-01
+ 974,7.294804920344798e-01,2.154113834720038e-01
+ 975,5.454977357569027e-01,4.195819833499564e-01
+ 976,6.273373135968571e-02,8.715219173633054e-01
+ 977,9.951434753138713e-01,3.369560211201914e-02
+ 978,2.836932904980107e-01,6.977497047075619e-01
+ 979,7.014974377834736e-01,2.382992333045957e-01
+ 980,7.217254661945463e-01,2.821856046433620e-01
+ 981,1.016830016088135e-01,9.476181113773414e-01
+ 982,2.064049493753210e-01,9.251973236981621e-01
+ 983,2.864957223622059e-01,8.536286369875722e-01
+ 984,1.117230527177739e-01,8.443987421412301e-01
+ 985,8.041409409161187e-01,1.471836131438423e-01
+ 986,6.073513609037643e-01,5.181385225899408e-01
+ 987,6.588851837199917e-01,4.052545877791234e-01
+ 988,7.062291433448370e-02,9.736689475071073e-01
+ 989,4.858820297526776e-01,4.417019008782969e-01
+ 990,1.287083043840976e-01,9.090723376772947e-01
+ 991,3.929849165354071e-01,6.034388904580810e-01
+ 992,9.899338358336806e-01,2.138284134673964e-01
+ 993,6.039387893772090e-01,2.579570971187624e-01
+ 994,7.545625703791708e-01,1.963943081219549e-01
+ 995,7.954571398953670e-01,1.880833239403513e-01
+ 996,4.477133529144070e-01,5.159250491634149e-01
+ 997,3.911265008684991e-01,7.290667370531243e-01
+ 998,7.368194117110248e-01,2.912140246556582e-01
+ 999,4.175301414668297e-01,5.524808971084969e-01
+ 1000,4.363426833709074e-01,5.382561619678203e-01
+ \.
+                         
+ SELECT ID FROM "a2d1000" SKYLINE OF d1 MIN, d2 MIN ORDER BY ID;
+ 
+ DROP TABLE IF EXISTS "a2d1000";
