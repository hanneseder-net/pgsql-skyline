%%%
%%% Introduction.
%%%

\svnInfo $Id$

\newcommand\schema[1]{\ensuremath{\mathcal{#1}}}
\newcommand\relation[1]{\ensuremath{\textnormal{\bf\textsf{#1}}}}

\newcommand\imp{\Rightarrow}

\newcommand\inlinesql[1]{{\tt #1}}
\newcommand\srcref[1]{{\tt #1}}
\newcommand\postgresdocu[2]{\href{http://www.postgresql.org/docs/8.3/static/#1}{#2}}

\newtheorem{definition}{Definition}
\newtheorem{lemma}{Lemma}

\chapter{Introduction\revision}
\label{chap:Introduction}

\todo{}{take some parts from the research planning intro}
The skyline operator \citep{Borzsonyi2001} filters out the \emph{interesting} points from a potentially large set of data points. The skyline operator returns the pareto optimal\index{pareto optimal} elements of a set. This is also know as maximum vector problem\index{maximum vector problem}.

Although we continously merging \texttt{CSV HEAD} of the \fixme{PostgreSQL source repository}{ref} 
into our main development branch, we decided to base this paper on branch \texttt{REL8\_3\_0}, 
in order to have a more stable and reproducibly setting, i.e. all experiments in this paper are based on version 8.3.0 of PostgreSQL with our patch for the skyline operator applied.

\section{Related Problems}
Convex hull\index{convex hull} is a related problem.



\newcommand\dominates{\ensuremath{\succ}\xspace}

\clearpage 
\fixme{}{no clearpage}
\section{Basic definitions}
\todo{We are in the context of relational model\index{relational model} of data}{\citep{Chomicki2002, Chomicki2003a}?}. As we aim at an implementation of the skyline operator into a relational database management system (RDBMS)\index{RDBMS} we restrict to finite database\index{finite database} instances.

We assume two infinite domains: $N$ (numbers) and $D$ (uninterpreted constants). The domain $D$ will be used for attributes which are not subject to skyline computation, i.e. for the travelling example we will not compute the skyline over the name of the airline, therefore $D$ will be used as domain for this attribute.
For attributes or expressions which are subject to skyline computation we use the domain $N$. No distinction is made between different numeric domains, since it is not necessary for this paper. For $N$ we require that equality ($=$), inequality ($\not=$), and the binary relations $<$ (strictly less than), $\le$ (less than or equal), $\ge$ (greater than or equal), and $>$ (strictly greater than) are defined with the usual properties.

\begin{definition}[Schema]
Given the domains $U_i, 1 \le i \le n$, such that $U_i$ is either equal to $D$ or $N$, we define the $n$-ary schema $\schema{R}$ as the cartesian product of the $U_i$'s, i.e. $\schema{R} = U_1 \times U_2 \times \ldots \times U_n$. The attributes of schema \schema{R} will be refered as $a_1, \ldots, a_n$.
\end{definition}

Preferences will be defined in terms of \emph{binary preference relations}\index{preference relation}.
\begin{definition}[Preference relation]
Let \schema{R} be a $n$-ary schema, a relation \dominates is a preference relation over \schema{R} if it is a subset of $\schema{R} \times \schema{R}$.
\end{definition}

To give an intuition, \dominates will be a binary relation between pairs of tuples from the same (database) relation, we say $r$ \emph{dominates} $s$ in \dominates iff $(r, s) \in \dominates$ (or in infix notation $r \dominates s$).

We require the relation \dominates to be a \emph{strict partial order}\index{strict partial order}, i.e. \dominates is irreflexive, asymmetric and transitive. These properties are formalized as usual:

\begin{itemize}
\item \emph{irreflexivity:} $\forall x: x \not\dominates x$
\item \emph{asymmetry:} $\forall x, y: x \dominates y \imp y \not\dominates x$
\item \emph{transitivity:} $\forall x, y, z: (x \dominates y \land y \dominates z) \imp x \dominates z$
\end{itemize}

Non-transitive\index{non-transitive} preferences can be compute with the \todo{Best}{special font for algo names?} algorithm (\citep{Torlone2002, Ciaccia2004}), we will not study this approach in this paper.

\begin{definition}
\todo{}{}Let \relation{R} be a relation of schema \schema{R}.
\end{definition}

\begin{definition}[Skyline]
The skyline of a relation \relation{R} with respect to the preference relation \dominates is the set of tuples $r \in \relation{R}$ which are not dominate by any other tuple $s \in \relation{R}$, formally $\skyline_\dominates(\relation{R}) := \{ r \in \relation{R} | \nexists s \in \relation{R} : s \dominates r \}$
\end{definition}

\begin{lemma}
\todo{}{this is more or less theorem 2 from \citep{Chomicki2002}}
Given the relation $\relation{R} \not= \emptyset$ and \dominates a strict parial order over \schema{R}, where \schema{R} is the schema for \relation{R}, the skyline is non empty, i.e. $\skyline_\dominates(\relation{R}) \not= \emptyset$ holds.
\end{lemma}

Our implementation of the \inlinesql{SKYLINE OF} clause is actually a bit more flexible than the mathematical definition given above. With our implementation the skyline operator is not restricted to attributes with a numerical domain, it can be applied to any attribute, as long as a \emph{sort function} is defined for the domain in question, i.e.\/ any expression valid in a SQL \inlinesql{ORDER BY} clause is valid as an expression in a \inlinesql{SKYLINE OF} clause.

This gives the opportunity to include expressions of almost any data type in a skyline query, even user defined ones. For more information on user defined data types see PostgreSQL documentation on \postgresdocu{xtypes.html}{User-Defined Types} and \postgresdocu{xindex.html\#XINDEX-OPFAMILY}{Operator Classes and Operator Families}

Anyway it is somewhat questionable what it is good for the include a e.g. \inlinesql{VARCHAR} column in a skyline query, still it is possible.

\subsection{Monoton vs. linear scoring functions}
see \citep{Chomicki2002a} page 5, Theorem 4

\section{Preliminaris}
\section{Existing Methods and Related Works}
\section{Skyline Algorithms}
\subsection{BNL}
\subsection{SFS}
\subsection{LESS}

\section{Implementation}
pseudo code

\subsection{Sampling}

sampling --> min / max  ---> (0,1) --> ln   --> sum

\subsection{Cardinality and Cost Estimation}


\section{SQL Extension}

In this section we explain the syntax and the semantics of the SQL
extension we implemened in order to support the skyline operator. The
extended query syntax resembles the syntax proposed in
\citep{Borzsonyi2001}.

To describe the syntax we use 
\subsection{Railroad Diagrams}

\railalias{selectclause}{select\_clause}
\railalias{targetlist}{target\_list}
\railalias{intoclause}{into\_clause}
\railalias{fromclause}{from\_clause}
\railalias{whereclause}{where\_clause}
\railalias{groupclause}{group\_clause}
\railalias{havingclause}{having\_clause}
\railalias{skylineclause}{skyline\_clause}
\railalias{sortclause}{sort\_clause}
\railalias{qualOp}{qual\_Op}
\railalias{cexpr}{c\_expr}

% \railparam{\thinline}
% \railparam{\thicklines}
\railtermfont{\ttfamily\upshape\tiny}
\railboxheight 12pt
\railinit

\begin{rail}

selectclause : 'SELECT' 'DISTINCT'? targetlist intoclause ? fromclause \\ whereclause ? ( groupclause havingclause ? ) ? \\ skylineclause ? sortclause ? ';';
skylineclause : 'SKYLINE' ( 'BY' | 'ON' ) 'DISTINCT' ? ( skylineexpr + ',' ) skylineoptions ?;
skylineexpr: cexpr ( 'MIN' | 'MAX' | 'DIFF' | 'USING' qualOp ) (() | 'NULLS FIRST' | 'NULLS LAST') ;
skylineoptions : 'WITH' ('EF' (('EFSLOTS' '=' slots) | (('EFWINDOW' | 'EFWINDOWSIZE') '=' windowsize ) ) ?) ? \\ ( (('BNL' | 'SFS') windowoptions ?) | 'PRESORT') ? ;
windowoptions : ( 'SLOTS' '=' slots ) | (('WINDOW' | 'WINDOWSIZE') '=' windowsize ) ;

\end{rail}


In fact we defined the grammar a bit different\footnote{see \srcref{src/backend/parser/gram.y} for details}, this is because \fixme{SQL92}{ref:SQL92} requires the following statement:
\begin{sql}SELECT foo UNION SELECT bar ORDER BY baz\end{sql}
to be parsed as 
\begin{sql}(SELECT foo UNION SELECT bar) ORDER BY baz\end{sql}
and not as
\begin{sql}SELECT foo UNION (SELECT bar ORDER BY baz)\end{sql}

\noindent{}For the \inlinesql{SKYLINE OF} clause we decided that the it should be left
assoziative, i.e. 
\begin{sql}SELECT * FROM foo UNION SELECT * FROM bar SKYLINE OF baz\end{sql}
will be parsed as 
\begin{sql}SELECT * FROM foo UNION (SELECT * FROM bar SKYLINE0 OF baz)\end{sql}

\noindent{}We did so, because we believe the \inlinesql{SKYLINE OF} clause is closer
related to the \inlinesql{GROUP BY} clause than to the \inlinesql{ORDER BY}
clause, therefore we parse it in the same way.

\chapter{Results\revision}
\label{chap:Results}

\section{Experiments}

\subsection{Random Dataset Generator}

\chapter*{Summary\revision}
\addcontentsline{toc}{chapter}{Summary\revision}



